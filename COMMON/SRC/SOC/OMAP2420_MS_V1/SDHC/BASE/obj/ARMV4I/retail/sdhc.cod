; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\SDHC\BASE\sdhc.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_TWL_GUID| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
	%	16
|gwaCMD| DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x0
	DCW	0x2000
	DCW	0x0
	DCB	0x0
	DCB	0x0
	DCB	0x1
	%	1
	DCW	0x1000
	DCW	0x2000
	DCW	0x1040
	DCB	0x1
	DCB	0x0
	DCB	0x1
	%	1
	DCW	0x1000
	DCW	0x2000
	DCW	0x1040
	DCB	0x1
	DCB	0x0
	DCB	0x1
	%	1
	DCW	0x1000
	DCW	0x2000
	DCW	0x1040
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x0
	DCW	0x2000
	DCW	0x0
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x1000
	DCW	0x2000
	DCW	0x1000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x1
	%	1
	DCW	0xf000
	DCW	0x2000
	DCW	0xf040
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x3000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x1
	%	1
	DCW	0x7000
	DCW	0x2000
	DCW	0x7000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x3000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x1
	DCB	0x1
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2040
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x1000
	DCW	0x1000
	DCW	0x1000
	DCB	0x1
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x1
	DCB	0x0
	%	1
	DCW	0xb000
	DCW	0x3000
	DCW	0xb000
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x2
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x1
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x3000
	DCW	0x2000
	DCW	0x3000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	DCB	0x0
	DCB	0x0
	DCB	0x0
	%	1
	DCW	0x2000
	DCW	0x2000
	DCW	0x2000
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41881| DCD	|$LN5@SetEvent|
	DCD	0x40000e04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M41878|

; 236  : 	return EventModify(h,EVENT_SET);

  00010	e3a01003	 mov         r1, #3
  00014	e59d0010	 ldr         r0, [sp, #0x10]
  00018	eb000000	 bl          EventModify
  0001c	e58d0004	 str         r0, [sp, #4]
  00020	e59d3004	 ldr         r3, [sp, #4]
  00024	e58d3000	 str         r3, [sp]

; 237  : }

  00028	e59d0000	 ldr         r0, [sp]
  0002c	e28dd008	 add         sp, sp, #8
  00030	e89d6000	 ldmia       sp, {sp, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M41879|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T41889| DCD	|$LN5@GetCurrent|
	DCD	0x40000601
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M41886|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00004	e3a03041	 mov         r3, #0x41
  00008	e58d3000	 str         r3, [sp]

; 353  : }

  0000c	e59d0000	 ldr         r0, [sp]
  00010	e28dd004	 add         sp, sp, #4
  00014	e12fff1e	 bx          lr
  00018		 |$M41887|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|?ZeroEntries@CReg@@AAAXXZ|		; CReg::ZeroEntries
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T41896| DCD	|$LN5@ZeroEntrie|
	DCD	0x40001403
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ZeroEntries@CReg@@AAAXXZ| PROC	; CReg::ZeroEntries

; 35   : 	void ZeroEntries() {

  00000		 |$LN5@ZeroEntrie|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M41893|

; 36   : 		m_hKey      = NULL;

  0000c	e59d2008	 ldr         r2, [sp, #8]
  00010	e3a03000	 mov         r3, #0
  00014	e5823000	 str         r3, [r2]

; 37   : 		m_Index     = 0;

  00018	e59d3008	 ldr         r3, [sp, #8]
  0001c	e2832004	 add         r2, r3, #4
  00020	e3a03000	 mov         r3, #0
  00024	e5823000	 str         r3, [r2]

; 38   : 		m_lpbValue  = NULL;

  00028	e59d3008	 ldr         r3, [sp, #8]
  0002c	e2832008	 add         r2, r3, #8
  00030	e3a03000	 mov         r3, #0
  00034	e5823000	 str         r3, [r2]

; 39   : 		m_iValueLen = 0;

  00038	e59d3008	 ldr         r3, [sp, #8]
  0003c	e283200c	 add         r2, r3, #0xC
  00040	e3a03000	 mov         r3, #0
  00044	e5823000	 str         r3, [r2]

; 40   : 	}

  00048	e89d6000	 ldmia       sp, {sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M41894|

			 ENDP  ; |?ZeroEntries@CReg@@AAAXXZ|, CReg::ZeroEntries

	EXPORT	|??0CReg@@QAA@XZ|			; CReg::CReg

  00000			 AREA	 |.pdata|, PDATA
|$T41907| DCD	|$LN7@CReg|
	DCD	0x40001904
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CReg@@QAA@XZ| PROC			; CReg::CReg

; 63   : 	CReg() {

  00000		 |$LN7@CReg|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M41904|

; 64   : 		ZeroEntries();

  00010	e59d200c	 ldr         r2, [sp, #0xC]
  00014	e3a03000	 mov         r3, #0
  00018	e5823000	 str         r3, [r2]
  0001c	e59d300c	 ldr         r3, [sp, #0xC]
  00020	e2832004	 add         r2, r3, #4
  00024	e3a03000	 mov         r3, #0
  00028	e5823000	 str         r3, [r2]
  0002c	e59d300c	 ldr         r3, [sp, #0xC]
  00030	e2832008	 add         r2, r3, #8
  00034	e3a03000	 mov         r3, #0
  00038	e5823000	 str         r3, [r2]
  0003c	e59d300c	 ldr         r3, [sp, #0xC]
  00040	e283200c	 add         r2, r3, #0xC
  00044	e3a03000	 mov         r3, #0
  00048	e5823000	 str         r3, [r2]

; 65   : 	}

  0004c	e59d300c	 ldr         r3, [sp, #0xC]
  00050	e58d3000	 str         r3, [sp]
  00054	e59d0000	 ldr         r0, [sp]
  00058	e28dd004	 add         sp, sp, #4
  0005c	e89d6000	 ldmia       sp, {sp, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M41905|

			 ENDP  ; |??0CReg@@QAA@XZ|, CReg::CReg

	EXPORT	|??1CReg@@QAA@XZ|			; CReg::~CReg
	IMPORT	|LocalFree|
	IMPORT	|RegCloseKey|

  00000			 AREA	 |.pdata|, PDATA
|$T41914| DCD	|$LN7@CReg@2|
	DCD	0x40001503
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CReg@@QAA@XZ| PROC			; CReg::~CReg

; 67   : 	~CReg() { 

  00000		 |$LN7@CReg@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M41911|

; 68   : 		if(m_hKey) RegCloseKey(m_hKey); 

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e5933000	 ldr         r3, [r3]
  00014	e3530000	 cmp         r3, #0
  00018	0a000002	 beq         |$LN2@CReg@2|
  0001c	e59d3008	 ldr         r3, [sp, #8]
  00020	e5930000	 ldr         r0, [r3]
  00024	eb000000	 bl          RegCloseKey
  00028		 |$LN2@CReg@2|

; 69   : 		if (m_lpbValue) {

  00028	e59d3008	 ldr         r3, [sp, #8]
  0002c	e2833008	 add         r3, r3, #8
  00030	e5933000	 ldr         r3, [r3]
  00034	e3530000	 cmp         r3, #0
  00038	0a000003	 beq         |$LN1@CReg@2|

; 70   : 			ASSERT(m_iValueLen != 0);
; 71   : 			LocalFree(m_lpbValue);

  0003c	e59d3008	 ldr         r3, [sp, #8]
  00040	e2833008	 add         r3, r3, #8
  00044	e5930000	 ldr         r0, [r3]
  00048	eb000000	 bl          LocalFree
  0004c		 |$LN1@CReg@2|

; 72   : 		}
; 73   : 	}

  0004c	e89d6000	 ldmia       sp, {sp, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M41912|

			 ENDP  ; |??1CReg@@QAA@XZ|, CReg::~CReg

	EXPORT	|?Reset@CReg@@QAAXXZ|			; CReg::Reset

  00000			 AREA	 |.pdata|, PDATA
|$T41921| DCD	|$LN6@Reset|
	DCD	0x40001303
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Reset@CReg@@QAAXXZ| PROC		; CReg::Reset

; 75   : 	void Reset() { 

  00000		 |$LN6@Reset|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M41918|

; 76   : 		if(m_hKey) {

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e5933000	 ldr         r3, [r3]
  00014	e3530000	 cmp         r3, #0
  00018	0a000005	 beq         |$LN1@Reset|

; 77   : 			RegCloseKey(m_hKey); 

  0001c	e59d3008	 ldr         r3, [sp, #8]
  00020	e5930000	 ldr         r0, [r3]
  00024	eb000000	 bl          RegCloseKey

; 78   : 			m_hKey = NULL;

  00028	e59d2008	 ldr         r2, [sp, #8]
  0002c	e3a03000	 mov         r3, #0
  00030	e5823000	 str         r3, [r2]
  00034		 |$LN1@Reset|

; 79   : 		}
; 80   : 		m_Index = 0;

  00034	e59d3008	 ldr         r3, [sp, #8]
  00038	e2832004	 add         r2, r3, #4
  0003c	e3a03000	 mov         r3, #0
  00040	e5823000	 str         r3, [r2]

; 81   : 	}

  00044	e89d6000	 ldmia       sp, {sp, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M41919|

			 ENDP  ; |?Reset@CReg@@QAAXXZ|, CReg::Reset

	EXPORT	|?ValueDW@CReg@@QAAKPBGK@Z|		; CReg::ValueDW
	IMPORT	|RegQueryValueExW|

  00000			 AREA	 |.pdata|, PDATA
|$T41931| DCD	|$LN6@ValueDW|
	DCD	0x40001c04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ValueDW@CReg@@QAAKPBGK@Z| PROC	; CReg::ValueDW

; 197  : 	DWORD ValueDW(LPCTSTR szName, DWORD dwDefault=0) {

  00000		 |$LN6@ValueDW|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd01c	 sub         sp, sp, #0x1C
  00010		 |$M41928|

; 198  : 		DWORD dwValue = dwDefault;

  00010	e59d302c	 ldr         r3, [sp, #0x2C]
  00014	e58d3008	 str         r3, [sp, #8]

; 199  : 		if(m_hKey) 

  00018	e59d3024	 ldr         r3, [sp, #0x24]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e3530000	 cmp         r3, #0
  00024	0a00000b	 beq         |$LN1@ValueDW|

; 200  : 		{
; 201  : 			DWORD dwLen = sizeof(DWORD);

  00028	e3a03004	 mov         r3, #4
  0002c	e58d300c	 str         r3, [sp, #0xC]

; 202  : 			RegQueryValueEx(m_hKey, szName, NULL, NULL, (LPBYTE)&dwValue, &dwLen);

  00030	e28d300c	 add         r3, sp, #0xC
  00034	e58d3004	 str         r3, [sp, #4]
  00038	e28d3008	 add         r3, sp, #8
  0003c	e58d3000	 str         r3, [sp]
  00040	e3a03000	 mov         r3, #0
  00044	e3a02000	 mov         r2, #0
  00048	e59d1028	 ldr         r1, [sp, #0x28]
  0004c	e59d0024	 ldr         r0, [sp, #0x24]
  00050	e5900000	 ldr         r0, [r0]
  00054	eb000000	 bl          RegQueryValueExW
  00058		 |$LN1@ValueDW|

; 203  : 		}
; 204  : 		return dwValue;

  00058	e59d3008	 ldr         r3, [sp, #8]
  0005c	e58d3018	 str         r3, [sp, #0x18]

; 205  : 	}

  00060	e59d0018	 ldr         r0, [sp, #0x18]
  00064	e28dd01c	 add         sp, sp, #0x1C
  00068	e89d6000	 ldmia       sp, {sp, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M41929|

			 ENDP  ; |?ValueDW@CReg@@QAAKPBGK@Z|, CReg::ValueDW

	EXPORT	|?DumpRegisters@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::DumpRegisters
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.h

  00000			 AREA	 |.pdata|, PDATA
|$T41938| DCD	|$LN5@DumpRegist|
	DCD	0x40000503
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DumpRegisters@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::DumpRegisters

; 141  :     VOID DumpRegisters() {}

  00000		 |$LN5@DumpRegist|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M41935|
  0000c	e89d6000	 ldmia       sp, {sp, lr}
  00010	e12fff1e	 bx          lr
  00014		 |$M41936|

			 ENDP  ; |?DumpRegisters@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::DumpRegisters

	EXPORT	|??_C@_1M@MOBNNOLN@?$AAT?$AAW?$AAL?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|TWLOpen|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\twl.h

  00000			 AREA	 |.pdata|, PDATA
|$T41953| DCD	|$LN11@TWLOpen|
	DCD	0x40004a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@MOBNNOLN@?$AAT?$AAW?$AAL?$AA1?$AA?3?$AA?$AA@| DCB "T", 0x0, "W", 0x0
	DCB	"L", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWLOpen| PROC

; 123  : {

  00000		 |$LN11@TWLOpen|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M41950|

; 124  :     HANDLE hDevice;
; 125  :     DEVICE_CONTEXT_TWL *pContext = NULL;

  00008	e3a03000	 mov         r3, #0
  0000c	e58d3014	 str         r3, [sp, #0x14]

; 126  : 
; 127  :     hDevice = CreateFile(TWL_DEVICE_NAME, 0, 0, NULL, 0, 0, NULL);

  00010	e3a03000	 mov         r3, #0
  00014	e58d3008	 str         r3, [sp, #8]
  00018	e3a03000	 mov         r3, #0
  0001c	e58d3004	 str         r3, [sp, #4]
  00020	e3a03000	 mov         r3, #0
  00024	e58d3000	 str         r3, [sp]
  00028	e3a03000	 mov         r3, #0
  0002c	e3a02000	 mov         r2, #0
  00030	e3a01000	 mov         r1, #0
  00034	e59f00e8	 ldr         r0, [pc, #0xE8]
  00038	eb000000	 bl          CreateFileW
  0003c	e58d0038	 str         r0, [sp, #0x38]
  00040	e59d3038	 ldr         r3, [sp, #0x38]
  00044	e58d3010	 str         r3, [sp, #0x10]

; 128  :     if (hDevice == INVALID_HANDLE_VALUE) goto cleanUp;

  00048	e59d3010	 ldr         r3, [sp, #0x10]
  0004c	e3730001	 cmn         r3, #1
  00050	1a000001	 bne         |$LN6@TWLOpen|
  00054	ea00002b	 b           |$LN5@TWLOpen|
  00058	ea00002a	 b           |$cleanUp$39913|
  0005c		 |$LN6@TWLOpen|

; 129  : 
; 130  :     // Allocate memory for our handler...
; 131  :     pContext = (DEVICE_CONTEXT_TWL*)LocalAlloc(
; 132  :         LPTR, sizeof(DEVICE_CONTEXT_TWL)
; 133  :         );

  0005c	e3a01020	 mov         r1, #0x20
  00060	e3a00040	 mov         r0, #0x40
  00064	eb000000	 bl          LocalAlloc
  00068	e58d003c	 str         r0, [sp, #0x3C]
  0006c	e59d303c	 ldr         r3, [sp, #0x3C]
  00070	e58d3014	 str         r3, [sp, #0x14]

; 134  :     if (pContext == NULL)

  00074	e59d3014	 ldr         r3, [sp, #0x14]
  00078	e3530000	 cmp         r3, #0
  0007c	1a000003	 bne         |$LN4@TWLOpen|

; 135  :         {
; 136  :         CloseHandle(hDevice);

  00080	e59d0010	 ldr         r0, [sp, #0x10]
  00084	eb000000	 bl          CloseHandle
  00088	ea00001e	 b           |$LN3@TWLOpen|

; 137  :         goto cleanUp;

  0008c	ea00001d	 b           |$cleanUp$39913|
  00090		 |$LN4@TWLOpen|

; 138  :         }
; 139  : 
; 140  :     // Get function pointers, fail when IOCTL isn't supported...
; 141  :     if (!DeviceIoControl(
; 142  :             hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_TWL_GUID,
; 143  :             sizeof(DEVICE_IFC_TWL_GUID), &pContext->ifc, sizeof(DEVICE_IFC_TWL),
; 144  :             NULL, NULL))

  00090	e3a03000	 mov         r3, #0
  00094	e58d300c	 str         r3, [sp, #0xC]
  00098	e3a03000	 mov         r3, #0
  0009c	e58d3008	 str         r3, [sp, #8]
  000a0	e3a0301c	 mov         r3, #0x1C
  000a4	e58d3004	 str         r3, [sp, #4]
  000a8	e59d3014	 ldr         r3, [sp, #0x14]
  000ac	e58d3000	 str         r3, [sp]
  000b0	e3a03010	 mov         r3, #0x10
  000b4	e59f2064	 ldr         r2, [pc, #0x64]
  000b8	e3a01822	 mov         r1, #0x22, 16
  000bc	e3811b01	 orr         r1, r1, #1, 22
  000c0	e59d0010	 ldr         r0, [sp, #0x10]
  000c4	eb000000	 bl          DeviceIoControl
  000c8	e58d0040	 str         r0, [sp, #0x40]
  000cc	e59d3040	 ldr         r3, [sp, #0x40]
  000d0	e3530000	 cmp         r3, #0
  000d4	1a000007	 bne         |$LN2@TWLOpen|

; 145  :         {
; 146  :         CloseHandle(hDevice);

  000d8	e59d0010	 ldr         r0, [sp, #0x10]
  000dc	eb000000	 bl          CloseHandle

; 147  :         LocalFree(pContext);

  000e0	e59d0014	 ldr         r0, [sp, #0x14]
  000e4	eb000000	 bl          LocalFree

; 148  :         pContext = NULL;

  000e8	e3a03000	 mov         r3, #0
  000ec	e58d3014	 str         r3, [sp, #0x14]
  000f0	ea000004	 b           |$LN1@TWLOpen|

; 149  :         goto cleanUp;

  000f4	ea000003	 b           |$cleanUp$39913|
  000f8		 |$LN2@TWLOpen|

; 150  :         }
; 151  : 
; 152  :     // Save device handle
; 153  :     pContext->hDevice = hDevice;

  000f8	e59d3014	 ldr         r3, [sp, #0x14]
  000fc	e283201c	 add         r2, r3, #0x1C
  00100	e59d3010	 ldr         r3, [sp, #0x10]
  00104	e5823000	 str         r3, [r2]
  00108		 |$LN1@TWLOpen|
  00108		 |$LN3@TWLOpen|
  00108		 |$LN5@TWLOpen|
  00108		 |$cleanUp$39913|

; 154  : 
; 155  : cleanUp:
; 156  :     return pContext;

  00108	e59d3014	 ldr         r3, [sp, #0x14]
  0010c	e58d3034	 str         r3, [sp, #0x34]

; 157  : }

  00110	e59d0034	 ldr         r0, [sp, #0x34]
  00114	e28dd044	 add         sp, sp, #0x44
  00118	e49de004	 ldr         lr, [sp], #4
  0011c	e12fff1e	 bx          lr
  00120		 |$LN12@TWLOpen|
  00120		 |$LN13@TWLOpen|
  00120	00000000	 DCD         |DEVICE_IFC_TWL_GUID|
  00124		 |$LN14@TWLOpen|
  00124	00000000	 DCD         |??_C@_1M@MOBNNOLN@?$AAT?$AAW?$AAL?$AA1?$AA?3?$AA?$AA@|
  00128		 |$M41951|

			 ENDP  ; |TWLOpen|

	EXPORT	|TWLClose|

  00000			 AREA	 |.pdata|, PDATA
|$T41963| DCD	|$LN5@TWLClose|
	DCD	0x40000f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWLClose| PROC

; 164  : {

  00000		 |$LN5@TWLClose|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M41960|

; 165  :     DEVICE_CONTEXT_TWL *pContext = (DEVICE_CONTEXT_TWL*)hContext;

  00010	e59d300c	 ldr         r3, [sp, #0xC]
  00014	e58d3000	 str         r3, [sp]

; 166  :     CloseHandle(pContext->hDevice);

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e283301c	 add         r3, r3, #0x1C
  00020	e5930000	 ldr         r0, [r3]
  00024	eb000000	 bl          CloseHandle

; 167  :     LocalFree(pContext);

  00028	e59d0000	 ldr         r0, [sp]
  0002c	eb000000	 bl          LocalFree

; 168  : }

  00030	e28dd004	 add         sp, sp, #4
  00034	e89d6000	 ldmia       sp, {sp, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M41961|

			 ENDP  ; |TWLClose|

	EXPORT	|TWLSetIntrEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T41971| DCD	|$LN5@TWLSetIntr|
	DCD	0x40001604
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWLSetIntrEvent| PROC

; 204  : {

  00000		 |$LN5@TWLSetIntr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M41968|

; 205  :     DEVICE_CONTEXT_TWL *pContext = (DEVICE_CONTEXT_TWL*)hContext;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e58d3000	 str         r3, [sp]

; 206  :     return pContext->ifc.pfnSetIntrEvent(
; 207  :         pContext->ifc.context, intrId, hEvent
; 208  :         );

  00018	e59d201c	 ldr         r2, [sp, #0x1C]
  0001c	e59d1018	 ldr         r1, [sp, #0x18]
  00020	e59d3000	 ldr         r3, [sp]
  00024	e5930000	 ldr         r0, [r3]
  00028	e59d3000	 ldr         r3, [sp]
  0002c	e283300c	 add         r3, r3, #0xC
  00030	e5933000	 ldr         r3, [r3]
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3
  0003c	e58d0008	 str         r0, [sp, #8]
  00040	e59d3008	 ldr         r3, [sp, #8]
  00044	e58d3004	 str         r3, [sp, #4]

; 209  : }

  00048	e59d0004	 ldr         r0, [sp, #4]
  0004c	e28dd00c	 add         sp, sp, #0xC
  00050	e89d6000	 ldmia       sp, {sp, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M41969|

			 ENDP  ; |TWLSetIntrEvent|

	EXPORT	|TWLIntrEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T41979| DCD	|$LN5@TWLIntrEna|
	DCD	0x40001504
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWLIntrEnable| PROC

; 217  : {

  00000		 |$LN5@TWLIntrEna|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M41976|

; 218  :     DEVICE_CONTEXT_TWL *pContext = (DEVICE_CONTEXT_TWL*)hContext;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e58d3000	 str         r3, [sp]

; 219  :     return pContext->ifc.pfnIntrEnable(pContext->ifc.context, intrId);

  00018	e59d1018	 ldr         r1, [sp, #0x18]
  0001c	e59d3000	 ldr         r3, [sp]
  00020	e5930000	 ldr         r0, [r3]
  00024	e59d3000	 ldr         r3, [sp]
  00028	e2833010	 add         r3, r3, #0x10
  0002c	e5933000	 ldr         r3, [r3]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3
  00038	e58d0008	 str         r0, [sp, #8]
  0003c	e59d3008	 ldr         r3, [sp, #8]
  00040	e58d3004	 str         r3, [sp, #4]

; 220  : }

  00044	e59d0004	 ldr         r0, [sp, #4]
  00048	e28dd00c	 add         sp, sp, #0xC
  0004c	e89d6000	 ldmia       sp, {sp, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M41977|

			 ENDP  ; |TWLIntrEnable|

	EXPORT	|TWLIntrDisable|

  00000			 AREA	 |.pdata|, PDATA
|$T41987| DCD	|$LN5@TWLIntrDis|
	DCD	0x40001504
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWLIntrDisable| PROC

; 228  : {

  00000		 |$LN5@TWLIntrDis|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M41984|

; 229  :     DEVICE_CONTEXT_TWL *pContext = (DEVICE_CONTEXT_TWL*)hContext;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e58d3000	 str         r3, [sp]

; 230  :     return pContext->ifc.pfnIntrDisable(pContext->ifc.context, intrId);

  00018	e59d1018	 ldr         r1, [sp, #0x18]
  0001c	e59d3000	 ldr         r3, [sp]
  00020	e5930000	 ldr         r0, [r3]
  00024	e59d3000	 ldr         r3, [sp]
  00028	e2833014	 add         r3, r3, #0x14
  0002c	e5933000	 ldr         r3, [r3]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3
  00038	e58d0008	 str         r0, [sp, #8]
  0003c	e59d3008	 ldr         r3, [sp, #8]
  00040	e58d3004	 str         r3, [sp, #4]

; 231  : }

  00044	e59d0004	 ldr         r0, [sp, #4]
  00048	e28dd00c	 add         sp, sp, #0xC
  0004c	e89d6000	 ldmia       sp, {sp, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M41985|

			 ENDP  ; |TWLIntrDisable|

	EXPORT	|??_7CSDIOControllerBase@@6B@| [ DATA ]	; CSDIOControllerBase::`vftable'
	EXPORT	|??0CSDIOControllerBase@@QAA@XZ|	; CSDIOControllerBase::CSDIOControllerBase
	EXPORT	|?IndicateBusRequestComplete@CSDIOControllerBase@@UAAXPAU_SD_BUS_REQUEST@@J@Z| ; CSDIOControllerBase::IndicateBusRequestComplete
	EXPORT	|?GetRegistrySettings@CSDIOControllerBase@@UAAHPAVCReg@@@Z| ; CSDIOControllerBase::GetRegistrySettings
	EXPORT	|?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ| ; CSDIOControllerBase::InterpretCapabilities
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??_ECSDIOControllerBase@@UAAPAXI@Z|, WEAK |??_GCSDIOControllerBase@@UAAPAXI@Z| ; CSDIOControllerBase::`vector deleting destructor', CSDIOControllerBase::`scalar deleting destructor'
	IMPORT	|_purecall|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T41995| DCD	|$LN5@CSDIOContr|
	DCD	0x40005e04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CSDIOControllerBase@@6B@| DCD |??_ECSDIOControllerBase@@UAAPAXI@Z| ; CSDIOControllerBase::`vftable'
	DCD	|?IndicateBusRequestComplete@CSDIOControllerBase@@UAAXPAU_SD_BUS_REQUEST@@J@Z|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?GetRegistrySettings@CSDIOControllerBase@@UAAHPAVCReg@@@Z|
	DCD	|?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ|
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CSDIOControllerBase@@QAA@XZ| PROC	; CSDIOControllerBase::CSDIOControllerBase

; 168  : {

  00000		 |$LN5@CSDIOContr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M41992|
  00010	e59f215c	 ldr         r2, [pc, #0x15C]
  00014	e59d300c	 ldr         r3, [sp, #0xC]
  00018	e5832000	 str         r2, [r3]

; 169  :     InitializeCriticalSection( &m_critSec );

  0001c	e59d300c	 ldr         r3, [sp, #0xC]
  00020	e2830014	 add         r0, r3, #0x14
  00024	eb000000	 bl          InitializeCriticalSection

; 170  :     m_fSDIOInterruptInService = FALSE;

  00028	e59d300c	 ldr         r3, [sp, #0xC]
  0002c	e2832028	 add         r2, r3, #0x28
  00030	e3a03000	 mov         r3, #0
  00034	e5823000	 str         r3, [r2]

; 171  :     m_fFirstTime = TRUE;

  00038	e59d300c	 ldr         r3, [sp, #0xC]
  0003c	e2832080	 add         r2, r3, #0x80
  00040	e3a03001	 mov         r3, #1
  00044	e5823000	 str         r3, [r2]

; 172  :     m_hControllerISTEvent = NULL;

  00048	e59d300c	 ldr         r3, [sp, #0xC]
  0004c	e2832048	 add         r2, r3, #0x48
  00050	e3a03000	 mov         r3, #0
  00054	e5823000	 str         r3, [r2]

; 173  :     m_htControllerIST = NULL;

  00058	e59d300c	 ldr         r3, [sp, #0xC]
  0005c	e283204c	 add         r2, r3, #0x4C
  00060	e3a03000	 mov         r3, #0
  00064	e5823000	 str         r3, [r2]

; 174  :     m_dwControllerSysIntr = SYSINTR_UNDEFINED;

  00068	e59d300c	 ldr         r3, [sp, #0xC]
  0006c	e283206c	 add         r2, r3, #0x6C
  00070	e3e03000	 mvn         r3, #0
  00074	e5823000	 str         r3, [r2]

; 175  :     m_hCardDetectEvent = NULL;

  00078	e59d300c	 ldr         r3, [sp, #0xC]
  0007c	e2832050	 add         r2, r3, #0x50
  00080	e3a03000	 mov         r3, #0
  00084	e5823000	 str         r3, [r2]

; 176  :     m_htCardDetectIST = NULL;

  00088	e59d300c	 ldr         r3, [sp, #0xC]
  0008c	e2832054	 add         r2, r3, #0x54
  00090	e3a03000	 mov         r3, #0
  00094	e5823000	 str         r3, [r2]

; 177  :     m_dwCardDetectSysIntr = SYSINTR_UNDEFINED;

  00098	e59d300c	 ldr         r3, [sp, #0xC]
  0009c	e2832068	 add         r2, r3, #0x68
  000a0	e3e03000	 mvn         r3, #0
  000a4	e5823000	 str         r3, [r2]

; 178  :     m_dwCardDetectSysIRQSize = -1;

  000a8	e59d300c	 ldr         r3, [sp, #0xC]
  000ac	e2832064	 add         r2, r3, #0x64
  000b0	e3e03000	 mvn         r3, #0
  000b4	e5823000	 str         r3, [r2]

; 179  :     m_fAppCmdMode = FALSE;

  000b8	e59d300c	 ldr         r3, [sp, #0xC]
  000bc	e2832044	 add         r2, r3, #0x44
  000c0	e3a03000	 mov         r3, #0
  000c4	e5823000	 str         r3, [r2]

; 180  : 
; 181  :     m_vpSDIOReg = NULL;

  000c8	e59d300c	 ldr         r3, [sp, #0xC]
  000cc	e2832088	 add         r2, r3, #0x88
  000d0	e3a03000	 mov         r3, #0
  000d4	e5823000	 str         r3, [r2]

; 182  :     m_fCardPresent = FALSE;

  000d8	e59d300c	 ldr         r3, [sp, #0xC]
  000dc	e2832038	 add         r2, r3, #0x38
  000e0	e3a03000	 mov         r3, #0
  000e4	e5823000	 str         r3, [r2]

; 183  :     m_fSDIOInterruptsEnabled = FALSE;

  000e8	e59d300c	 ldr         r3, [sp, #0xC]
  000ec	e283203c	 add         r2, r3, #0x3C
  000f0	e3a03000	 mov         r3, #0
  000f4	e5823000	 str         r3, [r2]

; 184  :     
; 185  :     m_dwMaxTimeout = DEFAULT_TIMEOUT_VALUE;

  000f8	e59d300c	 ldr         r3, [sp, #0xC]
  000fc	e283207c	 add         r2, r3, #0x7C
  00100	e3a03cea	 mov         r3, #0xEA, 24
  00104	e3833060	 orr         r3, r3, #0x60
  00108	e5823000	 str         r3, [r2]

; 186  :     m_bReinsertTheCard = FALSE;

  0010c	e59d300c	 ldr         r3, [sp, #0xC]
  00110	e283202c	 add         r2, r3, #0x2C
  00114	e3a03000	 mov         r3, #0
  00118	e5823000	 str         r3, [r2]

; 187  :     m_dwWakeupSources = 0;

  0011c	e59d300c	 ldr         r3, [sp, #0xC]
  00120	e2832030	 add         r2, r3, #0x30
  00124	e3a03000	 mov         r3, #0
  00128	e5823000	 str         r3, [r2]

; 188  :     m_dwCurrentWakeupSources = 0;

  0012c	e59d300c	 ldr         r3, [sp, #0xC]
  00130	e2832034	 add         r2, r3, #0x34
  00134	e3a03000	 mov         r3, #0
  00138	e5823000	 str         r3, [r2]

; 189  :     m_fMMCMode = FALSE;

  0013c	e59d300c	 ldr         r3, [sp, #0xC]
  00140	e2832040	 add         r2, r3, #0x40
  00144	e3a03000	 mov         r3, #0
  00148	e5823000	 str         r3, [r2]

; 190  : 
; 191  :     m_PowerState = D0;

  0014c	e59d300c	 ldr         r3, [sp, #0xC]
  00150	e2832010	 add         r2, r3, #0x10
  00154	e3a03000	 mov         r3, #0
  00158	e5823000	 str         r3, [r2]

; 192  : }

  0015c	e59d300c	 ldr         r3, [sp, #0xC]
  00160	e58d3000	 str         r3, [sp]
  00164	e59d0000	 ldr         r0, [sp]
  00168	e28dd004	 add         sp, sp, #4
  0016c	e89d6000	 ldmia       sp, {sp, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$LN6@CSDIOContr|
  00174		 |$LN7@CSDIOContr|
  00174	00000000	 DCD         |??_7CSDIOControllerBase@@6B@|
  00178		 |$M41993|

			 ENDP  ; |??0CSDIOControllerBase@@QAA@XZ|, CSDIOControllerBase::CSDIOControllerBase

	EXPORT	|?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ| ; CSDIOControllerBase::Read_MMC_SDIO
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T42005| DCD	|$LN5@Read_MMC_S|
	DCD	0x40001604
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ| PROC ; CSDIOControllerBase::Read_MMC_SDIO

; 195  : {

  00000		 |$LN5@Read_MMC_S|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42002|

; 196  :     WORD wVal;
; 197  :     EnterCriticalSection( &m_critSec );

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e2830014	 add         r0, r3, #0x14
  00018	eb000000	 bl          EnterCriticalSection

; 198  :     wVal = INREG16(&m_vpSDIOReg->MMC_SDIO);

  0001c	e59d3010	 ldr         r3, [sp, #0x10]
  00020	e2833088	 add         r3, r3, #0x88
  00024	e5933000	 ldr         r3, [r3]
  00028	e2833034	 add         r3, r3, #0x34
  0002c	e1d330b0	 ldrh        r3, [r3]
  00030	e1cd30b0	 strh        r3, [sp]

; 199  :     LeaveCriticalSection( &m_critSec );

  00034	e59d3010	 ldr         r3, [sp, #0x10]
  00038	e2830014	 add         r0, r3, #0x14
  0003c	eb000000	 bl          LeaveCriticalSection

; 200  :     return wVal;

  00040	e1dd30b0	 ldrh        r3, [sp]
  00044	e1cd30b4	 strh        r3, [sp, #4]

; 201  : }

  00048	e1dd00b4	 ldrh        r0, [sp, #4]
  0004c	e28dd008	 add         sp, sp, #8
  00050	e89d6000	 ldmia       sp, {sp, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M42003|

			 ENDP  ; |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|, CSDIOControllerBase::Read_MMC_SDIO

	EXPORT	|?Write_MMC_SDIO@CSDIOControllerBase@@QAAXG@Z| ; CSDIOControllerBase::Write_MMC_SDIO

  00000			 AREA	 |.pdata|, PDATA
|$T42012| DCD	|$LN5@Write_MMC_|
	DCD	0x40001103
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Write_MMC_SDIO@CSDIOControllerBase@@QAAXG@Z| PROC ; CSDIOControllerBase::Write_MMC_SDIO

; 204  : {

  00000		 |$LN5@Write_MMC_|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M42009|

; 205  :     EnterCriticalSection( &m_critSec );

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e2830014	 add         r0, r3, #0x14
  00014	eb000000	 bl          EnterCriticalSection

; 206  :     OUTREG16(&m_vpSDIOReg->MMC_SDIO, wVal);

  00018	e59d3008	 ldr         r3, [sp, #8]
  0001c	e2833088	 add         r3, r3, #0x88
  00020	e5933000	 ldr         r3, [r3]
  00024	e2832034	 add         r2, r3, #0x34
  00028	e1dd30bc	 ldrh        r3, [sp, #0xC]
  0002c	e1c230b0	 strh        r3, [r2]

; 207  :     LeaveCriticalSection( &m_critSec );

  00030	e59d3008	 ldr         r3, [sp, #8]
  00034	e2830014	 add         r0, r3, #0x14
  00038	eb000000	 bl          LeaveCriticalSection

; 208  : }

  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42010|

			 ENDP  ; |?Write_MMC_SDIO@CSDIOControllerBase@@QAAXG@Z|, CSDIOControllerBase::Write_MMC_SDIO

	EXPORT	|?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ| ; CSDIOControllerBase::Read_MMC_STAT

  00000			 AREA	 |.pdata|, PDATA
|$T42020| DCD	|$LN5@Read_MMC_S@2|
	DCD	0x40001604
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ| PROC ; CSDIOControllerBase::Read_MMC_STAT

; 211  : {

  00000		 |$LN5@Read_MMC_S@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42017|

; 212  :     WORD wVal;
; 213  :     EnterCriticalSection( &m_critSec );

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e2830014	 add         r0, r3, #0x14
  00018	eb000000	 bl          EnterCriticalSection

; 214  :     wVal = INREG16(&m_vpSDIOReg->MMC_STAT);

  0001c	e59d3010	 ldr         r3, [sp, #0x10]
  00020	e2833088	 add         r3, r3, #0x88
  00024	e5933000	 ldr         r3, [r3]
  00028	e2833010	 add         r3, r3, #0x10
  0002c	e1d330b0	 ldrh        r3, [r3]
  00030	e1cd30b0	 strh        r3, [sp]

; 215  :     LeaveCriticalSection( &m_critSec );

  00034	e59d3010	 ldr         r3, [sp, #0x10]
  00038	e2830014	 add         r0, r3, #0x14
  0003c	eb000000	 bl          LeaveCriticalSection

; 216  :     return wVal;

  00040	e1dd30b0	 ldrh        r3, [sp]
  00044	e1cd30b4	 strh        r3, [sp, #4]

; 217  : }

  00048	e1dd00b4	 ldrh        r0, [sp, #4]
  0004c	e28dd008	 add         sp, sp, #8
  00050	e89d6000	 ldmia       sp, {sp, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M42018|

			 ENDP  ; |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|, CSDIOControllerBase::Read_MMC_STAT

	EXPORT	|?Write_MMC_STAT@CSDIOControllerBase@@QAAXG@Z| ; CSDIOControllerBase::Write_MMC_STAT

  00000			 AREA	 |.pdata|, PDATA
|$T42027| DCD	|$LN5@Write_MMC_@2|
	DCD	0x40001103
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Write_MMC_STAT@CSDIOControllerBase@@QAAXG@Z| PROC ; CSDIOControllerBase::Write_MMC_STAT

; 220  : {

  00000		 |$LN5@Write_MMC_@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M42024|

; 221  :     EnterCriticalSection( &m_critSec );

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e2830014	 add         r0, r3, #0x14
  00014	eb000000	 bl          EnterCriticalSection

; 222  :     OUTREG16(&m_vpSDIOReg->MMC_STAT,wVal);

  00018	e59d3008	 ldr         r3, [sp, #8]
  0001c	e2833088	 add         r3, r3, #0x88
  00020	e5933000	 ldr         r3, [r3]
  00024	e2832010	 add         r2, r3, #0x10
  00028	e1dd30bc	 ldrh        r3, [sp, #0xC]
  0002c	e1c230b0	 strh        r3, [r2]

; 223  :     LeaveCriticalSection( &m_critSec );

  00030	e59d3008	 ldr         r3, [sp, #8]
  00034	e2830014	 add         r0, r3, #0x14
  00038	eb000000	 bl          LeaveCriticalSection

; 224  : }

  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42025|

			 ENDP  ; |?Write_MMC_STAT@CSDIOControllerBase@@QAAXG@Z|, CSDIOControllerBase::Write_MMC_STAT

	EXPORT	|?SoftwareReset@CSDIOControllerBase@@QAAXE@Z| ; CSDIOControllerBase::SoftwareReset
	IMPORT	|GetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T42040| DCD	|$LN16@SoftwareRe|
	DCD	0x40005504
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SoftwareReset@CSDIOControllerBase@@QAAXE@Z| PROC ; CSDIOControllerBase::SoftwareReset

; 228  : {

  00000		 |$LN16@SoftwareRe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd028	 sub         sp, sp, #0x28
  00010		 |$M42037|

; 229  :     WORD                bValue;
; 230  :     DWORD               dwCurrentTickCount;
; 231  :     DWORD               dwTimeout;
; 232  :     DWORD               dwCountStart;
; 233  :     BOOL                fTimeoutOverflow = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 234  : 
; 235  :     DEBUGCHK(sizeof(OMAP2420_SDIO_REGS) % sizeof(WORD) == 0);
; 236  : 
; 237  :     // Reset the controller
; 238  :     OUTREG16(&m_vpSDIOReg->MMC_SYSC,(0x0002 & bResetBits));

  00018	e5dd3034	 ldrb        r3, [sp, #0x34]
  0001c	e2033002	 and         r3, r3, #2
  00020	e1a02803	 mov         r2, r3, lsl #16
  00024	e1a02822	 mov         r2, r2, lsr #16
  00028	e59d3030	 ldr         r3, [sp, #0x30]
  0002c	e2833088	 add         r3, r3, #0x88
  00030	e5933000	 ldr         r3, [r3]
  00034	e2833064	 add         r3, r3, #0x64
  00038	e1c320b0	 strh        r2, [r3]

; 239  : 
; 240  :     // calculate timeout conditions
; 241  :     dwCountStart = GetTickCount();

  0003c	eb000000	 bl          GetTickCount
  00040	e58d0014	 str         r0, [sp, #0x14]
  00044	e59d3014	 ldr         r3, [sp, #0x14]
  00048	e58d3004	 str         r3, [sp, #4]

; 242  :     dwTimeout = dwCountStart + m_dwMaxTimeout;

  0004c	e59d3030	 ldr         r3, [sp, #0x30]
  00050	e283307c	 add         r3, r3, #0x7C
  00054	e59d2004	 ldr         r2, [sp, #4]
  00058	e5933000	 ldr         r3, [r3]
  0005c	e0823003	 add         r3, r2, r3
  00060	e58d300c	 str         r3, [sp, #0xC]

; 243  :     if( dwTimeout < dwCountStart )

  00064	e59d200c	 ldr         r2, [sp, #0xC]
  00068	e59d3004	 ldr         r3, [sp, #4]
  0006c	e1520003	 cmp         r2, r3
  00070	2a000001	 bcs         |$LN5@SoftwareRe|

; 244  :         fTimeoutOverflow = TRUE;

  00074	e3a03001	 mov         r3, #1
  00078	e58d3000	 str         r3, [sp]
  0007c		 |$LN5@SoftwareRe|
  0007c		 |$LN4@SoftwareRe|

; 245  : 
; 246  :     // Verify that reset has completed.
; 247  :     do {
; 248  :         bValue = INREG16(&m_vpSDIOReg->MMC_SISS);

  0007c	e59d3030	 ldr         r3, [sp, #0x30]
  00080	e2833088	 add         r3, r3, #0x88
  00084	e5933000	 ldr         r3, [r3]
  00088	e2833068	 add         r3, r3, #0x68
  0008c	e1d330b0	 ldrh        r3, [r3]
  00090	e1cd31b0	 strh        r3, [sp, #0x10]

; 249  : 
; 250  :         // check for a timeout
; 251  :         dwCurrentTickCount = GetTickCount();

  00094	eb000000	 bl          GetTickCount
  00098	e58d0018	 str         r0, [sp, #0x18]
  0009c	e59d3018	 ldr         r3, [sp, #0x18]
  000a0	e58d3008	 str         r3, [sp, #8]

; 252  :         if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 253  :             : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  000a4	e59d3000	 ldr         r3, [sp]
  000a8	e3530000	 cmp         r3, #0
  000ac	0a00000f	 beq         |$LN12@SoftwareRe|
  000b0	e59d200c	 ldr         r2, [sp, #0xC]
  000b4	e59d3008	 ldr         r3, [sp, #8]
  000b8	e1520003	 cmp         r2, r3
  000bc	2a000006	 bcs         |$LN8@SoftwareRe|
  000c0	e59d2008	 ldr         r2, [sp, #8]
  000c4	e59d3004	 ldr         r3, [sp, #4]
  000c8	e1520003	 cmp         r2, r3
  000cc	2a000002	 bcs         |$LN8@SoftwareRe|
  000d0	e3a03001	 mov         r3, #1
  000d4	e58d301c	 str         r3, [sp, #0x1C]
  000d8	ea000001	 b           |$LN11@SoftwareRe|
  000dc		 |$LN8@SoftwareRe|
  000dc	e3a03000	 mov         r3, #0
  000e0	e58d301c	 str         r3, [sp, #0x1C]
  000e4		 |$LN11@SoftwareRe|
  000e4	e59d301c	 ldr         r3, [sp, #0x1C]
  000e8	e58d3020	 str         r3, [sp, #0x20]
  000ec	ea00000e	 b           |$LN13@SoftwareRe|
  000f0		 |$LN12@SoftwareRe|
  000f0	e59d200c	 ldr         r2, [sp, #0xC]
  000f4	e59d3008	 ldr         r3, [sp, #8]
  000f8	e1520003	 cmp         r2, r3
  000fc	3a000006	 bcc         |$LN9@SoftwareRe|
  00100	e59d2008	 ldr         r2, [sp, #8]
  00104	e59d3004	 ldr         r3, [sp, #4]
  00108	e1520003	 cmp         r2, r3
  0010c	3a000002	 bcc         |$LN9@SoftwareRe|
  00110	e3a03000	 mov         r3, #0
  00114	e58d3024	 str         r3, [sp, #0x24]
  00118	ea000001	 b           |$LN10@SoftwareRe|
  0011c		 |$LN9@SoftwareRe|
  0011c	e3a03001	 mov         r3, #1
  00120	e58d3024	 str         r3, [sp, #0x24]
  00124		 |$LN10@SoftwareRe|
  00124	e59d3024	 ldr         r3, [sp, #0x24]
  00128	e58d3020	 str         r3, [sp, #0x20]
  0012c		 |$LN13@SoftwareRe|
  0012c	e59d3020	 ldr         r3, [sp, #0x20]
  00130	e3530000	 cmp         r3, #0
  00134	0a000000	 beq         |$LN1@SoftwareRe|

; 254  :         {
; 255  :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SoftwareReset: "
; 256  :                 L"Exit: TIMEOUT.\r\n"
; 257  :             ));
; 258  :             break;

  00138	ea000002	 b           |$LN2@SoftwareRe|
  0013c		 |$LN1@SoftwareRe|

; 259  :         }
; 260  :     } while (bValue != 0);

  0013c	e1dd31b0	 ldrh        r3, [sp, #0x10]
  00140	e3530000	 cmp         r3, #0
  00144	1affffcc	 bne         |$LN4@SoftwareRe|
  00148		 |$LN2@SoftwareRe|

; 261  : }

  00148	e28dd028	 add         sp, sp, #0x28
  0014c	e89d6000	 ldmia       sp, {sp, lr}
  00150	e12fff1e	 bx          lr
  00154		 |$M42038|

			 ENDP  ; |?SoftwareReset@CSDIOControllerBase@@QAAXE@Z|, CSDIOControllerBase::SoftwareReset

	EXPORT	|?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::EnableSDIOInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T42051| DCD	|$LN9@EnableSDIO|
	DCD	0x40002e04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::EnableSDIOInterrupts

; 312  : {

  00000		 |$LN9@EnableSDIO|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42048|

; 313  :     ASSERT( !m_fSDIOInterruptsEnabled );
; 314  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (L"+CSDHCSlot::EnableSDIOInterrupts\r\n"));
; 315  : 
; 316  :     WORD wRegValue = Read_MMC_SDIO();

  00010	e59d0010	 ldr         r0, [sp, #0x10]
  00014	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  00018	e1cd00b4	 strh        r0, [sp, #4]
  0001c	e1dd30b4	 ldrh        r3, [sp, #4]
  00020	e1cd30b0	 strh        r3, [sp]

; 317  :     wRegValue |= MMC_IE_EOC;

  00024	e1dd30b0	 ldrh        r3, [sp]
  00028	e3833001	 orr         r3, r3, #1
  0002c	e1a03803	 mov         r3, r3, lsl #16
  00030	e1a03823	 mov         r3, r3, lsr #16
  00034	e1cd30b0	 strh        r3, [sp]

; 318  :     Write_MMC_SDIO(wRegValue);

  00038	e59d3010	 ldr         r3, [sp, #0x10]
  0003c	e2830014	 add         r0, r3, #0x14
  00040	eb000000	 bl          EnterCriticalSection
  00044	e59d3010	 ldr         r3, [sp, #0x10]
  00048	e2833088	 add         r3, r3, #0x88
  0004c	e5933000	 ldr         r3, [r3]
  00050	e2832034	 add         r2, r3, #0x34
  00054	e1dd30b0	 ldrh        r3, [sp]
  00058	e1c230b0	 strh        r3, [r2]
  0005c	e59d3010	 ldr         r3, [sp, #0x10]
  00060	e2830014	 add         r0, r3, #0x14
  00064	eb000000	 bl          LeaveCriticalSection

; 319  :     SETREG16(&m_vpSDIOReg->MMC_IE, MMC_IE_CIRQ);

  00068	e59d3010	 ldr         r3, [sp, #0x10]
  0006c	e2833088	 add         r3, r3, #0x88
  00070	e5933000	 ldr         r3, [r3]
  00074	e2833014	 add         r3, r3, #0x14
  00078	e1d330b0	 ldrh        r3, [r3]
  0007c	e3833a02	 orr         r3, r3, #2, 20
  00080	e1a02803	 mov         r2, r3, lsl #16
  00084	e1a02822	 mov         r2, r2, lsr #16
  00088	e59d3010	 ldr         r3, [sp, #0x10]
  0008c	e2833088	 add         r3, r3, #0x88
  00090	e5933000	 ldr         r3, [r3]
  00094	e2833014	 add         r3, r3, #0x14
  00098	e1c320b0	 strh        r2, [r3]

; 320  : 
; 321  :     m_fSDIOInterruptsEnabled = TRUE;

  0009c	e59d3010	 ldr         r3, [sp, #0x10]
  000a0	e283203c	 add         r2, r3, #0x3C
  000a4	e3a03001	 mov         r3, #1
  000a8	e5823000	 str         r3, [r2]

; 322  : }

  000ac	e28dd008	 add         sp, sp, #8
  000b0	e89d6000	 ldmia       sp, {sp, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$M42049|

			 ENDP  ; |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::EnableSDIOInterrupts

	EXPORT	|?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::AckSDIOInterrupt
	IMPORT	|SDHCDIndicateSlotStateChange|

  00000			 AREA	 |.pdata|, PDATA
|$T42063| DCD	|$LN13@AckSDIOInt|
	DCD	0x40003804
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::AckSDIOInterrupt

; 328  : {   

  00000		 |$LN13@AckSDIOInt|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42060|

; 329  :     ASSERT( m_fSDIOInterruptsEnabled );
; 330  : 
; 331  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (L"+CSDHCSlot::AckSDIOInterrupt\r\n"));
; 332  : 
; 333  :     WORD wRegValue = Read_MMC_STAT();

  00010	e59d0014	 ldr         r0, [sp, #0x14]
  00014	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00018	e1cd00b6	 strh        r0, [sp, #6]
  0001c	e1dd30b6	 ldrh        r3, [sp, #6]
  00020	e1cd30b0	 strh        r3, [sp]

; 334  :     Write_MMC_STAT(MMC_STAT_CIRQ);

  00024	e59d3014	 ldr         r3, [sp, #0x14]
  00028	e2830014	 add         r0, r3, #0x14
  0002c	eb000000	 bl          EnterCriticalSection
  00030	e59d3014	 ldr         r3, [sp, #0x14]
  00034	e2833088	 add         r3, r3, #0x88
  00038	e5933000	 ldr         r3, [r3]
  0003c	e2832010	 add         r2, r3, #0x10
  00040	e3a03a02	 mov         r3, #2, 20
  00044	e1c230b0	 strh        r3, [r2]
  00048	e59d3014	 ldr         r3, [sp, #0x14]
  0004c	e2830014	 add         r0, r3, #0x14
  00050	eb000000	 bl          LeaveCriticalSection

; 335  :     wRegValue = Read_MMC_STAT();

  00054	e59d0014	 ldr         r0, [sp, #0x14]
  00058	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  0005c	e1cd00b8	 strh        r0, [sp, #8]
  00060	e1dd30b8	 ldrh        r3, [sp, #8]
  00064	e1cd30b0	 strh        r3, [sp]

; 336  :     if( wRegValue & MMC_STAT_CIRQ )

  00068	e1dd30b0	 ldrh        r3, [sp]
  0006c	e3130a02	 tst         r3, #2, 20
  00070	0a000006	 beq         |$LN2@AckSDIOInt|

; 337  :     {
; 338  :         SDHCDIndicateSlotStateChange(m_pHCContext, 0, DeviceInterrupting);

  00074	e3a02003	 mov         r2, #3
  00078	e3a01000	 mov         r1, #0
  0007c	e59d3014	 ldr         r3, [sp, #0x14]
  00080	e2833004	 add         r3, r3, #4
  00084	e5930000	 ldr         r0, [r3]
  00088	eb000000	 bl          SDHCDIndicateSlotStateChange

; 339  :     }
; 340  :     else

  0008c	ea000010	 b           |$LN1@AckSDIOInt|
  00090		 |$LN2@AckSDIOInt|

; 341  :     {
; 342  :         SETREG16(&m_vpSDIOReg->MMC_IE, MMC_IE_CIRQ);

  00090	e59d3014	 ldr         r3, [sp, #0x14]
  00094	e2833088	 add         r3, r3, #0x88
  00098	e5933000	 ldr         r3, [r3]
  0009c	e2833014	 add         r3, r3, #0x14
  000a0	e1d330b0	 ldrh        r3, [r3]
  000a4	e3833a02	 orr         r3, r3, #2, 20
  000a8	e1a02803	 mov         r2, r3, lsl #16
  000ac	e1a02822	 mov         r2, r2, lsr #16
  000b0	e59d3014	 ldr         r3, [sp, #0x14]
  000b4	e2833088	 add         r3, r3, #0x88
  000b8	e5933000	 ldr         r3, [r3]
  000bc	e2833014	 add         r3, r3, #0x14
  000c0	e1c320b0	 strh        r2, [r3]

; 343  :         m_fSDIOInterruptInService = FALSE;

  000c4	e59d3014	 ldr         r3, [sp, #0x14]
  000c8	e2832028	 add         r2, r3, #0x28
  000cc	e3a03000	 mov         r3, #0
  000d0	e5823000	 str         r3, [r2]
  000d4		 |$LN1@AckSDIOInt|

; 344  :     }
; 345  : }

  000d4	e28dd00c	 add         sp, sp, #0xC
  000d8	e89d6000	 ldmia       sp, {sp, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M42061|

			 ENDP  ; |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::AckSDIOInterrupt

	EXPORT	|?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::DisableSDIOInterrupts

  00000			 AREA	 |.pdata|, PDATA
|$T42074| DCD	|$LN9@DisableSDI|
	DCD	0x40003204
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::DisableSDIOInterrupts

; 351  : {            

  00000		 |$LN9@DisableSDI|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42071|

; 352  :     ASSERT( m_fSDIOInterruptsEnabled );
; 353  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (L"+CSDHCSlot::DisableSDIOInterrupts\r\n"));
; 354  :     
; 355  :     CLRREG16(&m_vpSDIOReg->MMC_IE, MMC_IE_CIRQ);

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e2833088	 add         r3, r3, #0x88
  00018	e5933000	 ldr         r3, [r3]
  0001c	e2833014	 add         r3, r3, #0x14
  00020	e1d330b0	 ldrh        r3, [r3]
  00024	e1a02003	 mov         r2, r3
  00028	e3e03a02	 mvn         r3, #2, 20
  0002c	e0023003	 and         r3, r2, r3
  00030	e1a02803	 mov         r2, r3, lsl #16
  00034	e1a02822	 mov         r2, r2, lsr #16
  00038	e59d3010	 ldr         r3, [sp, #0x10]
  0003c	e2833088	 add         r3, r3, #0x88
  00040	e5933000	 ldr         r3, [r3]
  00044	e2833014	 add         r3, r3, #0x14
  00048	e1c320b0	 strh        r2, [r3]

; 356  :     WORD wRegValue = Read_MMC_SDIO();

  0004c	e59d0010	 ldr         r0, [sp, #0x10]
  00050	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  00054	e1cd00b4	 strh        r0, [sp, #4]
  00058	e1dd30b4	 ldrh        r3, [sp, #4]
  0005c	e1cd30b0	 strh        r3, [sp]

; 357  :     wRegValue &= (~MMC_IE_EOC);

  00060	e1dd30b0	 ldrh        r3, [sp]
  00064	e1a02003	 mov         r2, r3
  00068	e3e03001	 mvn         r3, #1
  0006c	e0023003	 and         r3, r2, r3
  00070	e1a03803	 mov         r3, r3, lsl #16
  00074	e1a03823	 mov         r3, r3, lsr #16
  00078	e1cd30b0	 strh        r3, [sp]

; 358  :     Write_MMC_SDIO(wRegValue);

  0007c	e59d3010	 ldr         r3, [sp, #0x10]
  00080	e2830014	 add         r0, r3, #0x14
  00084	eb000000	 bl          EnterCriticalSection
  00088	e59d3010	 ldr         r3, [sp, #0x10]
  0008c	e2833088	 add         r3, r3, #0x88
  00090	e5933000	 ldr         r3, [r3]
  00094	e2832034	 add         r2, r3, #0x34
  00098	e1dd30b0	 ldrh        r3, [sp]
  0009c	e1c230b0	 strh        r3, [r2]
  000a0	e59d3010	 ldr         r3, [sp, #0x10]
  000a4	e2830014	 add         r0, r3, #0x14
  000a8	eb000000	 bl          LeaveCriticalSection

; 359  : 
; 360  :     m_fSDIOInterruptsEnabled = FALSE;

  000ac	e59d3010	 ldr         r3, [sp, #0x10]
  000b0	e283203c	 add         r2, r3, #0x3C
  000b4	e3a03000	 mov         r3, #0
  000b8	e5823000	 str         r3, [r2]

; 361  : }

  000bc	e28dd008	 add         sp, sp, #8
  000c0	e89d6000	 ldmia       sp, {sp, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$M42072|

			 ENDP  ; |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::DisableSDIOInterrupts

	EXPORT	|?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z| ; CSDIOControllerBase::SetClockRate
	IMPORT	|__rt_sdiv|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T42083| DCD	|$LN6@SetClockRa|
	DCD	0x40003704
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z| PROC ; CSDIOControllerBase::SetClockRate

; 367  : {

  00000		 |$LN6@SetClockRa|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42080|

; 368  :     const DWORD dwClockRate = *pdwRate;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3000	 str         r3, [sp]

; 369  : 
; 370  :     // calculate the register value
; 371  :     WORD wDiv = (WORD)((MMCSD_CLOCK_INPUT + dwClockRate - 1) / dwClockRate);

  0001c	e59d2000	 ldr         r2, [sp]
  00020	e59f30b0	 ldr         r3, [pc, #0xB0]
  00024	e0823003	 add         r3, r2, r3
  00028	e2431001	 sub         r1, r3, #1
  0002c	e59d0000	 ldr         r0, [sp]
  00030	eb000000	 bl          __rt_udiv
  00034	e1a03800	 mov         r3, r0, lsl #16
  00038	e1a03823	 mov         r3, r3, lsr #16
  0003c	e1cd30b4	 strh        r3, [sp, #4]

; 372  :     DEBUGMSG(SHC_CLOCK_ZONE, (L"CSDIOControllerBase::SetClockRate: "
; 373  :         L"Actual wDiv = 0x%x  requested:0x%x ", wDiv, *pdwRate
; 374  :     ));
; 375  :     // Only 8 bits available for the divider, so mmc base clock / 255 is minimum.
; 376  :     if ( wDiv > 0x03FF )

  00040	e1dd30b4	 ldrh        r3, [sp, #4]
  00044	e1a02003	 mov         r2, r3
  00048	e3a03c03	 mov         r3, #3, 24
  0004c	e38330ff	 orr         r3, r3, #0xFF
  00050	e1520003	 cmp         r2, r3
  00054	da000002	 ble         |$LN1@SetClockRa|

; 377  :         wDiv = 0x03FF;

  00058	e3a03c03	 mov         r3, #3, 24
  0005c	e38330ff	 orr         r3, r3, #0xFF
  00060	e1cd30b4	 strh        r3, [sp, #4]
  00064		 |$LN1@SetClockRa|

; 378  : 
; 379  :     DEBUGMSG(SHC_CLOCK_ZONE, (L"wDiv = 0x%x 0x%x", wDiv, *pdwRate
; 380  :     ));
; 381  : 
; 382  :     // Program the divisor, but leave the rest of the register alone.
; 383  :     WORD wRegValue = INREG16(&m_vpSDIOReg->MMC_CON);

  00064	e59d3010	 ldr         r3, [sp, #0x10]
  00068	e2833088	 add         r3, r3, #0x88
  0006c	e5933000	 ldr         r3, [r3]
  00070	e283300c	 add         r3, r3, #0xC
  00074	e1d330b0	 ldrh        r3, [r3]
  00078	e1cd30b6	 strh        r3, [sp, #6]

; 384  : 
; 385  :     OUTREG16(&m_vpSDIOReg->MMC_CON, ((wRegValue & ~0x03FF) | wDiv));

  0007c	e1dd30b6	 ldrh        r3, [sp, #6]
  00080	e1a02003	 mov         r2, r3
  00084	e3e030ff	 mvn         r3, #0xFF
  00088	e1a03103	 mov         r3, r3, lsl #2
  0008c	e0022003	 and         r2, r2, r3
  00090	e1dd30b4	 ldrh        r3, [sp, #4]
  00094	e1823003	 orr         r3, r2, r3
  00098	e1a02803	 mov         r2, r3, lsl #16
  0009c	e1a02822	 mov         r2, r2, lsr #16
  000a0	e59d3010	 ldr         r3, [sp, #0x10]
  000a4	e2833088	 add         r3, r3, #0x88
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e283300c	 add         r3, r3, #0xC
  000b0	e1c320b0	 strh        r2, [r3]

; 386  : 
; 387  :     
; 388  :     *pdwRate = MMCSD_CLOCK_INPUT / wDiv;

  000b4	e1dd30b4	 ldrh        r3, [sp, #4]
  000b8	e1a00003	 mov         r0, r3
  000bc	e59f1014	 ldr         r1, [pc, #0x14]
  000c0	eb000000	 bl          __rt_sdiv
  000c4	e59d3014	 ldr         r3, [sp, #0x14]
  000c8	e5830000	 str         r0, [r3]

; 389  :     DEBUGMSG(SHC_CLOCK_ZONE,(L"CSDIOControllerBase::SetClockRate: "
; 390  :         L"Actual clock rate = 0x%x\n", *pdwRate
; 391  :     ));
; 392  : }

  000cc	e28dd008	 add         sp, sp, #8
  000d0	e89d6000	 ldmia       sp, {sp, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN7@SetClockRa|
  000d8		 |$LN8@SetClockRa|
  000d8	05b8d800	 DCD         0x5b8d800
  000dc		 |$M42081|

			 ENDP  ; |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|, CSDIOControllerBase::SetClockRate

	EXPORT	|?ClockOn@CSDIOControllerBase@@QAAXXZ|	; CSDIOControllerBase::ClockOn
	IMPORT	|KernelIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T42096| DCD	|$LN5@ClockOn|
	DCD	0x40001f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClockOn@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::ClockOn

; 397  : {

  00000		 |$LN5@ClockOn|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd020	 sub         sp, sp, #0x20
  00010		 |$M42093|

; 398  :     // Enable MMC clock - clocks on by default
; 399  :     DWORD cbRet;
; 400  :     DWORD regVal = PRCM_FCLKEN1_CORE_EN_MMC;

  00010	e3a03301	 mov         r3, #1, 6
  00014	e58d300c	 str         r3, [sp, #0xC]

; 401  :     KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regVal, sizeof(DWORD), (VOID *)&regVal, sizeof(DWORD), &cbRet);

  00018	e28d3008	 add         r3, sp, #8
  0001c	e58d3004	 str         r3, [sp, #4]
  00020	e3a03004	 mov         r3, #4
  00024	e58d3000	 str         r3, [sp]
  00028	e28d300c	 add         r3, sp, #0xC
  0002c	e3a02004	 mov         r2, #4
  00030	e28d100c	 add         r1, sp, #0xC
  00034	e59f003c	 ldr         r0, [pc, #0x3C]
  00038	eb000000	 bl          KernelIoControl

; 402  :     regVal = PRCM_ICLKEN1_CORE_EN_MMC;

  0003c	e3a03301	 mov         r3, #1, 6
  00040	e58d300c	 str         r3, [sp, #0xC]

; 403  :     KernelIoControl(IOCTL_ICLK1_ENB, (VOID *)&regVal, sizeof(DWORD), (VOID *)&regVal, sizeof(DWORD), &cbRet);   

  00044	e28d3008	 add         r3, sp, #8
  00048	e58d3004	 str         r3, [sp, #4]
  0004c	e3a03004	 mov         r3, #4
  00050	e58d3000	 str         r3, [sp]
  00054	e28d300c	 add         r3, sp, #0xC
  00058	e3a02004	 mov         r2, #4
  0005c	e28d100c	 add         r1, sp, #0xC
  00060	e59f000c	 ldr         r0, [pc, #0xC]
  00064	eb000000	 bl          KernelIoControl

; 404  : }

  00068	e28dd020	 add         sp, sp, #0x20
  0006c	e89d6000	 ldmia       sp, {sp, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$LN6@ClockOn|
  00074		 |$LN7@ClockOn|
  00074	0022040c	 DCD         0x22040c
  00078		 |$LN8@ClockOn|
  00078	0022041c	 DCD         0x22041c
  0007c		 |$M42094|

			 ENDP  ; |?ClockOn@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::ClockOn

	EXPORT	|?ClockOff@CSDIOControllerBase@@QAAXXZ|	; CSDIOControllerBase::ClockOff

  00000			 AREA	 |.pdata|, PDATA
|$T42110| DCD	|$LN5@ClockOff|
	DCD	0x40001f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ClockOff@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::ClockOff

; 409  : {

  00000		 |$LN5@ClockOff|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd020	 sub         sp, sp, #0x20
  00010		 |$M42107|

; 410  :     // disable MMC clock
; 411  :     DWORD cbRet;
; 412  :     DWORD regVal = PRCM_FCLKEN1_CORE_EN_MMC;

  00010	e3a03301	 mov         r3, #1, 6
  00014	e58d300c	 str         r3, [sp, #0xC]

; 413  :     KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regVal, sizeof(DWORD), (VOID *)&regVal, sizeof(DWORD), &cbRet);

  00018	e28d3008	 add         r3, sp, #8
  0001c	e58d3004	 str         r3, [sp, #4]
  00020	e3a03004	 mov         r3, #4
  00024	e58d3000	 str         r3, [sp]
  00028	e28d300c	 add         r3, sp, #0xC
  0002c	e3a02004	 mov         r2, #4
  00030	e28d100c	 add         r1, sp, #0xC
  00034	e3a00822	 mov         r0, #0x22, 16
  00038	e3800e42	 orr         r0, r0, #0x42, 28
  0003c	eb000000	 bl          KernelIoControl

; 414  :     regVal = PRCM_ICLKEN1_CORE_EN_MMC;

  00040	e3a03301	 mov         r3, #1, 6
  00044	e58d300c	 str         r3, [sp, #0xC]

; 415  :     KernelIoControl(IOCTL_ICLK1_DIS, (VOID *)&regVal, sizeof(DWORD), (VOID *)&regVal, sizeof(DWORD), &cbRet);   

  00048	e28d3008	 add         r3, sp, #8
  0004c	e58d3004	 str         r3, [sp, #4]
  00050	e3a03004	 mov         r3, #4
  00054	e58d3000	 str         r3, [sp]
  00058	e28d300c	 add         r3, sp, #0xC
  0005c	e3a02004	 mov         r2, #4
  00060	e28d100c	 add         r1, sp, #0xC
  00064	e3a00822	 mov         r0, #0x22, 16
  00068	e3800e41	 orr         r0, r0, #0x41, 28
  0006c	eb000000	 bl          KernelIoControl

; 416  : }

  00070	e28dd020	 add         sp, sp, #0x20
  00074	e89d6000	 ldmia       sp, {sp, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M42108|

			 ENDP  ; |?ClockOff@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::ClockOff

	EXPORT	|?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SendCommand

  00000			 AREA	 |.pdata|, PDATA
|$T42148| DCD	|$LN69@SendComman|
	DCD	0x40021604
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SendCommand

; 423  : {

  00000		 |$LN69@SendComman|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd06c	 sub         sp, sp, #0x6C
  00010		 |$M42145|

; 424  :     WORD MMC_CMD;
; 425  :     DWORD dwCurrentTickCount;
; 426  :     DWORD dwTimeout;
; 427  :     DWORD dwCountStart;
; 428  :     BOOL  fTimeoutOverflow = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3008	 str         r3, [sp, #8]

; 429  :     UINT16 Cmd = pRequest->CommandCode;

  00018	e59d3078	 ldr         r3, [sp, #0x78]
  0001c	e2833014	 add         r3, r3, #0x14
  00020	e5d33000	 ldrb        r3, [r3]
  00024	e1cd31bc	 strh        r3, [sp, #0x1C]

; 430  :     UINT32 Arg = pRequest->CommandArgument;

  00028	e59d3078	 ldr         r3, [sp, #0x78]
  0002c	e2833018	 add         r3, r3, #0x18
  00030	e5933000	 ldr         r3, [r3]
  00034	e58d3004	 str         r3, [sp, #4]

; 431  :     UINT16 respType = pRequest->CommandResponse.ResponseType;

  00038	e59d3078	 ldr         r3, [sp, #0x78]
  0003c	e283301c	 add         r3, r3, #0x1C
  00040	e5933000	 ldr         r3, [r3]
  00044	e1a03803	 mov         r3, r3, lsl #16
  00048	e1a03823	 mov         r3, r3, lsr #16
  0004c	e1cd31b4	 strh        r3, [sp, #0x14]

; 432  :     UINT16 TransferClass = pRequest->TransferClass;

  00050	e59d3078	 ldr         r3, [sp, #0x78]
  00054	e2833010	 add         r3, r3, #0x10
  00058	e5933000	 ldr         r3, [r3]
  0005c	e1a03803	 mov         r3, r3, lsl #16
  00060	e1a03823	 mov         r3, r3, lsr #16
  00064	e1cd30b0	 strh        r3, [sp]

; 433  : 
; 434  :     DEBUGMSG(SHC_SEND_ZONE, (L"CSDIOControllerBase::SendCommand: "
; 435  :         L"Cmd = 0x%x Arg = 0x%x respType = 0x%x TransferClass = 0x%x\r\n", Cmd, Arg, respType, TransferClass
; 436  :     ));
; 437  : 
; 438  :     if( TransferClass == SD_READ || TransferClass == SD_WRITE )
; 439  :     {
; 440  :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::SendCommand: "
; 441  :             L"Cmd=0x%04x, Arg=0x%08x, RespType=0x%04x, Data=0x%x <%dx%d>) starts\r\n", 
; 442  :             Cmd, Arg, respType, (TransferClass==SD_COMMAND)?FALSE:TRUE, pRequest->NumBlocks, pRequest->BlockSize
; 443  :         ));
; 444  :     }
; 445  :     else
; 446  :     {
; 447  :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::SendCommand: "
; 448  :             L"Cmd=0x%04x, Arg=0x%08x, RespType=0x%04x, Data=0x%x) starts\r\n", 
; 449  :             Cmd, Arg, respType, (TransferClass==SD_COMMAND)?FALSE:TRUE
; 450  :         ));
; 451  :     }
; 452  : 
; 453  :     // turn the clock on
; 454  :     ClockOn();

  00068	e59d0074	 ldr         r0, [sp, #0x74]
  0006c	eb000000	 bl          |?ClockOn@CSDIOControllerBase@@QAAXXZ|

; 455  : 
; 456  :     WORD MMC_STAT = Read_MMC_STAT();

  00070	e59d0074	 ldr         r0, [sp, #0x74]
  00074	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00078	e1cd03bc	 strh        r0, [sp, #0x3C]
  0007c	e1dd33bc	 ldrh        r3, [sp, #0x3C]
  00080	e1cd30be	 strh        r3, [sp, #0xE]

; 457  : 
; 458  :     if ( MMC_STAT & MMC_STAT_CB )
; 459  :     {
; 460  :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SendCommand: "
; 461  :             L"Card in busy state before command sent!\r\n"
; 462  :         ));
; 463  :     }
; 464  : 
; 465  :     if (m_fFirstTime) 

  00084	e59d3074	 ldr         r3, [sp, #0x74]
  00088	e2833080	 add         r3, r3, #0x80
  0008c	e5933000	 ldr         r3, [r3]
  00090	e3530000	 cmp         r3, #0
  00094	0a000095	 beq         |$LN26@SendComman|

; 466  :     {
; 467  :         m_fFirstTime = FALSE;

  00098	e59d3074	 ldr         r3, [sp, #0x74]
  0009c	e2832080	 add         r2, r3, #0x80
  000a0	e3a03000	 mov         r3, #0
  000a4	e5823000	 str         r3, [r2]

; 468  : 
; 469  :         // Clear the MMC_STAT register
; 470  :         Write_MMC_STAT( Read_MMC_STAT() & (~MMC_STAT_CIRQ) );

  000a8	e59d0074	 ldr         r0, [sp, #0x74]
  000ac	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  000b0	e1cd03be	 strh        r0, [sp, #0x3E]
  000b4	e59d3074	 ldr         r3, [sp, #0x74]
  000b8	e2830014	 add         r0, r3, #0x14
  000bc	eb000000	 bl          EnterCriticalSection
  000c0	e59d3074	 ldr         r3, [sp, #0x74]
  000c4	e2833088	 add         r3, r3, #0x88
  000c8	e5933000	 ldr         r3, [r3]
  000cc	e2831010	 add         r1, r3, #0x10
  000d0	e1dd33be	 ldrh        r3, [sp, #0x3E]
  000d4	e1a02003	 mov         r2, r3
  000d8	e3e03a02	 mvn         r3, #2, 20
  000dc	e0023003	 and         r3, r2, r3
  000e0	e1a03803	 mov         r3, r3, lsl #16
  000e4	e1a03823	 mov         r3, r3, lsr #16
  000e8	e1c130b0	 strh        r3, [r1]
  000ec	e59d3074	 ldr         r3, [sp, #0x74]
  000f0	e2830014	 add         r0, r3, #0x14
  000f4	eb000000	 bl          LeaveCriticalSection

; 471  : 
; 472  :         // temporarily mask all interrupts
; 473  :         OUTREG16(&m_vpSDIOReg->MMC_IE, 0x00);

  000f8	e59d3074	 ldr         r3, [sp, #0x74]
  000fc	e2833088	 add         r3, r3, #0x88
  00100	e5933000	 ldr         r3, [r3]
  00104	e2832014	 add         r2, r3, #0x14
  00108	e3a03000	 mov         r3, #0
  0010c	e1c230b0	 strh        r3, [r2]

; 474  : 
; 475  :         // send the initialization command
; 476  :         OUTREG16(&m_vpSDIOReg->MMC_CMD, 0x80);

  00110	e59d3074	 ldr         r3, [sp, #0x74]
  00114	e2833088	 add         r3, r3, #0x88
  00118	e5932000	 ldr         r2, [r3]
  0011c	e3a03080	 mov         r3, #0x80
  00120	e1c230b0	 strh        r3, [r2]

; 477  : 
; 478  :         // calculate timeout conditions
; 479  :         dwCountStart = GetTickCount();

  00124	eb000000	 bl          GetTickCount
  00128	e58d0040	 str         r0, [sp, #0x40]
  0012c	e59d3040	 ldr         r3, [sp, #0x40]
  00130	e58d3010	 str         r3, [sp, #0x10]

; 480  :         dwTimeout = dwCountStart + m_dwMaxTimeout;

  00134	e59d3074	 ldr         r3, [sp, #0x74]
  00138	e283307c	 add         r3, r3, #0x7C
  0013c	e59d2010	 ldr         r2, [sp, #0x10]
  00140	e5933000	 ldr         r3, [r3]
  00144	e0823003	 add         r3, r2, r3
  00148	e58d3020	 str         r3, [sp, #0x20]

; 481  :         if( dwTimeout < dwCountStart )

  0014c	e59d2020	 ldr         r2, [sp, #0x20]
  00150	e59d3010	 ldr         r3, [sp, #0x10]
  00154	e1520003	 cmp         r2, r3
  00158	2a000001	 bcs         |$LN25@SendComman|

; 482  :             fTimeoutOverflow = TRUE;

  0015c	e3a03001	 mov         r3, #1
  00160	e58d3008	 str         r3, [sp, #8]
  00164		 |$LN25@SendComman|
  00164		 |$LN24@SendComman|

; 483  : 
; 484  :         // poll until command complete
; 485  :         while( !( Read_MMC_STAT() & ( MMC_IE_EOC | MMC_IE_CTO | MMC_IE_CCRC | MMC_IE_CERR ) ) )

  00164	e59d0074	 ldr         r0, [sp, #0x74]
  00168	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  0016c	e1cd04b4	 strh        r0, [sp, #0x44]
  00170	e1dd34b4	 ldrh        r3, [sp, #0x44]
  00174	e1a02003	 mov         r2, r3
  00178	e3a03c41	 mov         r3, #0x41, 24
  0017c	e3833081	 orr         r3, r3, #0x81
  00180	e1120003	 tst         r2, r3
  00184	1a00003e	 bne         |$LN23@SendComman|

; 486  :         {
; 487  :             // check for a timeout
; 488  :             dwCurrentTickCount = GetTickCount();

  00188	eb000000	 bl          GetTickCount
  0018c	e58d0048	 str         r0, [sp, #0x48]
  00190	e59d3048	 ldr         r3, [sp, #0x48]
  00194	e58d3018	 str         r3, [sp, #0x18]

; 489  :             if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 490  :                 : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  00198	e59d3008	 ldr         r3, [sp, #8]
  0019c	e3530000	 cmp         r3, #0
  001a0	0a00000f	 beq         |$LN37@SendComman|
  001a4	e59d2020	 ldr         r2, [sp, #0x20]
  001a8	e59d3018	 ldr         r3, [sp, #0x18]
  001ac	e1520003	 cmp         r2, r3
  001b0	2a000006	 bcs         |$LN33@SendComman|
  001b4	e59d2018	 ldr         r2, [sp, #0x18]
  001b8	e59d3010	 ldr         r3, [sp, #0x10]
  001bc	e1520003	 cmp         r2, r3
  001c0	2a000002	 bcs         |$LN33@SendComman|
  001c4	e3a03001	 mov         r3, #1
  001c8	e58d304c	 str         r3, [sp, #0x4C]
  001cc	ea000001	 b           |$LN36@SendComman|
  001d0		 |$LN33@SendComman|
  001d0	e3a03000	 mov         r3, #0
  001d4	e58d304c	 str         r3, [sp, #0x4C]
  001d8		 |$LN36@SendComman|
  001d8	e59d304c	 ldr         r3, [sp, #0x4C]
  001dc	e58d3050	 str         r3, [sp, #0x50]
  001e0	ea00000e	 b           |$LN38@SendComman|
  001e4		 |$LN37@SendComman|
  001e4	e59d2020	 ldr         r2, [sp, #0x20]
  001e8	e59d3018	 ldr         r3, [sp, #0x18]
  001ec	e1520003	 cmp         r2, r3
  001f0	3a000006	 bcc         |$LN34@SendComman|
  001f4	e59d2018	 ldr         r2, [sp, #0x18]
  001f8	e59d3010	 ldr         r3, [sp, #0x10]
  001fc	e1520003	 cmp         r2, r3
  00200	3a000002	 bcc         |$LN34@SendComman|
  00204	e3a03000	 mov         r3, #0
  00208	e58d3054	 str         r3, [sp, #0x54]
  0020c	ea000001	 b           |$LN35@SendComman|
  00210		 |$LN34@SendComman|
  00210	e3a03001	 mov         r3, #1
  00214	e58d3054	 str         r3, [sp, #0x54]
  00218		 |$LN35@SendComman|
  00218	e59d3054	 ldr         r3, [sp, #0x54]
  0021c	e58d3050	 str         r3, [sp, #0x50]
  00220		 |$LN38@SendComman|
  00220	e59d3050	 ldr         r3, [sp, #0x50]
  00224	e3530000	 cmp         r3, #0
  00228	0a000004	 beq         |$LN22@SendComman|

; 491  :             {
; 492  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SendCommand: "
; 493  :                     L"Exit: TIMEOUT while sending INIB.\r\n"
; 494  :                 ));
; 495  :                 ClockOff();

  0022c	e59d0074	 ldr         r0, [sp, #0x74]
  00230	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 496  :                 return SD_API_STATUS_UNSUCCESSFUL;

  00234	e3a0310f	 mov         r3, #0xF, 2
  00238	e58d3038	 str         r3, [sp, #0x38]
  0023c	ea000180	 b           |$LN31@SendComman|
  00240		 |$LN22@SendComman|

; 497  :             }
; 498  : 
; 499  :             // check for card ejection
; 500  :             if( !SDCardDetect() )

  00240	e59d3074	 ldr         r3, [sp, #0x74]
  00244	e5933000	 ldr         r3, [r3]
  00248	e2833014	 add         r3, r3, #0x14
  0024c	e59d0074	 ldr         r0, [sp, #0x74]
  00250	e5933000	 ldr         r3, [r3]
  00254	e1a0e00f	 mov         lr, pc
  00258	e12fff13	 bx          r3
  0025c	e58d0058	 str         r0, [sp, #0x58]
  00260	e59d3058	 ldr         r3, [sp, #0x58]
  00264	e3530000	 cmp         r3, #0
  00268	1a000004	 bne         |$LN21@SendComman|

; 501  :             {
; 502  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SendCommand: "
; 503  :                     L"Exit: card ejected while sending INIB.\r\n"
; 504  :                 ));
; 505  :                 ClockOff();

  0026c	e59d0074	 ldr         r0, [sp, #0x74]
  00270	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 506  :                 return SD_API_STATUS_DEVICE_REMOVED;

  00274	e3a03147	 mov         r3, #0x47, 2
  00278	e58d3038	 str         r3, [sp, #0x38]
  0027c	ea000170	 b           |$LN31@SendComman|
  00280		 |$LN21@SendComman|

; 507  :             }
; 508  :         }

  00280	eaffffb7	 b           |$LN24@SendComman|
  00284		 |$LN23@SendComman|

; 509  : 
; 510  :         // Clear the MMC_STAT register
; 511  :         Write_MMC_STAT( Read_MMC_STAT() & (~MMC_STAT_CIRQ) );

  00284	e59d0074	 ldr         r0, [sp, #0x74]
  00288	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  0028c	e1cd05bc	 strh        r0, [sp, #0x5C]
  00290	e59d3074	 ldr         r3, [sp, #0x74]
  00294	e2830014	 add         r0, r3, #0x14
  00298	eb000000	 bl          EnterCriticalSection
  0029c	e59d3074	 ldr         r3, [sp, #0x74]
  002a0	e2833088	 add         r3, r3, #0x88
  002a4	e5933000	 ldr         r3, [r3]
  002a8	e2831010	 add         r1, r3, #0x10
  002ac	e1dd35bc	 ldrh        r3, [sp, #0x5C]
  002b0	e1a02003	 mov         r2, r3
  002b4	e3e03a02	 mvn         r3, #2, 20
  002b8	e0023003	 and         r3, r2, r3
  002bc	e1a03803	 mov         r3, r3, lsl #16
  002c0	e1a03823	 mov         r3, r3, lsr #16
  002c4	e1c130b0	 strh        r3, [r1]
  002c8	e59d3074	 ldr         r3, [sp, #0x74]
  002cc	e2830014	 add         r0, r3, #0x14
  002d0	eb000000	 bl          LeaveCriticalSection

; 512  : 
; 513  :         // unmask interrupts
; 514  :         OUTREG16(&m_vpSDIOReg->MMC_IE, (MMC_IE_EOC | MMC_IE_CTO | MMC_IE_CCRC | MMC_IE_CERR | MMC_IE_BRS));           

  002d4	e59d3074	 ldr         r3, [sp, #0x74]
  002d8	e2833088	 add         r3, r3, #0x88
  002dc	e5933000	 ldr         r3, [r3]
  002e0	e2832014	 add         r2, r3, #0x14
  002e4	e3a03c41	 mov         r3, #0x41, 24
  002e8	e3833089	 orr         r3, r3, #0x89
  002ec	e1c230b0	 strh        r3, [r2]
  002f0		 |$LN26@SendComman|

; 515  :     }
; 516  : 
; 517  :     // Clear the MMC_STAT register before issues command.
; 518  :     Write_MMC_STAT( Read_MMC_STAT() & (~MMC_STAT_CIRQ) );

  002f0	e59d0074	 ldr         r0, [sp, #0x74]
  002f4	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  002f8	e1cd05be	 strh        r0, [sp, #0x5E]
  002fc	e59d3074	 ldr         r3, [sp, #0x74]
  00300	e2830014	 add         r0, r3, #0x14
  00304	eb000000	 bl          EnterCriticalSection
  00308	e59d3074	 ldr         r3, [sp, #0x74]
  0030c	e2833088	 add         r3, r3, #0x88
  00310	e5933000	 ldr         r3, [r3]
  00314	e2831010	 add         r1, r3, #0x10
  00318	e1dd35be	 ldrh        r3, [sp, #0x5E]
  0031c	e1a02003	 mov         r2, r3
  00320	e3e03a02	 mvn         r3, #2, 20
  00324	e0023003	 and         r3, r2, r3
  00328	e1a03803	 mov         r3, r3, lsl #16
  0032c	e1a03823	 mov         r3, r3, lsr #16
  00330	e1c130b0	 strh        r3, [r1]
  00334	e59d3074	 ldr         r3, [sp, #0x74]
  00338	e2830014	 add         r0, r3, #0x14
  0033c	eb000000	 bl          LeaveCriticalSection

; 519  : 
; 520  :     MMC_CMD = Cmd;

  00340	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00344	e1cd30bc	 strh        r3, [sp, #0xC]

; 521  :     ASSERT( ( MMC_CMD & 0x003f ) == MMC_CMD );
; 522  : 
; 523  :     if( m_fAppCmdMode )

  00348	e59d3074	 ldr         r3, [sp, #0x74]
  0034c	e2833044	 add         r3, r3, #0x44
  00350	e5933000	 ldr         r3, [r3]
  00354	e3530000	 cmp         r3, #0
  00358	0a00000e	 beq         |$LN20@SendComman|

; 524  :     {
; 525  :         ASSERT( gwaCMD[Cmd].ACmd != 0 );
; 526  :         MMC_CMD |= gwaCMD[Cmd].ACMD_TYPE;

  0035c	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00360	e1a01003	 mov         r1, r3
  00364	e3a0300a	 mov         r3, #0xA
  00368	e0020391	 mul         r2, r1, r3
  0036c	e59f34e0	 ldr         r3, [pc, #0x4E0]
  00370	e0833002	 add         r3, r3, r2
  00374	e2833006	 add         r3, r3, #6
  00378	e1d330b0	 ldrh        r3, [r3]
  0037c	e1a02003	 mov         r2, r3
  00380	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00384	e1833002	 orr         r3, r3, r2
  00388	e1a03803	 mov         r3, r3, lsl #16
  0038c	e1a03823	 mov         r3, r3, lsr #16
  00390	e1cd30bc	 strh        r3, [sp, #0xC]

; 527  :     }
; 528  :     else

  00394	ea00003a	 b           |$LN19@SendComman|
  00398		 |$LN20@SendComman|

; 529  :     {
; 530  :         if( m_fMMCMode )

  00398	e59d3074	 ldr         r3, [sp, #0x74]
  0039c	e2833040	 add         r3, r3, #0x40
  003a0	e5933000	 ldr         r3, [r3]
  003a4	e3530000	 cmp         r3, #0
  003a8	0a000027	 beq         |$LN18@SendComman|

; 531  :         {
; 532  :             ASSERT( gwaCMD[Cmd].Cmd != 0 || gwaCMD[Cmd].MMCCmd != 0 );
; 533  :             if( gwaCMD[Cmd].MMCCmd )

  003ac	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  003b0	e1a01003	 mov         r1, r3
  003b4	e3a0300a	 mov         r3, #0xA
  003b8	e0020391	 mul         r2, r1, r3
  003bc	e59f3490	 ldr         r3, [pc, #0x490]
  003c0	e0833002	 add         r3, r3, r2
  003c4	e2833002	 add         r3, r3, #2
  003c8	e5d33000	 ldrb        r3, [r3]
  003cc	e3530000	 cmp         r3, #0
  003d0	0a00000e	 beq         |$LN17@SendComman|

; 534  :                 MMC_CMD |= gwaCMD[Cmd].MMC_CMD_TYPE;

  003d4	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  003d8	e1a01003	 mov         r1, r3
  003dc	e3a0300a	 mov         r3, #0xA
  003e0	e0020391	 mul         r2, r1, r3
  003e4	e59f3468	 ldr         r3, [pc, #0x468]
  003e8	e0833002	 add         r3, r3, r2
  003ec	e2833008	 add         r3, r3, #8
  003f0	e1d330b0	 ldrh        r3, [r3]
  003f4	e1a02003	 mov         r2, r3
  003f8	e1dd30bc	 ldrh        r3, [sp, #0xC]
  003fc	e1833002	 orr         r3, r3, r2
  00400	e1a03803	 mov         r3, r3, lsl #16
  00404	e1a03823	 mov         r3, r3, lsr #16
  00408	e1cd30bc	 strh        r3, [sp, #0xC]

; 535  :             else

  0040c	ea00000d	 b           |$LN16@SendComman|
  00410		 |$LN17@SendComman|

; 536  :                 MMC_CMD |= gwaCMD[Cmd].CMD_TYPE;

  00410	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00414	e1a01003	 mov         r1, r3
  00418	e3a0300a	 mov         r3, #0xA
  0041c	e0020391	 mul         r2, r1, r3
  00420	e59f342c	 ldr         r3, [pc, #0x42C]
  00424	e0833002	 add         r3, r3, r2
  00428	e2833004	 add         r3, r3, #4
  0042c	e1d330b0	 ldrh        r3, [r3]
  00430	e1a02003	 mov         r2, r3
  00434	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00438	e1833002	 orr         r3, r3, r2
  0043c	e1a03803	 mov         r3, r3, lsl #16
  00440	e1a03823	 mov         r3, r3, lsr #16
  00444	e1cd30bc	 strh        r3, [sp, #0xC]
  00448		 |$LN16@SendComman|

; 537  :         }
; 538  :         else

  00448	ea00000d	 b           |$LN15@SendComman|
  0044c		 |$LN18@SendComman|

; 539  :         {
; 540  :             ASSERT( gwaCMD[Cmd].Cmd != 0 || gwaCMD[Cmd].MMCCmd != 0 );
; 541  :             MMC_CMD |= gwaCMD[Cmd].CMD_TYPE;

  0044c	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00450	e1a01003	 mov         r1, r3
  00454	e3a0300a	 mov         r3, #0xA
  00458	e0020391	 mul         r2, r1, r3
  0045c	e59f33f0	 ldr         r3, [pc, #0x3F0]
  00460	e0833002	 add         r3, r3, r2
  00464	e2833004	 add         r3, r3, #4
  00468	e1d330b0	 ldrh        r3, [r3]
  0046c	e1a02003	 mov         r2, r3
  00470	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00474	e1833002	 orr         r3, r3, r2
  00478	e1a03803	 mov         r3, r3, lsl #16
  0047c	e1a03823	 mov         r3, r3, lsr #16
  00480	e1cd30bc	 strh        r3, [sp, #0xC]
  00484		 |$LN15@SendComman|
  00484		 |$LN19@SendComman|

; 542  :         }
; 543  :     }
; 544  : 
; 545  :     switch( respType )

  00484	e1dd31b4	 ldrh        r3, [sp, #0x14]
  00488	e58d3060	 str         r3, [sp, #0x60]
  0048c	e59d3060	 ldr         r3, [sp, #0x60]
  00490	e3530001	 cmp         r3, #1
  00494	0a000012	 beq         |$LN12@SendComman|
  00498	e59d3060	 ldr         r3, [sp, #0x60]
  0049c	e3530002	 cmp         r3, #2
  004a0	0a000015	 beq         |$LN11@SendComman|
  004a4	e59d3060	 ldr         r3, [sp, #0x60]
  004a8	e3530003	 cmp         r3, #3
  004ac	0a000018	 beq         |$LN10@SendComman|
  004b0	e59d3060	 ldr         r3, [sp, #0x60]
  004b4	e3530004	 cmp         r3, #4
  004b8	0a00001b	 beq         |$LN9@SendComman|
  004bc	e59d3060	 ldr         r3, [sp, #0x60]
  004c0	e3530005	 cmp         r3, #5
  004c4	0a00001e	 beq         |$LN8@SendComman|
  004c8	e59d3060	 ldr         r3, [sp, #0x60]
  004cc	e3530006	 cmp         r3, #6
  004d0	0a000033	 beq         |$LN7@SendComman|
  004d4	e59d3060	 ldr         r3, [sp, #0x60]
  004d8	e3530007	 cmp         r3, #7
  004dc	0a000036	 beq         |$LN6@SendComman|
  004e0	ea00003a	 b           |$LN13@SendComman|
  004e4		 |$LN12@SendComman|

; 546  :     {
; 547  :     case ResponseR1:                // Short response required
; 548  :         MMC_CMD |= 0x100;

  004e4	e1dd30bc	 ldrh        r3, [sp, #0xC]
  004e8	e3833c01	 orr         r3, r3, #1, 24
  004ec	e1a03803	 mov         r3, r3, lsl #16
  004f0	e1a03823	 mov         r3, r3, lsr #16
  004f4	e1cd30bc	 strh        r3, [sp, #0xC]

; 549  :         break;

  004f8	ea000034	 b           |$LN13@SendComman|
  004fc		 |$LN11@SendComman|

; 550  :     case ResponseR1b:
; 551  :         MMC_CMD |= 0x900;

  004fc	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00500	e3833c09	 orr         r3, r3, #9, 24
  00504	e1a03803	 mov         r3, r3, lsl #16
  00508	e1a03823	 mov         r3, r3, lsr #16
  0050c	e1cd30bc	 strh        r3, [sp, #0xC]

; 552  :         break;

  00510	ea00002e	 b           |$LN13@SendComman|
  00514		 |$LN10@SendComman|

; 553  :     case ResponseR2:
; 554  :         MMC_CMD |= 0x200;

  00514	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00518	e3833c02	 orr         r3, r3, #2, 24
  0051c	e1a03803	 mov         r3, r3, lsl #16
  00520	e1a03823	 mov         r3, r3, lsr #16
  00524	e1cd30bc	 strh        r3, [sp, #0xC]

; 555  :         break;

  00528	ea000028	 b           |$LN13@SendComman|
  0052c		 |$LN9@SendComman|

; 556  :     case ResponseR3:
; 557  :         MMC_CMD |= 0x300;

  0052c	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00530	e3833c03	 orr         r3, r3, #3, 24
  00534	e1a03803	 mov         r3, r3, lsl #16
  00538	e1a03823	 mov         r3, r3, lsr #16
  0053c	e1cd30bc	 strh        r3, [sp, #0xC]

; 558  :         break;

  00540	ea000022	 b           |$LN13@SendComman|
  00544		 |$LN8@SendComman|

; 559  :     case ResponseR4:
; 560  :         MMC_CMD |= 0x400;

  00544	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00548	e3833b01	 orr         r3, r3, #1, 22
  0054c	e1a03803	 mov         r3, r3, lsl #16
  00550	e1a03823	 mov         r3, r3, lsr #16
  00554	e1cd30bc	 strh        r3, [sp, #0xC]

; 561  :         Write_MMC_SDIO( Read_MMC_SDIO() | MMC_IE_CTO ); // disable CRC check in R4 response

  00558	e59d0074	 ldr         r0, [sp, #0x74]
  0055c	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  00560	e1cd06b4	 strh        r0, [sp, #0x64]
  00564	e59d3074	 ldr         r3, [sp, #0x74]
  00568	e2830014	 add         r0, r3, #0x14
  0056c	eb000000	 bl          EnterCriticalSection
  00570	e59d3074	 ldr         r3, [sp, #0x74]
  00574	e2833088	 add         r3, r3, #0x88
  00578	e5933000	 ldr         r3, [r3]
  0057c	e2832034	 add         r2, r3, #0x34
  00580	e1dd36b4	 ldrh        r3, [sp, #0x64]
  00584	e3833080	 orr         r3, r3, #0x80
  00588	e1a03803	 mov         r3, r3, lsl #16
  0058c	e1a03823	 mov         r3, r3, lsr #16
  00590	e1c230b0	 strh        r3, [r2]
  00594	e59d3074	 ldr         r3, [sp, #0x74]
  00598	e2830014	 add         r0, r3, #0x14
  0059c	eb000000	 bl          LeaveCriticalSection

; 562  :         break;

  005a0	ea00000a	 b           |$LN13@SendComman|
  005a4		 |$LN7@SendComman|

; 563  :     case ResponseR5:                
; 564  :         MMC_CMD |= 0x500;

  005a4	e1dd30bc	 ldrh        r3, [sp, #0xC]
  005a8	e3833c05	 orr         r3, r3, #5, 24
  005ac	e1a03803	 mov         r3, r3, lsl #16
  005b0	e1a03823	 mov         r3, r3, lsr #16
  005b4	e1cd30bc	 strh        r3, [sp, #0xC]

; 565  :         break;

  005b8	ea000004	 b           |$LN13@SendComman|
  005bc		 |$LN6@SendComman|

; 566  :     case ResponseR6:
; 567  :         MMC_CMD |= 0x600;

  005bc	e1dd30bc	 ldrh        r3, [sp, #0xC]
  005c0	e3833c06	 orr         r3, r3, #6, 24
  005c4	e1a03803	 mov         r3, r3, lsl #16
  005c8	e1a03823	 mov         r3, r3, lsr #16
  005cc	e1cd30bc	 strh        r3, [sp, #0xC]
  005d0		 |$LN13@SendComman|

; 568  :         break;
; 569  :     }
; 570  : 
; 571  :     if ((Cmd == SD_CMD_IO_RW_DIRECT) || (Cmd == SD_CMD_IO_RW_EXTENDED))

  005d0	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  005d4	e3530034	 cmp         r3, #0x34
  005d8	0a000002	 beq         |$LN4@SendComman|
  005dc	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  005e0	e3530035	 cmp         r3, #0x35
  005e4	1a000019	 bne         |$LN5@SendComman|
  005e8		 |$LN4@SendComman|

; 572  :     {
; 573  :         Write_MMC_SDIO( Read_MMC_SDIO() | ( BIT15 | BIT6 ) );

  005e8	e59d0074	 ldr         r0, [sp, #0x74]
  005ec	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  005f0	e1cd06b6	 strh        r0, [sp, #0x66]
  005f4	e59d3074	 ldr         r3, [sp, #0x74]
  005f8	e2830014	 add         r0, r3, #0x14
  005fc	eb000000	 bl          EnterCriticalSection
  00600	e59d3074	 ldr         r3, [sp, #0x74]
  00604	e2833088	 add         r3, r3, #0x88
  00608	e5933000	 ldr         r3, [r3]
  0060c	e2831034	 add         r1, r3, #0x34
  00610	e1dd36b6	 ldrh        r3, [sp, #0x66]
  00614	e1a02003	 mov         r2, r3
  00618	e3a03902	 mov         r3, #2, 18
  0061c	e3833040	 orr         r3, r3, #0x40
  00620	e1823003	 orr         r3, r2, r3
  00624	e1a03803	 mov         r3, r3, lsl #16
  00628	e1a03823	 mov         r3, r3, lsr #16
  0062c	e1c130b0	 strh        r3, [r1]
  00630	e59d3074	 ldr         r3, [sp, #0x74]
  00634	e2830014	 add         r0, r3, #0x14
  00638	eb000000	 bl          LeaveCriticalSection

; 574  :         MMC_CMD |= 0x0040;

  0063c	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00640	e3833040	 orr         r3, r3, #0x40
  00644	e1a03803	 mov         r3, r3, lsl #16
  00648	e1a03823	 mov         r3, r3, lsr #16
  0064c	e1cd30bc	 strh        r3, [sp, #0xC]
  00650		 |$LN5@SendComman|

; 575  :     }
; 576  : 
; 577  :     CLRREG16(&m_vpSDIOReg->MMC_BUF, (MMC_BUF_RXDE|MMC_BUF_TXDE));

  00650	e59d3074	 ldr         r3, [sp, #0x74]
  00654	e2833088	 add         r3, r3, #0x88
  00658	e5933000	 ldr         r3, [r3]
  0065c	e283302c	 add         r3, r3, #0x2C
  00660	e1d330b0	 ldrh        r3, [r3]
  00664	e1a02003	 mov         r2, r3
  00668	e3e03902	 mvn         r3, #2, 18
  0066c	e2233080	 eor         r3, r3, #0x80
  00670	e0023003	 and         r3, r2, r3
  00674	e1a02803	 mov         r2, r3, lsl #16
  00678	e1a02822	 mov         r2, r2, lsr #16
  0067c	e59d3074	 ldr         r3, [sp, #0x74]
  00680	e2833088	 add         r3, r3, #0x88
  00684	e5933000	 ldr         r3, [r3]
  00688	e283302c	 add         r3, r3, #0x2C
  0068c	e1c320b0	 strh        r2, [r3]

; 578  : 
; 579  :     if( TransferClass == SD_READ )

  00690	e1dd30b0	 ldrh        r3, [sp]
  00694	e3530000	 cmp         r3, #0
  00698	1a000021	 bne         |$LN3@SendComman|

; 580  :     {
; 581  :         MMC_CMD |= 0x8000;

  0069c	e1dd30bc	 ldrh        r3, [sp, #0xC]
  006a0	e3833902	 orr         r3, r3, #2, 18
  006a4	e1a03803	 mov         r3, r3, lsl #16
  006a8	e1a03823	 mov         r3, r3, lsr #16
  006ac	e1cd30bc	 strh        r3, [sp, #0xC]

; 582  :         OUTREG16(&m_vpSDIOReg->MMC_BLEN, ((WORD)(( pRequest->BlockSize - 1 ) & 0x7ff)));

  006b0	e59d3078	 ldr         r3, [sp, #0x78]
  006b4	e2833040	 add         r3, r3, #0x40
  006b8	e5933000	 ldr         r3, [r3]
  006bc	e2432001	 sub         r2, r3, #1
  006c0	e3a03c07	 mov         r3, #7, 24
  006c4	e38330ff	 orr         r3, r3, #0xFF
  006c8	e0023003	 and         r3, r2, r3
  006cc	e1a02803	 mov         r2, r3, lsl #16
  006d0	e1a02822	 mov         r2, r2, lsr #16
  006d4	e59d3074	 ldr         r3, [sp, #0x74]
  006d8	e2833088	 add         r3, r3, #0x88
  006dc	e5933000	 ldr         r3, [r3]
  006e0	e2833024	 add         r3, r3, #0x24
  006e4	e1c320b0	 strh        r2, [r3]

; 583  :         OUTREG16(&m_vpSDIOReg->MMC_NBLK, ((WORD)(( pRequest->NumBlocks - 1 ) & 0x7ff)));

  006e8	e59d3078	 ldr         r3, [sp, #0x78]
  006ec	e283303c	 add         r3, r3, #0x3C
  006f0	e5933000	 ldr         r3, [r3]
  006f4	e2432001	 sub         r2, r3, #1
  006f8	e3a03c07	 mov         r3, #7, 24
  006fc	e38330ff	 orr         r3, r3, #0xFF
  00700	e0023003	 and         r3, r2, r3
  00704	e1a02803	 mov         r2, r3, lsl #16
  00708	e1a02822	 mov         r2, r2, lsr #16
  0070c	e59d3074	 ldr         r3, [sp, #0x74]
  00710	e2833088	 add         r3, r3, #0x88
  00714	e5933000	 ldr         r3, [r3]
  00718	e2833028	 add         r3, r3, #0x28
  0071c	e1c320b0	 strh        r2, [r3]
  00720	ea000025	 b           |$LN2@SendComman|
  00724		 |$LN3@SendComman|

; 584  :     }
; 585  :     else if( TransferClass == SD_WRITE )

  00724	e1dd30b0	 ldrh        r3, [sp]
  00728	e3530001	 cmp         r3, #1
  0072c	1a000022	 bne         |$LN1@SendComman|

; 586  :     {
; 587  :         MMC_CMD &= ~0x8000;

  00730	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00734	e1a02003	 mov         r2, r3
  00738	e3e03902	 mvn         r3, #2, 18
  0073c	e0023003	 and         r3, r2, r3
  00740	e1a03803	 mov         r3, r3, lsl #16
  00744	e1a03823	 mov         r3, r3, lsr #16
  00748	e1cd30bc	 strh        r3, [sp, #0xC]

; 588  :         OUTREG16(&m_vpSDIOReg->MMC_BLEN, ((WORD)(( pRequest->BlockSize - 1 ) & 0x7ff)));

  0074c	e59d3078	 ldr         r3, [sp, #0x78]
  00750	e2833040	 add         r3, r3, #0x40
  00754	e5933000	 ldr         r3, [r3]
  00758	e2432001	 sub         r2, r3, #1
  0075c	e3a03c07	 mov         r3, #7, 24
  00760	e38330ff	 orr         r3, r3, #0xFF
  00764	e0023003	 and         r3, r2, r3
  00768	e1a02803	 mov         r2, r3, lsl #16
  0076c	e1a02822	 mov         r2, r2, lsr #16
  00770	e59d3074	 ldr         r3, [sp, #0x74]
  00774	e2833088	 add         r3, r3, #0x88
  00778	e5933000	 ldr         r3, [r3]
  0077c	e2833024	 add         r3, r3, #0x24
  00780	e1c320b0	 strh        r2, [r3]

; 589  :         OUTREG16(&m_vpSDIOReg->MMC_NBLK, ((WORD)(( pRequest->NumBlocks - 1 ) & 0x7ff)));

  00784	e59d3078	 ldr         r3, [sp, #0x78]
  00788	e283303c	 add         r3, r3, #0x3C
  0078c	e5933000	 ldr         r3, [r3]
  00790	e2432001	 sub         r2, r3, #1
  00794	e3a03c07	 mov         r3, #7, 24
  00798	e38330ff	 orr         r3, r3, #0xFF
  0079c	e0023003	 and         r3, r2, r3
  007a0	e1a02803	 mov         r2, r3, lsl #16
  007a4	e1a02822	 mov         r2, r2, lsr #16
  007a8	e59d3074	 ldr         r3, [sp, #0x74]
  007ac	e2833088	 add         r3, r3, #0x88
  007b0	e5933000	 ldr         r3, [r3]
  007b4	e2833028	 add         r3, r3, #0x28
  007b8	e1c320b0	 strh        r2, [r3]
  007bc		 |$LN1@SendComman|
  007bc		 |$LN2@SendComman|

; 590  :     }
; 591  : 
; 592  :     // Program the argument into the argument registers
; 593  :     OUTREG16(&m_vpSDIOReg->MMC_ARG1, Arg);

  007bc	e59d3004	 ldr         r3, [sp, #4]
  007c0	e1a02803	 mov         r2, r3, lsl #16
  007c4	e1a02822	 mov         r2, r2, lsr #16
  007c8	e59d3074	 ldr         r3, [sp, #0x74]
  007cc	e2833088	 add         r3, r3, #0x88
  007d0	e5933000	 ldr         r3, [r3]
  007d4	e2833004	 add         r3, r3, #4
  007d8	e1c320b0	 strh        r2, [r3]

; 594  :     OUTREG16(&m_vpSDIOReg->MMC_ARG2, ((WORD)(Arg >> 16)));

  007dc	e59d3004	 ldr         r3, [sp, #4]
  007e0	e1a03823	 mov         r3, r3, lsr #16
  007e4	e1a02803	 mov         r2, r3, lsl #16
  007e8	e1a02822	 mov         r2, r2, lsr #16
  007ec	e59d3074	 ldr         r3, [sp, #0x74]
  007f0	e2833088	 add         r3, r3, #0x88
  007f4	e5933000	 ldr         r3, [r3]
  007f8	e2833008	 add         r3, r3, #8
  007fc	e1c320b0	 strh        r2, [r3]

; 595  : 
; 596  :     DEBUGMSG(SHC_SEND_ZONE, (L"CSDIOControllerBase::SendCommand: "
; 597  :         L"Registers:Command = 0x%x, MMC_ARG1 = 0x%x, MMC_ARG2 = 0x%x\r\n",
; 598  :         MMC_CMD, m_vpSDIOReg->MMC_ARG1 , m_vpSDIOReg->MMC_ARG2
; 599  :     ));
; 600  : 
; 601  :     MMC_STAT = Read_MMC_STAT();

  00800	e59d0074	 ldr         r0, [sp, #0x74]
  00804	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00808	e1cd06b8	 strh        r0, [sp, #0x68]
  0080c	e1dd36b8	 ldrh        r3, [sp, #0x68]
  00810	e1cd30be	 strh        r3, [sp, #0xE]

; 602  : 
; 603  :     // Issue the command.
; 604  :     OUTREG16(&m_vpSDIOReg->MMC_CMD, MMC_CMD);

  00814	e59d3074	 ldr         r3, [sp, #0x74]
  00818	e2833088	 add         r3, r3, #0x88
  0081c	e5932000	 ldr         r2, [r3]
  00820	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00824	e1c230b0	 strh        r3, [r2]

; 605  :     MMC_STAT = Read_MMC_STAT();

  00828	e59d0074	 ldr         r0, [sp, #0x74]
  0082c	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00830	e1cd06ba	 strh        r0, [sp, #0x6A]
  00834	e1dd36ba	 ldrh        r3, [sp, #0x6A]
  00838	e1cd30be	 strh        r3, [sp, #0xE]

; 606  : 
; 607  :     return SD_API_STATUS_PENDING;

  0083c	e3a03001	 mov         r3, #1
  00840	e58d3038	 str         r3, [sp, #0x38]
  00844		 |$LN31@SendComman|

; 608  : }

  00844	e59d0038	 ldr         r0, [sp, #0x38]
  00848	e28dd06c	 add         sp, sp, #0x6C
  0084c	e89d6000	 ldmia       sp, {sp, lr}
  00850	e12fff1e	 bx          lr
  00854		 |$LN70@SendComman|
  00854		 |$LN71@SendComman|
  00854	00000000	 DCD         |gwaCMD|
  00858		 |$M42146|

			 ENDP  ; |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SendCommand

	EXPORT	|?HandleRemoval@CSDIOControllerBase@@QAAXH@Z| ; CSDIOControllerBase::HandleRemoval
	IMPORT	|SDHCDGetAndLockCurrentRequest|

  00000			 AREA	 |.pdata|, PDATA
|$T42157| DCD	|$LN8@HandleRemo|
	DCD	0x40003e04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z| PROC ; CSDIOControllerBase::HandleRemoval

; 617  : {    

  00000		 |$LN8@HandleRemo|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42154|

; 618  :     m_fCardPresent = FALSE;

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e2832038	 add         r2, r3, #0x38
  00018	e3a03000	 mov         r3, #0
  0001c	e5823000	 str         r3, [r2]

; 619  :     m_fMMCMode = FALSE;

  00020	e59d3010	 ldr         r3, [sp, #0x10]
  00024	e2832040	 add         r2, r3, #0x40
  00028	e3a03000	 mov         r3, #0
  0002c	e5823000	 str         r3, [r2]

; 620  : 
; 621  :     IndicateSlotStateChange(DeviceEjected);

  00030	e3a02001	 mov         r2, #1
  00034	e3a01000	 mov         r1, #0
  00038	e59d3010	 ldr         r3, [sp, #0x10]
  0003c	e2833004	 add         r3, r3, #4
  00040	e5930000	 ldr         r0, [r3]
  00044	eb000000	 bl          SDHCDIndicateSlotStateChange

; 622  : 
; 623  :     // turn clock off and remove power from the slot
; 624  :     ClockOff();

  00048	e59d0010	 ldr         r0, [sp, #0x10]
  0004c	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 625  :     TurnCardPowerOff();

  00050	e59d3010	 ldr         r3, [sp, #0x10]
  00054	e5933000	 ldr         r3, [r3]
  00058	e2833020	 add         r3, r3, #0x20
  0005c	e59d0010	 ldr         r0, [sp, #0x10]
  00060	e5933000	 ldr         r3, [r3]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff13	 bx          r3

; 626  : 
; 627  :     // turn off SDIO interrupts
; 628  :     if( m_fSDIOInterruptsEnabled )

  0006c	e59d3010	 ldr         r3, [sp, #0x10]
  00070	e283303c	 add         r3, r3, #0x3C
  00074	e5933000	 ldr         r3, [r3]
  00078	e3530000	 cmp         r3, #0
  0007c	0a000001	 beq         |$LN3@HandleRemo|

; 629  :     {
; 630  :         DisableSDIOInterrupts();

  00080	e59d0010	 ldr         r0, [sp, #0x10]
  00084	eb000000	 bl          |?DisableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|
  00088		 |$LN3@HandleRemo|

; 631  :     }
; 632  : 
; 633  :     if (fCancelRequest) {

  00088	e59d3014	 ldr         r3, [sp, #0x14]
  0008c	e3530000	 cmp         r3, #0
  00090	0a000015	 beq         |$LN2@HandleRemo|

; 634  :         // get the current request  
; 635  :         PSD_BUS_REQUEST pRequest = GetAndLockCurrentRequest();

  00094	e3a01000	 mov         r1, #0
  00098	e59d3010	 ldr         r3, [sp, #0x10]
  0009c	e2833004	 add         r3, r3, #4
  000a0	e5930000	 ldr         r0, [r3]
  000a4	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  000a8	e58d0004	 str         r0, [sp, #4]
  000ac	e59d3004	 ldr         r3, [sp, #4]
  000b0	e58d3000	 str         r3, [sp]

; 636  : 
; 637  :         if (pRequest != NULL) {

  000b4	e59d3000	 ldr         r3, [sp]
  000b8	e3530000	 cmp         r3, #0
  000bc	0a00000a	 beq         |$LN1@HandleRemo|

; 638  :             DEBUGMSG(SDCARD_ZONE_WARN, (L"CSDIOControllerBase::HandleRemoval: "
; 639  :                 L"Card Removal Detected - Canceling current request: 0x%08X, command: %d\r\n", 
; 640  :                 pRequest, pRequest->CommandCode
; 641  :             ));
; 642  :             DumpRequest(pRequest);
; 643  :             IndicateBusRequestComplete(pRequest, SD_API_STATUS_DEVICE_REMOVED);

  000c0	e3a02147	 mov         r2, #0x47, 2
  000c4	e59d1000	 ldr         r1, [sp]
  000c8	e59d3010	 ldr         r3, [sp, #0x10]
  000cc	e5933000	 ldr         r3, [r3]
  000d0	e2833004	 add         r3, r3, #4
  000d4	e59d0010	 ldr         r0, [sp, #0x10]
  000d8	e5933000	 ldr         r3, [r3]
  000dc	e1a0e00f	 mov         lr, pc
  000e0	e12fff13	 bx          r3

; 644  :             
; 645  :             ClockOff();

  000e4	e59d0010	 ldr         r0, [sp, #0x10]
  000e8	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|
  000ec		 |$LN1@HandleRemo|
  000ec		 |$LN2@HandleRemo|

; 646  :         }
; 647  :     }
; 648  : }

  000ec	e28dd008	 add         sp, sp, #8
  000f0	e89d6000	 ldmia       sp, {sp, lr}
  000f4	e12fff1e	 bx          lr
  000f8		 |$M42155|

			 ENDP  ; |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|, CSDIOControllerBase::HandleRemoval

	EXPORT	|?HandleInsertion@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::HandleInsertion

  00000			 AREA	 |.pdata|, PDATA
|$T42164| DCD	|$LN5@HandleInse|
	DCD	0x40002004
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleInsertion@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::HandleInsertion

; 654  : {

  00000		 |$LN5@HandleInse|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M42161|

; 655  :     DWORD dwClockRate = SD_DEFAULT_CARD_ID_CLOCK_RATE;

  00010	e3a03b61	 mov         r3, #0x61, 22
  00014	e3833e2a	 orr         r3, r3, #0x2A, 28
  00018	e58d3000	 str         r3, [sp]

; 656  : 
; 657  :     m_fCardPresent = TRUE;

  0001c	e59d300c	 ldr         r3, [sp, #0xC]
  00020	e2832038	 add         r2, r3, #0x38
  00024	e3a03001	 mov         r3, #1
  00028	e5823000	 str         r3, [r2]

; 658  : 
; 659  :     DEBUGMSG(SDCARD_ZONE_FUNC, (L"+CSDIOControllerBase::HandleInsertion\r\n"));
; 660  : 
; 661  :     // turn power to the card on
; 662  :     TurnCardPowerOn();

  0002c	e59d300c	 ldr         r3, [sp, #0xC]
  00030	e5933000	 ldr         r3, [r3]
  00034	e283301c	 add         r3, r3, #0x1C
  00038	e59d000c	 ldr         r0, [sp, #0xC]
  0003c	e5933000	 ldr         r3, [r3]
  00040	e1a0e00f	 mov         lr, pc
  00044	e12fff13	 bx          r3

; 663  : 
; 664  :     SetClockRate(&dwClockRate);

  00048	e28d1000	 add         r1, sp, #0
  0004c	e59d000c	 ldr         r0, [sp, #0xC]
  00050	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|

; 665  :     
; 666  :     ClockOn();

  00054	e59d000c	 ldr         r0, [sp, #0xC]
  00058	eb000000	 bl          |?ClockOn@CSDIOControllerBase@@QAAXXZ|

; 667  : 
; 668  :     // indicate device arrival
; 669  :     IndicateSlotStateChange(DeviceInserted);

  0005c	e3a02002	 mov         r2, #2
  00060	e3a01000	 mov         r1, #0
  00064	e59d300c	 ldr         r3, [sp, #0xC]
  00068	e2833004	 add         r3, r3, #4
  0006c	e5930000	 ldr         r0, [r3]
  00070	eb000000	 bl          SDHCDIndicateSlotStateChange

; 670  : }

  00074	e28dd004	 add         sp, sp, #4
  00078	e89d6000	 ldmia       sp, {sp, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M42162|

			 ENDP  ; |?HandleInsertion@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::HandleInsertion

	EXPORT	|?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAXXZ| ; CSDIOControllerBase::HandleCardDetectInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T42171| DCD	|$LN10@HandleCard|
	DCD	0x40003904
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAXXZ| PROC ; CSDIOControllerBase::HandleCardDetectInterrupt

; 674  : {

  00000		 |$LN10@HandleCard|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M42168|

; 675  :     DEBUGMSG(SHC_INTERRUPT_ZONE, (L"+CSDHCSlot::HandleCardDetectInterrupt\r\n"));
; 676  : 
; 677  :     SDHCDAcquireHCLock(m_pHCContext);

  00010	e59d300c	 ldr         r3, [sp, #0xC]
  00014	e2833004	 add         r3, r3, #4
  00018	e5933000	 ldr         r3, [r3]
  0001c	e2830024	 add         r0, r3, #0x24
  00020	eb000000	 bl          EnterCriticalSection

; 678  : 
; 679  :     if( SDCardDetect() )

  00024	e59d300c	 ldr         r3, [sp, #0xC]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2833014	 add         r3, r3, #0x14
  00030	e59d000c	 ldr         r0, [sp, #0xC]
  00034	e5933000	 ldr         r3, [r3]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3
  00040	e58d0000	 str         r0, [sp]
  00044	e59d3000	 ldr         r3, [sp]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000014	 beq         |$LN5@HandleCard|

; 680  :     {
; 681  :         DEBUGMSG(SHC_INTERRUPT_ZONE, (L"CSDHCSlot::HandleCardDetectInterrupt: "
; 682  :             L"Card is Inserted!\r\n"
; 683  :         ));
; 684  :         
; 685  :         if( m_fCardPresent == FALSE || m_bReinsertTheCard ) {

  00050	e59d300c	 ldr         r3, [sp, #0xC]
  00054	e2833038	 add         r3, r3, #0x38
  00058	e5933000	 ldr         r3, [r3]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000004	 beq         |$LN3@HandleCard|
  00064	e59d300c	 ldr         r3, [sp, #0xC]
  00068	e283302c	 add         r3, r3, #0x2C
  0006c	e5933000	 ldr         r3, [r3]
  00070	e3530000	 cmp         r3, #0
  00074	0a000009	 beq         |$LN4@HandleCard|
  00078		 |$LN3@HandleCard|

; 686  :             m_bReinsertTheCard = FALSE;

  00078	e59d300c	 ldr         r3, [sp, #0xC]
  0007c	e283202c	 add         r2, r3, #0x2C
  00080	e3a03000	 mov         r3, #0
  00084	e5823000	 str         r3, [r2]

; 687  :             m_fFirstTime = TRUE;

  00088	e59d300c	 ldr         r3, [sp, #0xC]
  0008c	e2832080	 add         r2, r3, #0x80
  00090	e3a03001	 mov         r3, #1
  00094	e5823000	 str         r3, [r2]

; 688  :             HandleInsertion();

  00098	e59d000c	 ldr         r0, [sp, #0xC]
  0009c	eb000000	 bl          |?HandleInsertion@CSDIOControllerBase@@QAAXXZ|
  000a0		 |$LN4@HandleCard|

; 689  :         }
; 690  :     }

  000a0	ea000007	 b           |$LN2@HandleCard|
  000a4		 |$LN5@HandleCard|

; 691  :     else if( m_fCardPresent ) 

  000a4	e59d300c	 ldr         r3, [sp, #0xC]
  000a8	e2833038	 add         r3, r3, #0x38
  000ac	e5933000	 ldr         r3, [r3]
  000b0	e3530000	 cmp         r3, #0
  000b4	0a000002	 beq         |$LN1@HandleCard|

; 692  :     {
; 693  :         DEBUGMSG(SHC_INTERRUPT_ZONE, (L"CSDHCSlot::HandleCardDetectInterrupt: "
; 694  :             L"Card is Removed!\r\n"));
; 695  :         HandleRemoval(TRUE);

  000b8	e3a01001	 mov         r1, #1
  000bc	e59d000c	 ldr         r0, [sp, #0xC]
  000c0	eb000000	 bl          |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|
  000c4		 |$LN1@HandleCard|
  000c4		 |$LN2@HandleCard|

; 696  :     }
; 697  : 
; 698  :     SDHCDReleaseHCLock(m_pHCContext);

  000c4	e59d300c	 ldr         r3, [sp, #0xC]
  000c8	e2833004	 add         r3, r3, #4
  000cc	e5933000	 ldr         r3, [r3]
  000d0	e2830024	 add         r0, r3, #0x24
  000d4	eb000000	 bl          LeaveCriticalSection

; 699  : }

  000d8	e28dd004	 add         sp, sp, #4
  000dc	e89d6000	 ldmia       sp, {sp, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M42169|

			 ENDP  ; |?HandleCardDetectInterrupt@CSDIOControllerBase@@QAAXXZ|, CSDIOControllerBase::HandleCardDetectInterrupt

	EXPORT	|??1CSDIOControllerBase@@UAA@XZ|	; CSDIOControllerBase::~CSDIOControllerBase
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T42178| DCD	|$LN5@CSDIOContr@2|
	DCD	0x40000c03
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CSDIOControllerBase@@UAA@XZ| PROC	; CSDIOControllerBase::~CSDIOControllerBase

; 742  : {

  00000		 |$LN5@CSDIOContr@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M42175|
  0000c	e59f2018	 ldr         r2, [pc, #0x18]
  00010	e59d3008	 ldr         r3, [sp, #8]
  00014	e5832000	 str         r2, [r3]

; 743  :     DeleteCriticalSection( &m_critSec );

  00018	e59d3008	 ldr         r3, [sp, #8]
  0001c	e2830014	 add         r0, r3, #0x14
  00020	eb000000	 bl          DeleteCriticalSection

; 744  : }

  00024	e89d6000	 ldmia       sp, {sp, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN6@CSDIOContr@2|
  0002c		 |$LN7@CSDIOContr@2|
  0002c	00000000	 DCD         |??_7CSDIOControllerBase@@6B@|
  00030		 |$M42176|

			 ENDP  ; |??1CSDIOControllerBase@@UAA@XZ|, CSDIOControllerBase::~CSDIOControllerBase

	EXPORT	|?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z| ; CSDIOControllerBase::FreeHostContext
	IMPORT	|SDHCDDeleteContext|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|SDHCDDeregisterHostController|

  00000			 AREA	 |.pdata|, PDATA
|$T42187| DCD	|$LN8@FreeHostCo|
	DCD	0x40003103
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z| PROC ; CSDIOControllerBase::FreeHostContext

; 874  : {

  00000		 |$LN8@FreeHostCo|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M42184|

; 875  :     DEBUGCHK(m_pHCContext);
; 876  :     ClockOff();

  0000c	e59d0008	 ldr         r0, [sp, #8]
  00010	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 877  : 
; 878  :     if (fRegisteredWithBusDriver) {

  00014	e59d300c	 ldr         r3, [sp, #0xC]
  00018	e3530000	 cmp         r3, #0
  0001c	0a000003	 beq         |$LN3@FreeHostCo|

; 879  :         // deregister the host controller
; 880  :         SDHCDDeregisterHostController(m_pHCContext);

  00020	e59d3008	 ldr         r3, [sp, #8]
  00024	e2833004	 add         r3, r3, #4
  00028	e5930000	 ldr         r0, [r3]
  0002c	eb000000	 bl          SDHCDDeregisterHostController
  00030		 |$LN3@FreeHostCo|

; 881  :     }
; 882  : 
; 883  :     // unmap hardware memory space
; 884  : 
; 885  :     DeinitializeHardware();

  00030	e59d3008	 ldr         r3, [sp, #8]
  00034	e5933000	 ldr         r3, [r3]
  00038	e283300c	 add         r3, r3, #0xC
  0003c	e59d0008	 ldr         r0, [sp, #8]
  00040	e5933000	 ldr         r3, [r3]
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 886  :     if (m_vpSDIOReg) MmUnmapIoSpace((PVOID)m_vpSDIOReg, sizeof(OMAP2420_SDIO_REGS));

  0004c	e59d3008	 ldr         r3, [sp, #8]
  00050	e2833088	 add         r3, r3, #0x88
  00054	e5933000	 ldr         r3, [r3]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000004	 beq         |$LN2@FreeHostCo|
  00060	e3a0106a	 mov         r1, #0x6A
  00064	e59d3008	 ldr         r3, [sp, #8]
  00068	e2833088	 add         r3, r3, #0x88
  0006c	e5930000	 ldr         r0, [r3]
  00070	eb000000	 bl          MmUnmapIoSpace
  00074		 |$LN2@FreeHostCo|

; 887  :     if (m_vpPRCMReg) MmUnmapIoSpace((PVOID)m_vpPRCMReg, sizeof(OMAP2420_PRCM_REGS));

  00074	e59d3008	 ldr         r3, [sp, #8]
  00078	e283308c	 add         r3, r3, #0x8C
  0007c	e5933000	 ldr         r3, [r3]
  00080	e3530000	 cmp         r3, #0
  00084	0a000004	 beq         |$LN1@FreeHostCo|
  00088	e3a01c09	 mov         r1, #9, 24
  0008c	e59d3008	 ldr         r3, [sp, #8]
  00090	e283308c	 add         r3, r3, #0x8C
  00094	e5930000	 ldr         r0, [r3]
  00098	eb000000	 bl          MmUnmapIoSpace
  0009c		 |$LN1@FreeHostCo|

; 888  : 
; 889  :     m_PowerState = D4;

  0009c	e59d3008	 ldr         r3, [sp, #8]
  000a0	e2832010	 add         r2, r3, #0x10
  000a4	e3a03004	 mov         r3, #4
  000a8	e5823000	 str         r3, [r2]

; 890  :     
; 891  :     // cleanup the host context
; 892  :     SDHCDDeleteContext(m_pHCContext);

  000ac	e59d3008	 ldr         r3, [sp, #8]
  000b0	e2833004	 add         r3, r3, #4
  000b4	e5930000	 ldr         r0, [r3]
  000b8	eb000000	 bl          SDHCDDeleteContext

; 893  : }    

  000bc	e89d6000	 ldmia       sp, {sp, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M42185|

			 ENDP  ; |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|, CSDIOControllerBase::FreeHostContext

	EXPORT	|??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T42237| DCD	|$LN24@GetRegistr|
	DCD	0x4000a404

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@| DCB "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, "u", 0x0, "p", 0x0, "S"
	DCB	0x0, "o", 0x0, "u", 0x0, "r", 0x0, "c", 0x0, "e", 0x0, "s"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "R"
	DCB	0x0, "e", 0x0, "a", 0x0, "d", 0x0, "W", 0x0, "r", 0x0, "i"
	DCB	0x0, "t", 0x0, "e", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e"
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@| DCB "B"
	DCB	0x0, "a", 0x0, "s", 0x0, "e", 0x0, "C", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "k", 0x0, "F", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "n", 0x0, "c", 0x0, "y", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "C"
	DCB	0x0, "D", 0x0, "P", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r"
	DCB	0x0, "i", 0x0, "t", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@| DCB "S"
	DCB	0x0, "D", 0x0, "I", 0x0, "O", 0x0, "P", 0x0, "r", 0x0, "i"
	DCB	0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "y", 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odsp
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRegistrySettings@CSDIOControllerBase@@UAAHPAVCReg@@@Z| PROC ; CSDIOControllerBase::GetRegistrySettings

; 1073 : {

  00000		 |$LN24@GetRegistr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd064	 sub         sp, sp, #0x64
  00010		 |$M42234|

; 1074 :     BOOL fRet = TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e58d3008	 str         r3, [sp, #8]

; 1075 : 
; 1076 :     DEBUGCHK(pReg);
; 1077 : 
; 1078 :     // get the controller IST thread priority
; 1079 :     m_dwSDIOPriority = pReg->ValueDW(SHC_SDIO_PRIORITY_KEY, SHC_CARD_CONTROLLER_PRIORITY);

  00018	e3a03097	 mov         r3, #0x97
  0001c	e58d300c	 str         r3, [sp, #0xC]
  00020	e59d3070	 ldr         r3, [sp, #0x70]
  00024	e5933000	 ldr         r3, [r3]
  00028	e3530000	 cmp         r3, #0
  0002c	0a00000b	 beq         |$LN7@GetRegistr|
  00030	e3a03004	 mov         r3, #4
  00034	e58d3010	 str         r3, [sp, #0x10]
  00038	e28d3010	 add         r3, sp, #0x10
  0003c	e58d3004	 str         r3, [sp, #4]
  00040	e28d300c	 add         r3, sp, #0xC
  00044	e58d3000	 str         r3, [sp]
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02000	 mov         r2, #0
  00050	e59f1234	 ldr         r1, [pc, #0x234]
  00054	e59d0070	 ldr         r0, [sp, #0x70]
  00058	e5900000	 ldr         r0, [r0]
  0005c	eb000000	 bl          RegQueryValueExW
  00060		 |$LN7@GetRegistr|
  00060	e59d200c	 ldr         r2, [sp, #0xC]
  00064	e59d306c	 ldr         r3, [sp, #0x6C]
  00068	e2833058	 add         r3, r3, #0x58
  0006c	e5832000	 str         r2, [r3]

; 1080 : 
; 1081 :     // get the card detect IST thread priority
; 1082 :     m_dwCDPriority = pReg->ValueDW(SHC_CD_PRIORITY_KEY, SHC_CARD_DETECT_PRIORITY);

  00070	e3a03098	 mov         r3, #0x98
  00074	e58d3014	 str         r3, [sp, #0x14]
  00078	e59d3070	 ldr         r3, [sp, #0x70]
  0007c	e5933000	 ldr         r3, [r3]
  00080	e3530000	 cmp         r3, #0
  00084	0a00000b	 beq         |$LN10@GetRegistr|
  00088	e3a03004	 mov         r3, #4
  0008c	e58d3018	 str         r3, [sp, #0x18]
  00090	e28d3018	 add         r3, sp, #0x18
  00094	e58d3004	 str         r3, [sp, #4]
  00098	e28d3014	 add         r3, sp, #0x14
  0009c	e58d3000	 str         r3, [sp]
  000a0	e3a03000	 mov         r3, #0
  000a4	e3a02000	 mov         r2, #0
  000a8	e59f11d8	 ldr         r1, [pc, #0x1D8]
  000ac	e59d0070	 ldr         r0, [sp, #0x70]
  000b0	e5900000	 ldr         r0, [r0]
  000b4	eb000000	 bl          RegQueryValueExW
  000b8		 |$LN10@GetRegistr|
  000b8	e59d2014	 ldr         r2, [sp, #0x14]
  000bc	e59d306c	 ldr         r3, [sp, #0x6C]
  000c0	e283305c	 add         r3, r3, #0x5C
  000c4	e5832000	 str         r2, [r3]

; 1083 : 
; 1084 :     // get the max clock frequency from the registry (we allow the registry to override)
; 1085 :     m_dwMaxClockRate = pReg->ValueDW(SHC_FREQUENCY_KEY);

  000c8	e3a03000	 mov         r3, #0
  000cc	e58d301c	 str         r3, [sp, #0x1C]
  000d0	e59d3070	 ldr         r3, [sp, #0x70]
  000d4	e5933000	 ldr         r3, [r3]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a00000b	 beq         |$LN13@GetRegistr|
  000e0	e3a03004	 mov         r3, #4
  000e4	e58d3020	 str         r3, [sp, #0x20]
  000e8	e28d3020	 add         r3, sp, #0x20
  000ec	e58d3004	 str         r3, [sp, #4]
  000f0	e28d301c	 add         r3, sp, #0x1C
  000f4	e58d3000	 str         r3, [sp]
  000f8	e3a03000	 mov         r3, #0
  000fc	e3a02000	 mov         r2, #0
  00100	e59f117c	 ldr         r1, [pc, #0x17C]
  00104	e59d0070	 ldr         r0, [sp, #0x70]
  00108	e5900000	 ldr         r0, [r0]
  0010c	eb000000	 bl          RegQueryValueExW
  00110		 |$LN13@GetRegistr|
  00110	e59d201c	 ldr         r2, [sp, #0x1C]
  00114	e59d306c	 ldr         r3, [sp, #0x6C]
  00118	e2833074	 add         r3, r3, #0x74
  0011c	e5832000	 str         r2, [r3]

; 1086 :     if (m_dwMaxClockRate == 0) 

  00120	e59d306c	 ldr         r3, [sp, #0x6C]
  00124	e2833074	 add         r3, r3, #0x74
  00128	e5933000	 ldr         r3, [r3]
  0012c	e3530000	 cmp         r3, #0
  00130	1a000004	 bne         |$LN2@GetRegistr|

; 1087 :     {
; 1088 :         // No clock frequency specified. Use the highest possible that
; 1089 :         // could have been specified so that a working clock divisor 
; 1090 :         // will be chosen.
; 1091 :         m_dwMaxClockRate = STD_HC_MAX_CLOCK_FREQUENCY;

  00134	e59d306c	 ldr         r3, [sp, #0x6C]
  00138	e2832074	 add         r2, r3, #0x74
  0013c	e59f313c	 ldr         r3, [pc, #0x13C]
  00140	e5823000	 str         r3, [r2]

; 1092 :     }
; 1093 :     else 

  00144	ea000010	 b           |$LN1@GetRegistr|
  00148		 |$LN2@GetRegistr|

; 1094 :     {
; 1095 :         m_dwMaxClockRate = min(m_dwMaxClockRate, 
; 1096 :             STD_HC_MAX_CLOCK_FREQUENCY);

  00148	e59d306c	 ldr         r3, [sp, #0x6C]
  0014c	e2833074	 add         r3, r3, #0x74
  00150	e5932000	 ldr         r2, [r3]
  00154	e59f3124	 ldr         r3, [pc, #0x124]
  00158	e1520003	 cmp         r2, r3
  0015c	2a000004	 bcs         |$LN5@GetRegistr|
  00160	e59d306c	 ldr         r3, [sp, #0x6C]
  00164	e2833074	 add         r3, r3, #0x74
  00168	e5933000	 ldr         r3, [r3]
  0016c	e58d3060	 str         r3, [sp, #0x60]
  00170	ea000001	 b           |$LN6@GetRegistr|
  00174		 |$LN5@GetRegistr|
  00174	e59f3104	 ldr         r3, [pc, #0x104]
  00178	e58d3060	 str         r3, [sp, #0x60]
  0017c		 |$LN6@GetRegistr|
  0017c	e59d306c	 ldr         r3, [sp, #0x6C]
  00180	e2832074	 add         r2, r3, #0x74
  00184	e59d3060	 ldr         r3, [sp, #0x60]
  00188	e5823000	 str         r3, [r2]
  0018c		 |$LN1@GetRegistr|

; 1097 :     }
; 1098 : 
; 1099 :     // get the read/write timeout value
; 1100 :     m_dwMaxTimeout = pReg->ValueDW(SHC_RW_TIMEOUT_KEY, DEFAULT_TIMEOUT_VALUE);

  0018c	e3a03cea	 mov         r3, #0xEA, 24
  00190	e3833060	 orr         r3, r3, #0x60
  00194	e58d3024	 str         r3, [sp, #0x24]
  00198	e59d3070	 ldr         r3, [sp, #0x70]
  0019c	e5933000	 ldr         r3, [r3]
  001a0	e3530000	 cmp         r3, #0
  001a4	0a00000b	 beq         |$LN16@GetRegistr|
  001a8	e3a03004	 mov         r3, #4
  001ac	e58d3028	 str         r3, [sp, #0x28]
  001b0	e28d3028	 add         r3, sp, #0x28
  001b4	e58d3004	 str         r3, [sp, #4]
  001b8	e28d3024	 add         r3, sp, #0x24
  001bc	e58d3000	 str         r3, [sp]
  001c0	e3a03000	 mov         r3, #0
  001c4	e3a02000	 mov         r2, #0
  001c8	e59f10ac	 ldr         r1, [pc, #0xAC]
  001cc	e59d0070	 ldr         r0, [sp, #0x70]
  001d0	e5900000	 ldr         r0, [r0]
  001d4	eb000000	 bl          RegQueryValueExW
  001d8		 |$LN16@GetRegistr|
  001d8	e59d2024	 ldr         r2, [sp, #0x24]
  001dc	e59d306c	 ldr         r3, [sp, #0x6C]
  001e0	e283307c	 add         r3, r3, #0x7C
  001e4	e5832000	 str         r2, [r3]

; 1101 : 
; 1102 :     // get the wakeup sources
; 1103 :     m_dwWakeupSources = pReg->ValueDW(SHC_WAKEUP_SOURCES_KEY, 0);

  001e8	e3a03000	 mov         r3, #0
  001ec	e58d302c	 str         r3, [sp, #0x2C]
  001f0	e59d3070	 ldr         r3, [sp, #0x70]
  001f4	e5933000	 ldr         r3, [r3]
  001f8	e3530000	 cmp         r3, #0
  001fc	0a00000b	 beq         |$LN19@GetRegistr|
  00200	e3a03004	 mov         r3, #4
  00204	e58d3030	 str         r3, [sp, #0x30]
  00208	e28d3030	 add         r3, sp, #0x30
  0020c	e58d3004	 str         r3, [sp, #4]
  00210	e28d302c	 add         r3, sp, #0x2C
  00214	e58d3000	 str         r3, [sp]
  00218	e3a03000	 mov         r3, #0
  0021c	e3a02000	 mov         r2, #0
  00220	e59f1050	 ldr         r1, [pc, #0x50]
  00224	e59d0070	 ldr         r0, [sp, #0x70]
  00228	e5900000	 ldr         r0, [r0]
  0022c	eb000000	 bl          RegQueryValueExW
  00230		 |$LN19@GetRegistr|
  00230	e59d202c	 ldr         r2, [sp, #0x2C]
  00234	e59d306c	 ldr         r3, [sp, #0x6C]
  00238	e2833030	 add         r3, r3, #0x30
  0023c	e5832000	 str         r2, [r3]

; 1104 :     m_dwCurrentWakeupSources = m_dwWakeupSources & (~WAKEUP_SDIO);

  00240	e59d306c	 ldr         r3, [sp, #0x6C]
  00244	e2833030	 add         r3, r3, #0x30
  00248	e5932000	 ldr         r2, [r3]
  0024c	e3e03001	 mvn         r3, #1
  00250	e0022003	 and         r2, r2, r3
  00254	e59d306c	 ldr         r3, [sp, #0x6C]
  00258	e2833034	 add         r3, r3, #0x34
  0025c	e5832000	 str         r2, [r3]

; 1105 : 
; 1106 :     return fRet;

  00260	e59d3008	 ldr         r3, [sp, #8]
  00264	e58d305c	 str         r3, [sp, #0x5C]

; 1107 : }

  00268	e59d005c	 ldr         r0, [sp, #0x5C]
  0026c	e28dd064	 add         sp, sp, #0x64
  00270	e89d6000	 ldmia       sp, {sp, lr}
  00274	e12fff1e	 bx          lr
  00278		 |$LN25@GetRegistr|
  00278		 |$LN26@GetRegistr|
  00278	00000000	 DCD         |??_C@_1BM@NNIPIGOJ@?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AAs?$AA?$AA@|
  0027c		 |$LN27@GetRegistr|
  0027c	00000000	 DCD         |??_C@_1CC@LMBBBPNF@?$AAR?$AAe?$AAa?$AAd?$AAW?$AAr?$AAi?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
  00280		 |$LN28@GetRegistr|
  00280	016e3600	 DCD         0x16e3600
  00284		 |$LN29@GetRegistr|
  00284	00000000	 DCD         |??_C@_1CG@OOJEOPHC@?$AAB?$AAa?$AAs?$AAe?$AAC?$AAl?$AAo?$AAc?$AAk?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?$AA@|
  00288		 |$LN30@GetRegistr|
  00288	00000000	 DCD         |??_C@_1BG@NAMMPMDB@?$AAC?$AAD?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
  0028c		 |$LN31@GetRegistr|
  0028c	00000000	 DCD         |??_C@_1BK@KBGNDCFC@?$AAS?$AAD?$AAI?$AAO?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?$AA@|
  00290		 |$M42235|

			 ENDP  ; |?GetRegistrySettings@CSDIOControllerBase@@UAAHPAVCReg@@@Z|, CSDIOControllerBase::GetRegistrySettings

	EXPORT	|?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z| ; CSDIOControllerBase::SDHCCardDetectIstThread

  00000			 AREA	 |.pdata|, PDATA
|$T42252| DCD	|$LN5@SDHCCardDe|
	DCD	0x40001404
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z| PROC ; CSDIOControllerBase::SDHCCardDetectIstThread

; 1225 : {

  00000		 |$LN5@SDHCCardDe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42249|

; 1226 :     CSDIOControllerBase *pController = (CSDIOControllerBase*)lpParameter;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e58d3000	 str         r3, [sp]

; 1227 :     return pController->SDHCCardDetectIstThreadImpl();

  00018	e59d3000	 ldr         r3, [sp]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e2833018	 add         r3, r3, #0x18
  00024	e59d0000	 ldr         r0, [sp]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3
  00034	e58d0008	 str         r0, [sp, #8]
  00038	e59d3008	 ldr         r3, [sp, #8]
  0003c	e58d3004	 str         r3, [sp, #4]

; 1228 : }

  00040	e59d0004	 ldr         r0, [sp, #4]
  00044	e28dd00c	 add         sp, sp, #0xC
  00048	e89d6000	 ldmia       sp, {sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M42250|

			 ENDP  ; |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z|, CSDIOControllerBase::SDHCCardDetectIstThread

	EXPORT	|?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ| ; CSDIOControllerBase::SDHCDeinitializeImpl
	IMPORT	|WaitForSingleObject|
	IMPORT	|InterruptDisable|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\twl.h

  00000			 AREA	 |.pdata|, PDATA
|$T42297| DCD	|$LN28@SDHCDeinit|
	DCD	0x4000dc04
; Function compile flags: /Odsp
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ| PROC ; CSDIOControllerBase::SDHCDeinitializeImpl

; 1240 : {

  00000		 |$LN28@SDHCDeinit|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd04c	 sub         sp, sp, #0x4C
  00010		 |$M42294|

; 1241 :     // mark for shutdown
; 1242 :     m_fDriverShutdown = TRUE;

  00010	e59d3054	 ldr         r3, [sp, #0x54]
  00014	e2832060	 add         r2, r3, #0x60
  00018	e3a03001	 mov         r3, #1
  0001c	e5823000	 str         r3, [r2]

; 1243 : 
; 1244 :     if (m_fInitialized) {

  00020	e59d3054	 ldr         r3, [sp, #0x54]
  00024	e2833070	 add         r3, r3, #0x70
  00028	e5933000	 ldr         r3, [r3]
  0002c	e3530000	 cmp         r3, #0
  00030	0a00002d	 beq         |$LN9@SDHCDeinit|

; 1245 :         if( m_dwControllerSysIntr != SYSINTR_UNDEFINED )

  00034	e59d3054	 ldr         r3, [sp, #0x54]
  00038	e283306c	 add         r3, r3, #0x6C
  0003c	e5933000	 ldr         r3, [r3]
  00040	e3730001	 cmn         r3, #1
  00044	0a000020	 beq         |$LN8@SDHCDeinit|

; 1246 :         {
; 1247 :             // disable wakeup on SDIO interrupt
; 1248 :             if ( m_dwCurrentWakeupSources & WAKEUP_SDIO )

  00048	e59d3054	 ldr         r3, [sp, #0x54]
  0004c	e2833034	 add         r3, r3, #0x34
  00050	e5933000	 ldr         r3, [r3]
  00054	e3130001	 tst         r3, #1
  00058	0a000009	 beq         |$LN7@SDHCDeinit|

; 1249 :             {
; 1250 :                 KernelIoControl( IOCTL_HAL_DISABLE_WAKE,
; 1251 :                     &m_dwControllerSysIntr,
; 1252 :                     sizeof( m_dwControllerSysIntr ),
; 1253 :                     NULL,
; 1254 :                     0,
; 1255 :                     NULL );

  0005c	e3a03000	 mov         r3, #0
  00060	e58d3004	 str         r3, [sp, #4]
  00064	e3a03000	 mov         r3, #0
  00068	e58d3000	 str         r3, [sp]
  0006c	e3a03000	 mov         r3, #0
  00070	e3a02004	 mov         r2, #4
  00074	e59d1054	 ldr         r1, [sp, #0x54]
  00078	e281106c	 add         r1, r1, #0x6C
  0007c	e59f02e8	 ldr         r0, [pc, #0x2E8]
  00080	eb000000	 bl          KernelIoControl
  00084		 |$LN7@SDHCDeinit|

; 1256 :             }
; 1257 : 
; 1258 :             // disable controller interrupt
; 1259 :             InterruptDisable(m_dwControllerSysIntr);

  00084	e59d3054	 ldr         r3, [sp, #0x54]
  00088	e283306c	 add         r3, r3, #0x6C
  0008c	e5930000	 ldr         r0, [r3]
  00090	eb000000	 bl          InterruptDisable

; 1260 : 
; 1261 :             // release the SYSINTR value
; 1262 :             KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &m_dwControllerSysIntr, sizeof(DWORD), NULL, 0, NULL);

  00094	e3a03000	 mov         r3, #0
  00098	e58d3004	 str         r3, [sp, #4]
  0009c	e3a03000	 mov         r3, #0
  000a0	e58d3000	 str         r3, [sp]
  000a4	e3a03000	 mov         r3, #0
  000a8	e3a02004	 mov         r2, #4
  000ac	e59d1054	 ldr         r1, [sp, #0x54]
  000b0	e281106c	 add         r1, r1, #0x6C
  000b4	e59f02ac	 ldr         r0, [pc, #0x2AC]
  000b8	eb000000	 bl          KernelIoControl

; 1263 :             m_dwControllerSysIntr = SYSINTR_UNDEFINED;

  000bc	e59d3054	 ldr         r3, [sp, #0x54]
  000c0	e283206c	 add         r2, r3, #0x6C
  000c4	e3e03000	 mvn         r3, #0
  000c8	e5823000	 str         r3, [r2]
  000cc		 |$LN8@SDHCDeinit|

; 1264 :         }
; 1265 : 
; 1266 :         if (m_fCardPresent) {

  000cc	e59d3054	 ldr         r3, [sp, #0x54]
  000d0	e2833038	 add         r3, r3, #0x38
  000d4	e5933000	 ldr         r3, [r3]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a000002	 beq         |$LN6@SDHCDeinit|

; 1267 :             // remove device
; 1268 :             HandleRemoval(FALSE);

  000e0	e3a01000	 mov         r1, #0
  000e4	e59d0054	 ldr         r0, [sp, #0x54]
  000e8	eb000000	 bl          |?HandleRemoval@CSDIOControllerBase@@QAAXH@Z|
  000ec		 |$LN6@SDHCDeinit|
  000ec		 |$LN9@SDHCDeinit|

; 1269 :         }
; 1270 : 
; 1271 :     }
; 1272 : 
; 1273 :     // clean up controller IST
; 1274 :     if (NULL != m_htControllerIST) {

  000ec	e59d3054	 ldr         r3, [sp, #0x54]
  000f0	e283304c	 add         r3, r3, #0x4C
  000f4	e5933000	 ldr         r3, [r3]
  000f8	e3530000	 cmp         r3, #0
  000fc	0a000013	 beq         |$LN5@SDHCDeinit|

; 1275 :         // wake up the IST
; 1276 :         SetEvent(m_hControllerISTEvent);

  00100	e59d3054	 ldr         r3, [sp, #0x54]
  00104	e2833048	 add         r3, r3, #0x48
  00108	e5933000	 ldr         r3, [r3]
  0010c	e58d3008	 str         r3, [sp, #8]
  00110	e3a01003	 mov         r1, #3
  00114	e59d0008	 ldr         r0, [sp, #8]
  00118	eb000000	 bl          EventModify

; 1277 :         // wait for the thread to exit
; 1278 :         WaitForSingleObject(m_htControllerIST, INFINITE); 

  0011c	e3e01000	 mvn         r1, #0
  00120	e59d3054	 ldr         r3, [sp, #0x54]
  00124	e283304c	 add         r3, r3, #0x4C
  00128	e5930000	 ldr         r0, [r3]
  0012c	eb000000	 bl          WaitForSingleObject

; 1279 :         CloseHandle(m_htControllerIST);

  00130	e59d3054	 ldr         r3, [sp, #0x54]
  00134	e283304c	 add         r3, r3, #0x4C
  00138	e5930000	 ldr         r0, [r3]
  0013c	eb000000	 bl          CloseHandle

; 1280 :         m_htControllerIST = NULL;

  00140	e59d3054	 ldr         r3, [sp, #0x54]
  00144	e283204c	 add         r2, r3, #0x4C
  00148	e3a03000	 mov         r3, #0
  0014c	e5823000	 str         r3, [r2]
  00150		 |$LN5@SDHCDeinit|

; 1281 :     }
; 1282 : 
; 1283 :     // free controller interrupt event
; 1284 :     if (NULL != m_hControllerISTEvent) {

  00150	e59d3054	 ldr         r3, [sp, #0x54]
  00154	e2833048	 add         r3, r3, #0x48
  00158	e5933000	 ldr         r3, [r3]
  0015c	e3530000	 cmp         r3, #0
  00160	0a000007	 beq         |$LN4@SDHCDeinit|

; 1285 :         CloseHandle(m_hControllerISTEvent);

  00164	e59d3054	 ldr         r3, [sp, #0x54]
  00168	e2833048	 add         r3, r3, #0x48
  0016c	e5930000	 ldr         r0, [r3]
  00170	eb000000	 bl          CloseHandle

; 1286 :         m_hControllerISTEvent = NULL;

  00174	e59d3054	 ldr         r3, [sp, #0x54]
  00178	e2832048	 add         r2, r3, #0x48
  0017c	e3a03000	 mov         r3, #0
  00180	e5823000	 str         r3, [r2]
  00184		 |$LN4@SDHCDeinit|

; 1287 :     }
; 1288 : 
; 1289 :     // clean up card detect IST
; 1290 :     if (NULL != m_htCardDetectIST) {

  00184	e59d3054	 ldr         r3, [sp, #0x54]
  00188	e2833054	 add         r3, r3, #0x54
  0018c	e5933000	 ldr         r3, [r3]
  00190	e3530000	 cmp         r3, #0
  00194	0a000013	 beq         |$LN3@SDHCDeinit|

; 1291 :         // wake up the IST
; 1292 :         SetEvent(m_hCardDetectEvent);

  00198	e59d3054	 ldr         r3, [sp, #0x54]
  0019c	e2833050	 add         r3, r3, #0x50
  001a0	e5933000	 ldr         r3, [r3]
  001a4	e58d300c	 str         r3, [sp, #0xC]
  001a8	e3a01003	 mov         r1, #3
  001ac	e59d000c	 ldr         r0, [sp, #0xC]
  001b0	eb000000	 bl          EventModify

; 1293 :         // wait for the thread to exit
; 1294 :         WaitForSingleObject(m_htCardDetectIST, INFINITE); 

  001b4	e3e01000	 mvn         r1, #0
  001b8	e59d3054	 ldr         r3, [sp, #0x54]
  001bc	e2833054	 add         r3, r3, #0x54
  001c0	e5930000	 ldr         r0, [r3]
  001c4	eb000000	 bl          WaitForSingleObject

; 1295 :         CloseHandle(m_htCardDetectIST);

  001c8	e59d3054	 ldr         r3, [sp, #0x54]
  001cc	e2833054	 add         r3, r3, #0x54
  001d0	e5930000	 ldr         r0, [r3]
  001d4	eb000000	 bl          CloseHandle

; 1296 :         m_htCardDetectIST = NULL;

  001d8	e59d3054	 ldr         r3, [sp, #0x54]
  001dc	e2832054	 add         r2, r3, #0x54
  001e0	e3a03000	 mov         r3, #0
  001e4	e5823000	 str         r3, [r2]
  001e8		 |$LN3@SDHCDeinit|

; 1297 :     }
; 1298 : 
; 1299 :     if( m_hParentBus != NULL )

  001e8	e59d3054	 ldr         r3, [sp, #0x54]
  001ec	e2833008	 add         r3, r3, #8
  001f0	e5933000	 ldr         r3, [r3]
  001f4	e3530000	 cmp         r3, #0
  001f8	0a000047	 beq         |$LN2@SDHCDeinit|

; 1300 :     {
; 1301 :         TWLIntrDisable(m_hParentBus, TWL_INTR_CD1);

  001fc	e59d3054	 ldr         r3, [sp, #0x54]
  00200	e2833008	 add         r3, r3, #8
  00204	e5933000	 ldr         r3, [r3]
  00208	e58d3014	 str         r3, [sp, #0x14]
  0020c	e59d3014	 ldr         r3, [sp, #0x14]
  00210	e58d3010	 str         r3, [sp, #0x10]
  00214	e3a01000	 mov         r1, #0
  00218	e59d3010	 ldr         r3, [sp, #0x10]
  0021c	e5930000	 ldr         r0, [r3]
  00220	e59d3010	 ldr         r3, [sp, #0x10]
  00224	e2833014	 add         r3, r3, #0x14
  00228	e5933000	 ldr         r3, [r3]
  0022c	e1a0e00f	 mov         lr, pc
  00230	e12fff13	 bx          r3

; 1302 :         TWLIntrDisable(m_hParentBus, TWL_INTR_DL1);

  00234	e59d3054	 ldr         r3, [sp, #0x54]
  00238	e2833008	 add         r3, r3, #8
  0023c	e5933000	 ldr         r3, [r3]
  00240	e58d301c	 str         r3, [sp, #0x1C]
  00244	e59d301c	 ldr         r3, [sp, #0x1C]
  00248	e58d3018	 str         r3, [sp, #0x18]
  0024c	e3a01002	 mov         r1, #2
  00250	e59d3018	 ldr         r3, [sp, #0x18]
  00254	e5930000	 ldr         r0, [r3]
  00258	e59d3018	 ldr         r3, [sp, #0x18]
  0025c	e2833014	 add         r3, r3, #0x14
  00260	e5933000	 ldr         r3, [r3]
  00264	e1a0e00f	 mov         lr, pc
  00268	e12fff13	 bx          r3

; 1303 :         TWLIntrDisable(m_hParentBus, TWL_INTR_CD2);

  0026c	e59d3054	 ldr         r3, [sp, #0x54]
  00270	e2833008	 add         r3, r3, #8
  00274	e5933000	 ldr         r3, [r3]
  00278	e58d3024	 str         r3, [sp, #0x24]
  0027c	e59d3024	 ldr         r3, [sp, #0x24]
  00280	e58d3020	 str         r3, [sp, #0x20]
  00284	e3a01001	 mov         r1, #1
  00288	e59d3020	 ldr         r3, [sp, #0x20]
  0028c	e5930000	 ldr         r0, [r3]
  00290	e59d3020	 ldr         r3, [sp, #0x20]
  00294	e2833014	 add         r3, r3, #0x14
  00298	e5933000	 ldr         r3, [r3]
  0029c	e1a0e00f	 mov         lr, pc
  002a0	e12fff13	 bx          r3

; 1304 :         TWLIntrDisable(m_hParentBus, TWL_INTR_DL2);

  002a4	e59d3054	 ldr         r3, [sp, #0x54]
  002a8	e2833008	 add         r3, r3, #8
  002ac	e5933000	 ldr         r3, [r3]
  002b0	e58d302c	 str         r3, [sp, #0x2C]
  002b4	e59d302c	 ldr         r3, [sp, #0x2C]
  002b8	e58d3028	 str         r3, [sp, #0x28]
  002bc	e3a01003	 mov         r1, #3
  002c0	e59d3028	 ldr         r3, [sp, #0x28]
  002c4	e5930000	 ldr         r0, [r3]
  002c8	e59d3028	 ldr         r3, [sp, #0x28]
  002cc	e2833014	 add         r3, r3, #0x14
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e1a0e00f	 mov         lr, pc
  002d8	e12fff13	 bx          r3

; 1305 : 
; 1306 :         TWLClose(m_hParentBus);

  002dc	e59d3054	 ldr         r3, [sp, #0x54]
  002e0	e2833008	 add         r3, r3, #8
  002e4	e5933000	 ldr         r3, [r3]
  002e8	e58d3034	 str         r3, [sp, #0x34]
  002ec	e59d3034	 ldr         r3, [sp, #0x34]
  002f0	e58d3030	 str         r3, [sp, #0x30]
  002f4	e59d3030	 ldr         r3, [sp, #0x30]
  002f8	e283301c	 add         r3, r3, #0x1C
  002fc	e5930000	 ldr         r0, [r3]
  00300	eb000000	 bl          CloseHandle
  00304	e59d0030	 ldr         r0, [sp, #0x30]
  00308	eb000000	 bl          LocalFree

; 1307 :         m_hParentBus = NULL;

  0030c	e59d3054	 ldr         r3, [sp, #0x54]
  00310	e2832008	 add         r2, r3, #8
  00314	e3a03000	 mov         r3, #0
  00318	e5823000	 str         r3, [r2]
  0031c		 |$LN2@SDHCDeinit|

; 1308 :     }
; 1309 : 
; 1310 :     // free card detect interrupt event
; 1311 :     if (NULL != m_hCardDetectEvent) {

  0031c	e59d3054	 ldr         r3, [sp, #0x54]
  00320	e2833050	 add         r3, r3, #0x50
  00324	e5933000	 ldr         r3, [r3]
  00328	e3530000	 cmp         r3, #0
  0032c	0a000007	 beq         |$LN1@SDHCDeinit|

; 1312 :         CloseHandle(m_hCardDetectEvent);

  00330	e59d3054	 ldr         r3, [sp, #0x54]
  00334	e2833050	 add         r3, r3, #0x50
  00338	e5930000	 ldr         r0, [r3]
  0033c	eb000000	 bl          CloseHandle

; 1313 :         m_hCardDetectEvent = NULL;

  00340	e59d3054	 ldr         r3, [sp, #0x54]
  00344	e2832050	 add         r2, r3, #0x50
  00348	e3a03000	 mov         r3, #0
  0034c	e5823000	 str         r3, [r2]
  00350		 |$LN1@SDHCDeinit|

; 1314 :     }
; 1315 : 
; 1316 :     return SD_API_STATUS_SUCCESS;

  00350	e3a03000	 mov         r3, #0
  00354	e58d3048	 str         r3, [sp, #0x48]

; 1317 : }

  00358	e59d0048	 ldr         r0, [sp, #0x48]
  0035c	e28dd04c	 add         sp, sp, #0x4C
  00360	e89d6000	 ldmia       sp, {sp, lr}
  00364	e12fff1e	 bx          lr
  00368		 |$LN29@SDHCDeinit|
  00368		 |$LN30@SDHCDeinit|
  00368	010100d8	 DCD         0x10100d8
  0036c		 |$LN31@SDHCDeinit|
  0036c	010100a4	 DCD         0x10100a4
  00370		 |$M42295|

			 ENDP  ; |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|, CSDIOControllerBase::SDHCDeinitializeImpl

	EXPORT	|?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCCancelIoHandlerImpl

  00000			 AREA	 |.pdata|, PDATA
|$T42308| DCD	|$LN5@SDHCCancel|
	DCD	0x40000a04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCCancelIoHandlerImpl

; 1515 : {

  00000		 |$LN5@SDHCCancel|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M42305|

; 1516 :     // for now, we should never get here because all requests are non-cancelable
; 1517 :     // the hardware supports timeouts so it is impossible for the controller to get stuck
; 1518 :     DEBUGCHK(FALSE);
; 1519 : 
; 1520 :     return TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e5cd3000	 strb        r3, [sp]

; 1521 : }

  00018	e5dd0000	 ldrb        r0, [sp]
  0001c	e28dd004	 add         sp, sp, #4
  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M42306|

			 ENDP  ; |?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCCancelIoHandlerImpl

	IMPORT	|SDHCDIndicateBusRequestComplete|

  00000			 AREA	 |.pdata|, PDATA
|$T42315| DCD	|$LN9@IndicateBu|
	DCD	0x40002603
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IndicateBusRequestComplete@CSDIOControllerBase@@UAAXPAU_SD_BUS_REQUEST@@J@Z| PROC ; CSDIOControllerBase::IndicateBusRequestComplete

; 1913 : {

  00000		 |$LN9@IndicateBu|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M42312|

; 1914 :     if ( m_pCurrentRequest == pRequest ) {

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e2833090	 add         r3, r3, #0x90
  00014	e5932000	 ldr         r2, [r3]
  00018	e59d300c	 ldr         r3, [sp, #0xC]
  0001c	e1520003	 cmp         r2, r3
  00020	1a000011	 bne         |$LN4@IndicateBu|

; 1915 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,
; 1916 :             (L"CSDIOControllerBase::IndicateBusRequestComplete: "
; 1917 :             L"pRequest = %x, Status = %d\r\n", pRequest,Status)); 
; 1918 :         m_pCurrentRequest = NULL;

  00024	e59d3008	 ldr         r3, [sp, #8]
  00028	e2832090	 add         r2, r3, #0x90
  0002c	e3a03000	 mov         r3, #0
  00030	e5823000	 str         r3, [r2]

; 1919 :         if (m_fCurrentRequestFastPath ) {

  00034	e59d3008	 ldr         r3, [sp, #8]
  00038	e2833094	 add         r3, r3, #0x94
  0003c	e5933000	 ldr         r3, [r3]
  00040	e3530000	 cmp         r3, #0
  00044	0a000008	 beq         |$LN3@IndicateBu|

; 1920 :             if (Status == SD_API_STATUS_SUCCESS) {

  00048	e59d3010	 ldr         r3, [sp, #0x10]
  0004c	e3530000	 cmp         r3, #0
  00050	1a000001	 bne         |$LN2@IndicateBu|

; 1921 :                 Status = SD_API_STATUS_FAST_PATH_SUCCESS;

  00054	e3a03002	 mov         r3, #2
  00058	e58d3010	 str         r3, [sp, #0x10]
  0005c		 |$LN2@IndicateBu|

; 1922 :             }
; 1923 :             FastPathStatus = Status ;

  0005c	e59d3008	 ldr         r3, [sp, #8]
  00060	e2832098	 add         r2, r3, #0x98
  00064	e59d3010	 ldr         r3, [sp, #0x10]
  00068	e5823000	 str         r3, [r2]
  0006c		 |$LN3@IndicateBu|
  0006c		 |$LN4@IndicateBu|

; 1924 :         }
; 1925 :     }
; 1926 : 
; 1927 :     if ( Status != SD_API_STATUS_FAST_PATH_SUCCESS ) {

  0006c	e59d3010	 ldr         r3, [sp, #0x10]
  00070	e3530002	 cmp         r3, #2
  00074	0a000005	 beq         |$LN1@IndicateBu|

; 1928 :         SDHCDIndicateBusRequestComplete(m_pHCContext, pRequest, Status);

  00078	e59d2010	 ldr         r2, [sp, #0x10]
  0007c	e59d100c	 ldr         r1, [sp, #0xC]
  00080	e59d3008	 ldr         r3, [sp, #8]
  00084	e2833004	 add         r3, r3, #4
  00088	e5930000	 ldr         r0, [r3]
  0008c	eb000000	 bl          SDHCDIndicateBusRequestComplete
  00090		 |$LN1@IndicateBu|

; 1929 :     }
; 1930 : }

  00090	e89d6000	 ldmia       sp, {sp, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M42313|

			 ENDP  ; |?IndicateBusRequestComplete@CSDIOControllerBase@@UAAXPAU_SD_BUS_REQUEST@@J@Z|, CSDIOControllerBase::IndicateBusRequestComplete

	EXPORT	|?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCCancelIoHandler

  00000			 AREA	 |.pdata|, PDATA
|$T42323| DCD	|$LN5@SDHCCancel@2|
	DCD	0x40001404
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCCancelIoHandler

; 2104 : {

  00000		 |$LN5@SDHCCancel@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42320|

; 2105 :     // get our extension 
; 2106 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e283304c	 add         r3, r3, #0x4C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3000	 str         r3, [sp]

; 2107 :     return pController->SDHCCancelIoHandlerImpl((UCHAR)Slot, pRequest);

  00020	e59d201c	 ldr         r2, [sp, #0x1C]
  00024	e59d3018	 ldr         r3, [sp, #0x18]
  00028	e20310ff	 and         r1, r3, #0xFF
  0002c	e59d0000	 ldr         r0, [sp]
  00030	eb000000	 bl          |?SDHCCancelIoHandlerImpl@CSDIOControllerBase@@QAAEEPAU_SD_BUS_REQUEST@@@Z|
  00034	e5cd0008	 strb        r0, [sp, #8]
  00038	e5dd3008	 ldrb        r3, [sp, #8]
  0003c	e5cd3004	 strb        r3, [sp, #4]

; 2108 : }

  00040	e5dd0004	 ldrb        r0, [sp, #4]
  00044	e28dd00c	 add         sp, sp, #0xC
  00048	e89d6000	 ldmia       sp, {sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M42321|

			 ENDP  ; |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCCancelIoHandler

	EXPORT	|?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| ; CSDIOControllerBase::SDHCDeinitialize

  00000			 AREA	 |.pdata|, PDATA
|$T42331| DCD	|$LN5@SDHCDeinit@2|
	DCD	0x40001104
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| PROC ; CSDIOControllerBase::SDHCDeinitialize

; 2137 : {

  00000		 |$LN5@SDHCDeinit@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42328|

; 2138 :     // get our extension 
; 2139 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e283304c	 add         r3, r3, #0x4C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3000	 str         r3, [sp]

; 2140 :     return pController->SDHCDeinitializeImpl();

  00020	e59d0000	 ldr         r0, [sp]
  00024	eb000000	 bl          |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|
  00028	e58d0008	 str         r0, [sp, #8]
  0002c	e59d3008	 ldr         r3, [sp, #8]
  00030	e58d3004	 str         r3, [sp, #4]

; 2141 : }

  00034	e59d0004	 ldr         r0, [sp, #4]
  00038	e28dd00c	 add         sp, sp, #0xC
  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42329|

			 ENDP  ; |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|, CSDIOControllerBase::SDHCDeinitialize

	EXPORT	|?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::GetCommandResponse

  00000			 AREA	 |.pdata|, PDATA
|$T42340| DCD	|$LN16@GetCommand|
	DCD	0x40013f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::GetCommandResponse

; 2158 : {

  00000		 |$LN16@GetCommand|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd018	 sub         sp, sp, #0x18
  00010		 |$M42337|

; 2159 :     UINT16  dtmp;
; 2160 :     PUCHAR              respBuff;       // response buffer
; 2161 :     WORD wRSP;
; 2162 : 
; 2163 :     dtmp = Read_MMC_STAT();

  00010	e59d0020	 ldr         r0, [sp, #0x20]
  00014	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00018	e1cd01b0	 strh        r0, [sp, #0x10]
  0001c	e1dd31b0	 ldrh        r3, [sp, #0x10]
  00020	e1cd30b4	 strh        r3, [sp, #4]

; 2164 : 
; 2165 :     DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2166 :         L"MMC_STAT = 0x%04X.\r\n", dtmp
; 2167 :     ));
; 2168 : 
; 2169 : 
; 2170 :     if ( dtmp & MMC_STAT_EOC | dtmp & MMC_STAT_CERR | dtmp & MMC_STAT_CCRC) 

  00024	e1dd30b4	 ldrh        r3, [sp, #4]
  00028	e2032001	 and         r2, r3, #1
  0002c	e1dd30b4	 ldrh        r3, [sp, #4]
  00030	e2033901	 and         r3, r3, #1, 18
  00034	e1822003	 orr         r2, r2, r3
  00038	e1dd30b4	 ldrh        r3, [sp, #4]
  0003c	e2033c01	 and         r3, r3, #1, 24
  00040	e1923003	 orrs        r3, r2, r3
  00044	0a000126	 beq         |$LN9@GetCommand|

; 2171 :     {
; 2172 :         respBuff = pRequest->CommandResponse.ResponseBuffer;

  00048	e59d3024	 ldr         r3, [sp, #0x24]
  0004c	e2833020	 add         r3, r3, #0x20
  00050	e58d3000	 str         r3, [sp]

; 2173 : 
; 2174 :         switch(pRequest->CommandResponse.ResponseType)

  00054	e59d3024	 ldr         r3, [sp, #0x24]
  00058	e283301c	 add         r3, r3, #0x1C
  0005c	e5933000	 ldr         r3, [r3]
  00060	e58d3014	 str         r3, [sp, #0x14]
  00064	e59d3014	 ldr         r3, [sp, #0x14]
  00068	e3530000	 cmp         r3, #0
  0006c	da00011c	 ble         |$LN1@GetCommand|
  00070	e59d3014	 ldr         r3, [sp, #0x14]
  00074	e3530002	 cmp         r3, #2
  00078	da000010	 ble         |$LN5@GetCommand|
  0007c	e59d3014	 ldr         r3, [sp, #0x14]
  00080	e3530003	 cmp         r3, #3
  00084	0a00008f	 beq         |$LN2@GetCommand|
  00088	e59d3014	 ldr         r3, [sp, #0x14]
  0008c	e3530003	 cmp         r3, #3
  00090	da000113	 ble         |$LN1@GetCommand|
  00094	e59d3014	 ldr         r3, [sp, #0x14]
  00098	e3530005	 cmp         r3, #5
  0009c	da000033	 ble         |$LN4@GetCommand|
  000a0	e59d3014	 ldr         r3, [sp, #0x14]
  000a4	e3530005	 cmp         r3, #5
  000a8	da00010d	 ble         |$LN1@GetCommand|
  000ac	e59d3014	 ldr         r3, [sp, #0x14]
  000b0	e3530007	 cmp         r3, #7
  000b4	da000057	 ble         |$LN3@GetCommand|
  000b8	ea000109	 b           |$LN1@GetCommand|

; 2175 :         {
; 2176 :         case NoResponse:
; 2177 :             break;

  000bc	ea000108	 b           |$LN7@GetCommand|
  000c0		 |$LN5@GetCommand|

; 2178 : 
; 2179 :         case ResponseR1:                
; 2180 :         case ResponseR1b:
; 2181 :             //--- SHORT RESPONSE (48 bits total)--- 
; 2182 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | COMMAND_INDEX(6) | CARD_STATUS(32) | CRC7(7) | END_BIT(1) }
; 2183 :             // NOTE: START_BIT and TRANSMISSION_BIT = 0, END_BIT = 1
; 2184 :             //
; 2185 :             // Dummy byte needed by calling function.
; 2186 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | pRequest->CommandCode);

  000c0	e59d3024	 ldr         r3, [sp, #0x24]
  000c4	e2833014	 add         r3, r3, #0x14
  000c8	e5d32000	 ldrb        r2, [r3]
  000cc	e59d3000	 ldr         r3, [sp]
  000d0	e5c32000	 strb        r2, [r3]

; 2187 : 
; 2188 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP6);

  000d4	e59d3020	 ldr         r3, [sp, #0x20]
  000d8	e2833088	 add         r3, r3, #0x88
  000dc	e5933000	 ldr         r3, [r3]
  000e0	e2833058	 add         r3, r3, #0x58
  000e4	e1d330b0	 ldrh        r3, [r3]
  000e8	e1cd30b6	 strh        r3, [sp, #6]

; 2189 :             *(respBuff + 1) = (BYTE)wRSP;

  000ec	e1dd30b6	 ldrh        r3, [sp, #6]
  000f0	e20320ff	 and         r2, r3, #0xFF
  000f4	e59d3000	 ldr         r3, [sp]
  000f8	e2833001	 add         r3, r3, #1
  000fc	e5c32000	 strb        r2, [r3]

; 2190 :             *(respBuff + 2) = (BYTE)(wRSP >> 8);

  00100	e1dd30b6	 ldrh        r3, [sp, #6]
  00104	e1a03443	 mov         r3, r3, asr #8
  00108	e20320ff	 and         r2, r3, #0xFF
  0010c	e59d3000	 ldr         r3, [sp]
  00110	e2833002	 add         r3, r3, #2
  00114	e5c32000	 strb        r2, [r3]

; 2191 : 
; 2192 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP7);

  00118	e59d3020	 ldr         r3, [sp, #0x20]
  0011c	e2833088	 add         r3, r3, #0x88
  00120	e5933000	 ldr         r3, [r3]
  00124	e283305c	 add         r3, r3, #0x5C
  00128	e1d330b0	 ldrh        r3, [r3]
  0012c	e1cd30b6	 strh        r3, [sp, #6]

; 2193 :             *(respBuff + 3) = (BYTE)wRSP;

  00130	e1dd30b6	 ldrh        r3, [sp, #6]
  00134	e20320ff	 and         r2, r3, #0xFF
  00138	e59d3000	 ldr         r3, [sp]
  0013c	e2833003	 add         r3, r3, #3
  00140	e5c32000	 strb        r2, [r3]

; 2194 :             *(respBuff + 4) = (BYTE)(wRSP >> 8);

  00144	e1dd30b6	 ldrh        r3, [sp, #6]
  00148	e1a03443	 mov         r3, r3, asr #8
  0014c	e20320ff	 and         r2, r3, #0xFF
  00150	e59d3000	 ldr         r3, [sp]
  00154	e2833004	 add         r3, r3, #4
  00158	e5c32000	 strb        r2, [r3]

; 2195 : 
; 2196 : 
; 2197 :             *(respBuff + 5) = (BYTE)(END_RESERVED | END_BIT);

  0015c	e59d3000	 ldr         r3, [sp]
  00160	e2832005	 add         r2, r3, #5
  00164	e3a030ff	 mov         r3, #0xFF
  00168	e5c23000	 strb        r3, [r2]

; 2198 : 
; 2199 :             DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2200 :                 L"R1 R1b : 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n", *(respBuff + 0), 
; 2201 :                 *(respBuff + 1), *(respBuff + 2), *(respBuff + 3), *(respBuff + 4), *(respBuff + 5)
; 2202 :             ));
; 2203 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(L"CSDIOControllerBase::GetCommandResponse: "
; 2204 :                 L"Returned [%02x%02x%02x%02x%02x]\r\n",
; 2205 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5]
; 2206 :             ));
; 2207 :             break;

  0016c	ea0000dc	 b           |$LN7@GetCommand|
  00170		 |$LN4@GetCommand|

; 2208 : 
; 2209 :         case ResponseR3:
; 2210 :         case ResponseR4:
; 2211 :             DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2212 :                 L"ResponseR3 ResponseR4\r\n"
; 2213 :             ));
; 2214 :             //--- SHORT RESPONSE (48 bits total)--- 
; 2215 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | RESERVED(6) | CARD_STATUS(32) | RESERVED(7) | END_BIT(1) }
; 2216 :             //
; 2217 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | START_RESERVED);

  00170	e59d2000	 ldr         r2, [sp]
  00174	e3a0303f	 mov         r3, #0x3F
  00178	e5c23000	 strb        r3, [r2]

; 2218 : 
; 2219 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP6);

  0017c	e59d3020	 ldr         r3, [sp, #0x20]
  00180	e2833088	 add         r3, r3, #0x88
  00184	e5933000	 ldr         r3, [r3]
  00188	e2833058	 add         r3, r3, #0x58
  0018c	e1d330b0	 ldrh        r3, [r3]
  00190	e1cd30b6	 strh        r3, [sp, #6]

; 2220 :             *(respBuff + 1) = (BYTE)wRSP;

  00194	e1dd30b6	 ldrh        r3, [sp, #6]
  00198	e20320ff	 and         r2, r3, #0xFF
  0019c	e59d3000	 ldr         r3, [sp]
  001a0	e2833001	 add         r3, r3, #1
  001a4	e5c32000	 strb        r2, [r3]

; 2221 :             *(respBuff + 2)= (BYTE)(wRSP >> 8);

  001a8	e1dd30b6	 ldrh        r3, [sp, #6]
  001ac	e1a03443	 mov         r3, r3, asr #8
  001b0	e20320ff	 and         r2, r3, #0xFF
  001b4	e59d3000	 ldr         r3, [sp]
  001b8	e2833002	 add         r3, r3, #2
  001bc	e5c32000	 strb        r2, [r3]

; 2222 : 
; 2223 : 
; 2224 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP7);

  001c0	e59d3020	 ldr         r3, [sp, #0x20]
  001c4	e2833088	 add         r3, r3, #0x88
  001c8	e5933000	 ldr         r3, [r3]
  001cc	e283305c	 add         r3, r3, #0x5C
  001d0	e1d330b0	 ldrh        r3, [r3]
  001d4	e1cd30b6	 strh        r3, [sp, #6]

; 2225 :             *(respBuff + 3) = (BYTE)wRSP;

  001d8	e1dd30b6	 ldrh        r3, [sp, #6]
  001dc	e20320ff	 and         r2, r3, #0xFF
  001e0	e59d3000	 ldr         r3, [sp]
  001e4	e2833003	 add         r3, r3, #3
  001e8	e5c32000	 strb        r2, [r3]

; 2226 :             *(respBuff + 4) = (BYTE)(wRSP >> 8);

  001ec	e1dd30b6	 ldrh        r3, [sp, #6]
  001f0	e1a03443	 mov         r3, r3, asr #8
  001f4	e20320ff	 and         r2, r3, #0xFF
  001f8	e59d3000	 ldr         r3, [sp]
  001fc	e2833004	 add         r3, r3, #4
  00200	e5c32000	 strb        r2, [r3]

; 2227 : 
; 2228 :             *(respBuff + 5) = (BYTE)(END_RESERVED | END_BIT);

  00204	e59d3000	 ldr         r3, [sp]
  00208	e2832005	 add         r2, r3, #5
  0020c	e3a030ff	 mov         r3, #0xFF
  00210	e5c23000	 strb        r3, [r2]

; 2229 : 
; 2230 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(L"CSDIOControllerBase::GetCommandResponse: "
; 2231 :                 L"Returned [%02x%02x%02x%02x%02x]\r\n", 
; 2232 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5]
; 2233 :             ));
; 2234 :             break;

  00214	ea0000b2	 b           |$LN7@GetCommand|
  00218		 |$LN3@GetCommand|

; 2235 : 
; 2236 :         case ResponseR5:                
; 2237 :         case ResponseR6:
; 2238 :             DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2239 :                 L"ResponseR5 ResponseR6\r\n"
; 2240 :             ));
; 2241 :             //--- SHORT RESPONSE (48 bits total)--- 
; 2242 :             // Format: { START_BIT(1) | TRANSMISSION_BIT(1) | COMMAND_INDEX(6) | RCA(16) | CARD_STATUS(16) | CRC7(7) | END_BIT(1) }
; 2243 :             //
; 2244 :             *respBuff = (BYTE)(START_BIT | TRANSMISSION_BIT | pRequest->CommandCode);

  00218	e59d3024	 ldr         r3, [sp, #0x24]
  0021c	e2833014	 add         r3, r3, #0x14
  00220	e5d32000	 ldrb        r2, [r3]
  00224	e59d3000	 ldr         r3, [sp]
  00228	e5c32000	 strb        r2, [r3]

; 2245 : 
; 2246 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP6);

  0022c	e59d3020	 ldr         r3, [sp, #0x20]
  00230	e2833088	 add         r3, r3, #0x88
  00234	e5933000	 ldr         r3, [r3]
  00238	e2833058	 add         r3, r3, #0x58
  0023c	e1d330b0	 ldrh        r3, [r3]
  00240	e1cd30b6	 strh        r3, [sp, #6]

; 2247 :             *(respBuff + 1) = (BYTE)wRSP;

  00244	e1dd30b6	 ldrh        r3, [sp, #6]
  00248	e20320ff	 and         r2, r3, #0xFF
  0024c	e59d3000	 ldr         r3, [sp]
  00250	e2833001	 add         r3, r3, #1
  00254	e5c32000	 strb        r2, [r3]

; 2248 :             *(respBuff + 2)= (BYTE)(wRSP >> 8);

  00258	e1dd30b6	 ldrh        r3, [sp, #6]
  0025c	e1a03443	 mov         r3, r3, asr #8
  00260	e20320ff	 and         r2, r3, #0xFF
  00264	e59d3000	 ldr         r3, [sp]
  00268	e2833002	 add         r3, r3, #2
  0026c	e5c32000	 strb        r2, [r3]

; 2249 : 
; 2250 : 
; 2251 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP7);

  00270	e59d3020	 ldr         r3, [sp, #0x20]
  00274	e2833088	 add         r3, r3, #0x88
  00278	e5933000	 ldr         r3, [r3]
  0027c	e283305c	 add         r3, r3, #0x5C
  00280	e1d330b0	 ldrh        r3, [r3]
  00284	e1cd30b6	 strh        r3, [sp, #6]

; 2252 :             *(respBuff + 3) = (BYTE)wRSP;

  00288	e1dd30b6	 ldrh        r3, [sp, #6]
  0028c	e20320ff	 and         r2, r3, #0xFF
  00290	e59d3000	 ldr         r3, [sp]
  00294	e2833003	 add         r3, r3, #3
  00298	e5c32000	 strb        r2, [r3]

; 2253 :             *(respBuff + 4) = (BYTE)(wRSP >> 8);

  0029c	e1dd30b6	 ldrh        r3, [sp, #6]
  002a0	e1a03443	 mov         r3, r3, asr #8
  002a4	e20320ff	 and         r2, r3, #0xFF
  002a8	e59d3000	 ldr         r3, [sp]
  002ac	e2833004	 add         r3, r3, #4
  002b0	e5c32000	 strb        r2, [r3]

; 2254 : 
; 2255 :             *(respBuff + 5) = (BYTE)(END_BIT);

  002b4	e59d3000	 ldr         r3, [sp]
  002b8	e2832005	 add         r2, r3, #5
  002bc	e3a03001	 mov         r3, #1
  002c0	e5c23000	 strb        r3, [r2]

; 2256 : 
; 2257 :             DEBUGMSG(SHC_RESPONSE_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2258 : 
; 2259 :                 L"R5 R6 : 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \r\n", *(respBuff + 0), 
; 2260 :                 *(respBuff + 1), *(respBuff + 2), *(respBuff + 3), *(respBuff + 4), *(respBuff + 5)
; 2261 :             ));
; 2262 : 
; 2263 :             DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(L"CSDIOControllerBase::GetCommandResponse: "
; 2264 :                 L"Returned [%02x%02x%02x%02x%02x]\r\n", 
; 2265 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5]
; 2266 :             ));
; 2267 :             break;

  002c4	ea000086	 b           |$LN7@GetCommand|
  002c8		 |$LN2@GetCommand|

; 2268 : 
; 2269 :         case ResponseR2:
; 2270 : 
; 2271 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP0);

  002c8	e59d3020	 ldr         r3, [sp, #0x20]
  002cc	e2833088	 add         r3, r3, #0x88
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e2833040	 add         r3, r3, #0x40
  002d8	e1d330b0	 ldrh        r3, [r3]
  002dc	e1cd30b6	 strh        r3, [sp, #6]

; 2272 :             *respBuff       = (BYTE)wRSP;

  002e0	e1dd30b6	 ldrh        r3, [sp, #6]
  002e4	e20320ff	 and         r2, r3, #0xFF
  002e8	e59d3000	 ldr         r3, [sp]
  002ec	e5c32000	 strb        r2, [r3]

; 2273 :             *(respBuff + 1) = (BYTE)(wRSP >> 8);

  002f0	e1dd30b6	 ldrh        r3, [sp, #6]
  002f4	e1a03443	 mov         r3, r3, asr #8
  002f8	e20320ff	 and         r2, r3, #0xFF
  002fc	e59d3000	 ldr         r3, [sp]
  00300	e2833001	 add         r3, r3, #1
  00304	e5c32000	 strb        r2, [r3]

; 2274 : 
; 2275 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP1);

  00308	e59d3020	 ldr         r3, [sp, #0x20]
  0030c	e2833088	 add         r3, r3, #0x88
  00310	e5933000	 ldr         r3, [r3]
  00314	e2833044	 add         r3, r3, #0x44
  00318	e1d330b0	 ldrh        r3, [r3]
  0031c	e1cd30b6	 strh        r3, [sp, #6]

; 2276 :             *(respBuff + 2) = (BYTE)wRSP;

  00320	e1dd30b6	 ldrh        r3, [sp, #6]
  00324	e20320ff	 and         r2, r3, #0xFF
  00328	e59d3000	 ldr         r3, [sp]
  0032c	e2833002	 add         r3, r3, #2
  00330	e5c32000	 strb        r2, [r3]

; 2277 :             *(respBuff + 3) = (BYTE)(wRSP >> 8);

  00334	e1dd30b6	 ldrh        r3, [sp, #6]
  00338	e1a03443	 mov         r3, r3, asr #8
  0033c	e20320ff	 and         r2, r3, #0xFF
  00340	e59d3000	 ldr         r3, [sp]
  00344	e2833003	 add         r3, r3, #3
  00348	e5c32000	 strb        r2, [r3]

; 2278 : 
; 2279 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP2);

  0034c	e59d3020	 ldr         r3, [sp, #0x20]
  00350	e2833088	 add         r3, r3, #0x88
  00354	e5933000	 ldr         r3, [r3]
  00358	e2833048	 add         r3, r3, #0x48
  0035c	e1d330b0	 ldrh        r3, [r3]
  00360	e1cd30b6	 strh        r3, [sp, #6]

; 2280 :             *(respBuff + 4) = (BYTE)wRSP;

  00364	e1dd30b6	 ldrh        r3, [sp, #6]
  00368	e20320ff	 and         r2, r3, #0xFF
  0036c	e59d3000	 ldr         r3, [sp]
  00370	e2833004	 add         r3, r3, #4
  00374	e5c32000	 strb        r2, [r3]

; 2281 :             *(respBuff + 5) = (BYTE)(wRSP >> 8);

  00378	e1dd30b6	 ldrh        r3, [sp, #6]
  0037c	e1a03443	 mov         r3, r3, asr #8
  00380	e20320ff	 and         r2, r3, #0xFF
  00384	e59d3000	 ldr         r3, [sp]
  00388	e2833005	 add         r3, r3, #5
  0038c	e5c32000	 strb        r2, [r3]

; 2282 : 
; 2283 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP3);

  00390	e59d3020	 ldr         r3, [sp, #0x20]
  00394	e2833088	 add         r3, r3, #0x88
  00398	e5933000	 ldr         r3, [r3]
  0039c	e283304c	 add         r3, r3, #0x4C
  003a0	e1d330b0	 ldrh        r3, [r3]
  003a4	e1cd30b6	 strh        r3, [sp, #6]

; 2284 :             *(respBuff + 6) = (BYTE)wRSP;

  003a8	e1dd30b6	 ldrh        r3, [sp, #6]
  003ac	e20320ff	 and         r2, r3, #0xFF
  003b0	e59d3000	 ldr         r3, [sp]
  003b4	e2833006	 add         r3, r3, #6
  003b8	e5c32000	 strb        r2, [r3]

; 2285 :             *(respBuff + 7) = (BYTE)(wRSP >> 8);

  003bc	e1dd30b6	 ldrh        r3, [sp, #6]
  003c0	e1a03443	 mov         r3, r3, asr #8
  003c4	e20320ff	 and         r2, r3, #0xFF
  003c8	e59d3000	 ldr         r3, [sp]
  003cc	e2833007	 add         r3, r3, #7
  003d0	e5c32000	 strb        r2, [r3]

; 2286 : 
; 2287 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP4);

  003d4	e59d3020	 ldr         r3, [sp, #0x20]
  003d8	e2833088	 add         r3, r3, #0x88
  003dc	e5933000	 ldr         r3, [r3]
  003e0	e2833050	 add         r3, r3, #0x50
  003e4	e1d330b0	 ldrh        r3, [r3]
  003e8	e1cd30b6	 strh        r3, [sp, #6]

; 2288 :             *(respBuff + 8) = (BYTE)wRSP;

  003ec	e1dd30b6	 ldrh        r3, [sp, #6]
  003f0	e20320ff	 and         r2, r3, #0xFF
  003f4	e59d3000	 ldr         r3, [sp]
  003f8	e2833008	 add         r3, r3, #8
  003fc	e5c32000	 strb        r2, [r3]

; 2289 :             *(respBuff + 9) = (BYTE)(wRSP >> 8);

  00400	e1dd30b6	 ldrh        r3, [sp, #6]
  00404	e1a03443	 mov         r3, r3, asr #8
  00408	e20320ff	 and         r2, r3, #0xFF
  0040c	e59d3000	 ldr         r3, [sp]
  00410	e2833009	 add         r3, r3, #9
  00414	e5c32000	 strb        r2, [r3]

; 2290 : 
; 2291 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP5);

  00418	e59d3020	 ldr         r3, [sp, #0x20]
  0041c	e2833088	 add         r3, r3, #0x88
  00420	e5933000	 ldr         r3, [r3]
  00424	e2833054	 add         r3, r3, #0x54
  00428	e1d330b0	 ldrh        r3, [r3]
  0042c	e1cd30b6	 strh        r3, [sp, #6]

; 2292 :             *(respBuff + 10) = (BYTE)wRSP;

  00430	e1dd30b6	 ldrh        r3, [sp, #6]
  00434	e20320ff	 and         r2, r3, #0xFF
  00438	e59d3000	 ldr         r3, [sp]
  0043c	e283300a	 add         r3, r3, #0xA
  00440	e5c32000	 strb        r2, [r3]

; 2293 :             *(respBuff + 11) = (BYTE)(wRSP >> 8);

  00444	e1dd30b6	 ldrh        r3, [sp, #6]
  00448	e1a03443	 mov         r3, r3, asr #8
  0044c	e20320ff	 and         r2, r3, #0xFF
  00450	e59d3000	 ldr         r3, [sp]
  00454	e283300b	 add         r3, r3, #0xB
  00458	e5c32000	 strb        r2, [r3]

; 2294 : 
; 2295 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP6);

  0045c	e59d3020	 ldr         r3, [sp, #0x20]
  00460	e2833088	 add         r3, r3, #0x88
  00464	e5933000	 ldr         r3, [r3]
  00468	e2833058	 add         r3, r3, #0x58
  0046c	e1d330b0	 ldrh        r3, [r3]
  00470	e1cd30b6	 strh        r3, [sp, #6]

; 2296 :             *(respBuff + 12) = (BYTE)wRSP;

  00474	e1dd30b6	 ldrh        r3, [sp, #6]
  00478	e20320ff	 and         r2, r3, #0xFF
  0047c	e59d3000	 ldr         r3, [sp]
  00480	e283300c	 add         r3, r3, #0xC
  00484	e5c32000	 strb        r2, [r3]

; 2297 :             *(respBuff + 13) = (BYTE)(wRSP >> 8);

  00488	e1dd30b6	 ldrh        r3, [sp, #6]
  0048c	e1a03443	 mov         r3, r3, asr #8
  00490	e20320ff	 and         r2, r3, #0xFF
  00494	e59d3000	 ldr         r3, [sp]
  00498	e283300d	 add         r3, r3, #0xD
  0049c	e5c32000	 strb        r2, [r3]

; 2298 : 
; 2299 :             wRSP = INREG16(&m_vpSDIOReg->MMC_RSP7);

  004a0	e59d3020	 ldr         r3, [sp, #0x20]
  004a4	e2833088	 add         r3, r3, #0x88
  004a8	e5933000	 ldr         r3, [r3]
  004ac	e283305c	 add         r3, r3, #0x5C
  004b0	e1d330b0	 ldrh        r3, [r3]
  004b4	e1cd30b6	 strh        r3, [sp, #6]

; 2300 :             *(respBuff + 14) = (BYTE)wRSP;

  004b8	e1dd30b6	 ldrh        r3, [sp, #6]
  004bc	e20320ff	 and         r2, r3, #0xFF
  004c0	e59d3000	 ldr         r3, [sp]
  004c4	e283300e	 add         r3, r3, #0xE
  004c8	e5c32000	 strb        r2, [r3]

; 2301 :             *(respBuff + 15) = (BYTE)(wRSP >> 8);

  004cc	e1dd30b6	 ldrh        r3, [sp, #6]
  004d0	e1a03443	 mov         r3, r3, asr #8
  004d4	e20320ff	 and         r2, r3, #0xFF
  004d8	e59d3000	 ldr         r3, [sp]
  004dc	e283300f	 add         r3, r3, #0xF
  004e0	e5c32000	 strb        r2, [r3]
  004e4		 |$LN1@GetCommand|
  004e4		 |$LN7@GetCommand|
  004e4		 |$LN9@GetCommand|

; 2302 : 
; 2303 :             DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::GetCommandResponse: "
; 2304 :                 L"Returned [%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x]\r\n", 
; 2305 :                 respBuff[0], respBuff[1], respBuff[2], respBuff[3], respBuff[4], respBuff[5], respBuff[6], respBuff[7], 
; 2306 :                 respBuff[8], respBuff[9], respBuff[10], respBuff[11], respBuff[12], respBuff[13], respBuff[14], respBuff[15]
; 2307 :             ));
; 2308 :             break;
; 2309 : 
; 2310 :         default:
; 2311 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::GetCommandResponse: "
; 2312 :                 L"Unrecognized response type!\r\n"
; 2313 :             ));
; 2314 :             break;
; 2315 :         }
; 2316 :     }
; 2317 :     return SD_API_STATUS_SUCCESS;

  004e4	e3a03000	 mov         r3, #0
  004e8	e58d300c	 str         r3, [sp, #0xC]

; 2318 : }

  004ec	e59d000c	 ldr         r0, [sp, #0xC]
  004f0	e28dd018	 add         sp, sp, #0x18
  004f4	e89d6000	 ldmia       sp, {sp, lr}
  004f8	e12fff1e	 bx          lr
  004fc		 |$M42338|

			 ENDP  ; |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::GetCommandResponse

	EXPORT	|?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDIPollingReceive

  00000			 AREA	 |.pdata|, PDATA
|$T42362| DCD	|$LN43@SDIPolling|
	DCD	0x40010404
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDIPollingReceive

; 2338 : {

  00000		 |$LN43@SDIPolling|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd04c	 sub         sp, sp, #0x4C
  00010		 |$M42359|

; 2339 :     WORD wFIFOAlmostFullLevel = (((INREG16(&m_vpSDIOReg->MMC_BUF) >> 8) & 0x1F) + 1) * 2;

  00010	e59d3054	 ldr         r3, [sp, #0x54]
  00014	e2833088	 add         r3, r3, #0x88
  00018	e5933000	 ldr         r3, [r3]
  0001c	e283302c	 add         r3, r3, #0x2C
  00020	e1d330b0	 ldrh        r3, [r3]
  00024	e1a03443	 mov         r3, r3, asr #8
  00028	e203301f	 and         r3, r3, #0x1F
  0002c	e2832001	 add         r2, r3, #1
  00030	e3a03002	 mov         r3, #2
  00034	e0030392	 mul         r3, r2, r3
  00038	e1a03803	 mov         r3, r3, lsl #16
  0003c	e1a03823	 mov         r3, r3, lsr #16
  00040	e1cd30b4	 strh        r3, [sp, #4]

; 2340 :     BOOL fWaitingForBusyEnd = FALSE;

  00044	e3a03000	 mov         r3, #0
  00048	e58d300c	 str         r3, [sp, #0xC]

; 2341 :     DWORD dwCurrentTickCount;
; 2342 :     DWORD dwTimeout;
; 2343 :     DWORD dwCountStart;
; 2344 :     BOOL fTimeoutOverflow = FALSE;

  0004c	e3a03000	 mov         r3, #0
  00050	e58d3000	 str         r3, [sp]

; 2345 : 
; 2346 :     DEBUGMSG(SHC_RECEIVE_ZONE, (L"+CSDIOControllerBase::SDIPollingReceive: "
; 2347 :         L"dwLen 0x%x\n", dwLen
; 2348 :     ));
; 2349 :     //check the parameters
; 2350 : 
; 2351 :     WORD MMC_STAT = Read_MMC_STAT();

  00054	e59d0054	 ldr         r0, [sp, #0x54]
  00058	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  0005c	e1cd02b8	 strh        r0, [sp, #0x28]
  00060	e1dd32b8	 ldrh        r3, [sp, #0x28]
  00064	e1cd30b6	 strh        r3, [sp, #6]

; 2352 : 
; 2353 :     if( ( MMC_STAT & MMC_STAT_CB ) && (!(MMC_STAT & MMC_STAT_EOFB)) )
; 2354 :     {
; 2355 :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2356 :             L"Card in busy state before data receive!  Delaying...\r\n"
; 2357 :         ));
; 2358 :     }
; 2359 : 
; 2360 :     // calculate timeout conditions
; 2361 :     dwCountStart = GetTickCount();

  00068	eb000000	 bl          GetTickCount
  0006c	e58d002c	 str         r0, [sp, #0x2C]
  00070	e59d302c	 ldr         r3, [sp, #0x2C]
  00074	e58d3008	 str         r3, [sp, #8]

; 2362 :     dwTimeout = dwCountStart + m_dwMaxTimeout;

  00078	e59d3054	 ldr         r3, [sp, #0x54]
  0007c	e283307c	 add         r3, r3, #0x7C
  00080	e59d2008	 ldr         r2, [sp, #8]
  00084	e5933000	 ldr         r3, [r3]
  00088	e0823003	 add         r3, r2, r3
  0008c	e58d3014	 str         r3, [sp, #0x14]

; 2363 :     if( dwTimeout < dwCountStart )

  00090	e59d2014	 ldr         r2, [sp, #0x14]
  00094	e59d3008	 ldr         r3, [sp, #8]
  00098	e1520003	 cmp         r2, r3
  0009c	2a000001	 bcs         |$LN23@SDIPolling|

; 2364 :         fTimeoutOverflow = TRUE;

  000a0	e3a03001	 mov         r3, #1
  000a4	e58d3000	 str         r3, [sp]
  000a8		 |$LN23@SDIPolling|
  000a8		 |$LN22@SDIPolling|

; 2365 : 
; 2366 :     while( dwLen > 0 )

  000a8	e59d305c	 ldr         r3, [sp, #0x5C]
  000ac	e3530000	 cmp         r3, #0
  000b0	9a0000c1	 bls         |$LN21@SDIPolling|

; 2367 :     {
; 2368 :         // check for a timeout
; 2369 :         dwCurrentTickCount = GetTickCount();

  000b4	eb000000	 bl          GetTickCount
  000b8	e58d0030	 str         r0, [sp, #0x30]
  000bc	e59d3030	 ldr         r3, [sp, #0x30]
  000c0	e58d3010	 str         r3, [sp, #0x10]

; 2370 :         if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 2371 :             : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  000c4	e59d3000	 ldr         r3, [sp]
  000c8	e3530000	 cmp         r3, #0
  000cc	0a00000f	 beq         |$LN31@SDIPolling|
  000d0	e59d2014	 ldr         r2, [sp, #0x14]
  000d4	e59d3010	 ldr         r3, [sp, #0x10]
  000d8	e1520003	 cmp         r2, r3
  000dc	2a000006	 bcs         |$LN27@SDIPolling|
  000e0	e59d2010	 ldr         r2, [sp, #0x10]
  000e4	e59d3008	 ldr         r3, [sp, #8]
  000e8	e1520003	 cmp         r2, r3
  000ec	2a000002	 bcs         |$LN27@SDIPolling|
  000f0	e3a03001	 mov         r3, #1
  000f4	e58d3034	 str         r3, [sp, #0x34]
  000f8	ea000001	 b           |$LN30@SDIPolling|
  000fc		 |$LN27@SDIPolling|
  000fc	e3a03000	 mov         r3, #0
  00100	e58d3034	 str         r3, [sp, #0x34]
  00104		 |$LN30@SDIPolling|
  00104	e59d3034	 ldr         r3, [sp, #0x34]
  00108	e58d3038	 str         r3, [sp, #0x38]
  0010c	ea00000e	 b           |$LN32@SDIPolling|
  00110		 |$LN31@SDIPolling|
  00110	e59d2014	 ldr         r2, [sp, #0x14]
  00114	e59d3010	 ldr         r3, [sp, #0x10]
  00118	e1520003	 cmp         r2, r3
  0011c	3a000006	 bcc         |$LN28@SDIPolling|
  00120	e59d2010	 ldr         r2, [sp, #0x10]
  00124	e59d3008	 ldr         r3, [sp, #8]
  00128	e1520003	 cmp         r2, r3
  0012c	3a000002	 bcc         |$LN28@SDIPolling|
  00130	e3a03000	 mov         r3, #0
  00134	e58d303c	 str         r3, [sp, #0x3C]
  00138	ea000001	 b           |$LN29@SDIPolling|
  0013c		 |$LN28@SDIPolling|
  0013c	e3a03001	 mov         r3, #1
  00140	e58d303c	 str         r3, [sp, #0x3C]
  00144		 |$LN29@SDIPolling|
  00144	e59d303c	 ldr         r3, [sp, #0x3C]
  00148	e58d3038	 str         r3, [sp, #0x38]
  0014c		 |$LN32@SDIPolling|
  0014c	e59d3038	 ldr         r3, [sp, #0x38]
  00150	e3530000	 cmp         r3, #0
  00154	0a000001	 beq         |$LN20@SDIPolling|
  00158	ea0000a6	 b           |$LN19@SDIPolling|

; 2372 :         {
; 2373 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2374 :                 L"Exit: TIMEOUT.\r\n"
; 2375 :             ));
; 2376 :             goto READ_ERROR;

  0015c	ea0000a5	 b           |$READ_ERROR$40896|
  00160		 |$LN20@SDIPolling|

; 2377 :         }
; 2378 : 
; 2379 :         if( !SDCardDetect() )

  00160	e59d3054	 ldr         r3, [sp, #0x54]
  00164	e5933000	 ldr         r3, [r3]
  00168	e2833014	 add         r3, r3, #0x14
  0016c	e59d0054	 ldr         r0, [sp, #0x54]
  00170	e5933000	 ldr         r3, [r3]
  00174	e1a0e00f	 mov         lr, pc
  00178	e12fff13	 bx          r3
  0017c	e58d0040	 str         r0, [sp, #0x40]
  00180	e59d3040	 ldr         r3, [sp, #0x40]
  00184	e3530000	 cmp         r3, #0
  00188	1a000001	 bne         |$LN18@SDIPolling|
  0018c	ea000099	 b           |$LN17@SDIPolling|

; 2380 :         {
; 2381 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2382 :                 L"Exit: Card removed.\r\n"
; 2383 :             ));
; 2384 :             goto READ_ERROR;

  00190	ea000098	 b           |$READ_ERROR$40896|
  00194		 |$LN18@SDIPolling|

; 2385 :         }
; 2386 : 
; 2387 :         if( MMC_STAT & MMC_STAT_DCRC ) // DATA CRC Error

  00194	e1dd30b6	 ldrh        r3, [sp, #6]
  00198	e3130040	 tst         r3, #0x40
  0019c	0a000001	 beq         |$LN16@SDIPolling|
  001a0	ea000094	 b           |$LN15@SDIPolling|

; 2388 :         {
; 2389 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2390 :                 L"Exit: MMC_CRC_ERROR_RCVD.\r\n"
; 2391 :             ));
; 2392 :             goto READ_ERROR;

  001a4	ea000093	 b           |$READ_ERROR$40896|
  001a8		 |$LN16@SDIPolling|

; 2393 :         }
; 2394 : 
; 2395 :         if( MMC_STAT & MMC_STAT_DTO ) // DATA Response Timeout

  001a8	e1dd30b6	 ldrh        r3, [sp, #6]
  001ac	e3130020	 tst         r3, #0x20
  001b0	0a000001	 beq         |$LN14@SDIPolling|
  001b4	ea00008f	 b           |$LN13@SDIPolling|

; 2396 :         {
; 2397 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2398 :                 L"Exit: MMC_TIME_OUT_RCVD.\r\n"
; 2399 :             ));
; 2400 :             goto READ_ERROR;

  001b8	ea00008e	 b           |$READ_ERROR$40896|
  001bc		 |$LN14@SDIPolling|

; 2401 :         }
; 2402 : 
; 2403 :         if( MMC_STAT & ( MMC_STAT_AF | MMC_STAT_BRS ) ) // buffer almost full or block received

  001bc	e1dd30b6	 ldrh        r3, [sp, #6]
  001c0	e1a02003	 mov         r2, r3
  001c4	e3a03b01	 mov         r3, #1, 22
  001c8	e3833008	 orr         r3, r3, #8
  001cc	e1120003	 tst         r2, r3
  001d0	0a000073	 beq         |$LN12@SDIPolling|

; 2404 :         {
; 2405 :             Write_MMC_STAT( MMC_STAT_AF );

  001d4	e59d3054	 ldr         r3, [sp, #0x54]
  001d8	e2830014	 add         r0, r3, #0x14
  001dc	eb000000	 bl          EnterCriticalSection
  001e0	e59d3054	 ldr         r3, [sp, #0x54]
  001e4	e2833088	 add         r3, r3, #0x88
  001e8	e5933000	 ldr         r3, [r3]
  001ec	e2832010	 add         r2, r3, #0x10
  001f0	e3a03b01	 mov         r3, #1, 22
  001f4	e1c230b0	 strh        r3, [r2]
  001f8	e59d3054	 ldr         r3, [sp, #0x54]
  001fc	e2830014	 add         r0, r3, #0x14
  00200	eb000000	 bl          LeaveCriticalSection

; 2406 :             DWORD dwTransferSize = wFIFOAlmostFullLevel;

  00204	e1dd30b4	 ldrh        r3, [sp, #4]
  00208	e58d3018	 str         r3, [sp, #0x18]

; 2407 :             if( dwLen < dwTransferSize )

  0020c	e59d205c	 ldr         r2, [sp, #0x5C]
  00210	e59d3018	 ldr         r3, [sp, #0x18]
  00214	e1520003	 cmp         r2, r3
  00218	2a000001	 bcs         |$LN11@SDIPolling|

; 2408 :             {
; 2409 :                 dwTransferSize = dwLen;

  0021c	e59d305c	 ldr         r3, [sp, #0x5C]
  00220	e58d3018	 str         r3, [sp, #0x18]
  00224		 |$LN11@SDIPolling|

; 2410 :             }
; 2411 : 
; 2412 :             dwLen = dwLen - dwTransferSize;

  00224	e59d205c	 ldr         r2, [sp, #0x5C]
  00228	e59d3018	 ldr         r3, [sp, #0x18]
  0022c	e0423003	 sub         r3, r2, r3
  00230	e58d305c	 str         r3, [sp, #0x5C]

; 2413 : 
; 2414 :             if( ((DWORD)pBuff) % 2 ) // the data buffer is not aligned

  00234	e59d1058	 ldr         r1, [sp, #0x58]
  00238	e3a00002	 mov         r0, #2
  0023c	eb000000	 bl          __rt_udiv
  00240	e3510000	 cmp         r1, #0
  00244	0a000020	 beq         |$LN10@SDIPolling|
  00248		 |$LN9@SDIPolling|

; 2415 :             {
; 2416 :                 while( dwTransferSize > 1)

  00248	e59d3018	 ldr         r3, [sp, #0x18]
  0024c	e3530001	 cmp         r3, #1
  00250	9a00001c	 bls         |$LN8@SDIPolling|

; 2417 :                 {
; 2418 :                     WORD wData = INREG16(&m_vpSDIOReg->MMC_DATA);

  00254	e59d3054	 ldr         r3, [sp, #0x54]
  00258	e2833088	 add         r3, r3, #0x88
  0025c	e5933000	 ldr         r3, [r3]
  00260	e2833020	 add         r3, r3, #0x20
  00264	e1d330b0	 ldrh        r3, [r3]
  00268	e1cd31bc	 strh        r3, [sp, #0x1C]

; 2419 :                     BYTE bLo = wData & 0xff;

  0026c	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00270	e20330ff	 and         r3, r3, #0xFF
  00274	e20330ff	 and         r3, r3, #0xFF
  00278	e5cd301e	 strb        r3, [sp, #0x1E]

; 2420 :                     BYTE bHi = ( wData & 0xff00 ) >> 8;

  0027c	e1dd31bc	 ldrh        r3, [sp, #0x1C]
  00280	e2033cff	 and         r3, r3, #0xFF, 24
  00284	e1a03443	 mov         r3, r3, asr #8
  00288	e20330ff	 and         r3, r3, #0xFF
  0028c	e5cd301f	 strb        r3, [sp, #0x1F]

; 2421 :                     *((BYTE*)pBuff) = bLo;

  00290	e5dd201e	 ldrb        r2, [sp, #0x1E]
  00294	e59d3058	 ldr         r3, [sp, #0x58]
  00298	e5c32000	 strb        r2, [r3]

; 2422 :                     *((BYTE*)pBuff+1) = bHi;

  0029c	e59d3058	 ldr         r3, [sp, #0x58]
  002a0	e2832001	 add         r2, r3, #1
  002a4	e5dd301f	 ldrb        r3, [sp, #0x1F]
  002a8	e5c23000	 strb        r3, [r2]

; 2423 :                     dwTransferSize -= 2;

  002ac	e59d3018	 ldr         r3, [sp, #0x18]
  002b0	e2433002	 sub         r3, r3, #2
  002b4	e58d3018	 str         r3, [sp, #0x18]

; 2424 :                     pBuff += 2;

  002b8	e59d3058	 ldr         r3, [sp, #0x58]
  002bc	e2833002	 add         r3, r3, #2
  002c0	e58d3058	 str         r3, [sp, #0x58]

; 2425 :                 }

  002c4	eaffffdf	 b           |$LN9@SDIPolling|
  002c8		 |$LN8@SDIPolling|

; 2426 :             }
; 2427 :             else

  002c8	ea000010	 b           |$LN7@SDIPolling|
  002cc		 |$LN10@SDIPolling|
  002cc		 |$LN6@SDIPolling|

; 2428 :             {
; 2429 :                 while( dwTransferSize > 1)

  002cc	e59d3018	 ldr         r3, [sp, #0x18]
  002d0	e3530001	 cmp         r3, #1
  002d4	9a00000d	 bls         |$LN5@SDIPolling|

; 2430 :                 {
; 2431 :                     *((WORD*)pBuff) = INREG16(&m_vpSDIOReg->MMC_DATA);

  002d8	e59d3054	 ldr         r3, [sp, #0x54]
  002dc	e2833088	 add         r3, r3, #0x88
  002e0	e5933000	 ldr         r3, [r3]
  002e4	e2833020	 add         r3, r3, #0x20
  002e8	e1d320b0	 ldrh        r2, [r3]
  002ec	e59d3058	 ldr         r3, [sp, #0x58]
  002f0	e1c320b0	 strh        r2, [r3]

; 2432 :                     dwTransferSize -= 2;

  002f4	e59d3018	 ldr         r3, [sp, #0x18]
  002f8	e2433002	 sub         r3, r3, #2
  002fc	e58d3018	 str         r3, [sp, #0x18]

; 2433 :                     pBuff += 2;

  00300	e59d3058	 ldr         r3, [sp, #0x58]
  00304	e2833002	 add         r3, r3, #2
  00308	e58d3058	 str         r3, [sp, #0x58]

; 2434 :                 }

  0030c	eaffffee	 b           |$LN6@SDIPolling|
  00310		 |$LN5@SDIPolling|
  00310		 |$LN7@SDIPolling|

; 2435 :             }
; 2436 : 
; 2437 :             if (dwTransferSize==1)

  00310	e59d3018	 ldr         r3, [sp, #0x18]
  00314	e3530001	 cmp         r3, #1
  00318	1a00000e	 bne         |$LN4@SDIPolling|

; 2438 :             {
; 2439 :                 *((BYTE*)pBuff) = INREG16(&m_vpSDIOReg->MMC_DATA) & 0xff;

  0031c	e59d3054	 ldr         r3, [sp, #0x54]
  00320	e2833088	 add         r3, r3, #0x88
  00324	e5933000	 ldr         r3, [r3]
  00328	e2833020	 add         r3, r3, #0x20
  0032c	e1d330b0	 ldrh        r3, [r3]
  00330	e20330ff	 and         r3, r3, #0xFF
  00334	e20320ff	 and         r2, r3, #0xFF
  00338	e59d3058	 ldr         r3, [sp, #0x58]
  0033c	e5c32000	 strb        r2, [r3]

; 2440 :                 dwTransferSize -= 1;

  00340	e59d3018	 ldr         r3, [sp, #0x18]
  00344	e2433001	 sub         r3, r3, #1
  00348	e58d3018	 str         r3, [sp, #0x18]

; 2441 :                 pBuff += 1;

  0034c	e59d3058	 ldr         r3, [sp, #0x58]
  00350	e2833001	 add         r3, r3, #1
  00354	e58d3058	 str         r3, [sp, #0x58]
  00358		 |$LN4@SDIPolling|

; 2442 :             }
; 2443 : 
; 2444 :             // recalculate timeout conditions
; 2445 :             dwCountStart = GetTickCount();

  00358	eb000000	 bl          GetTickCount
  0035c	e58d0044	 str         r0, [sp, #0x44]
  00360	e59d3044	 ldr         r3, [sp, #0x44]
  00364	e58d3008	 str         r3, [sp, #8]

; 2446 :             dwTimeout = dwCountStart + m_dwMaxTimeout;

  00368	e59d3054	 ldr         r3, [sp, #0x54]
  0036c	e283307c	 add         r3, r3, #0x7C
  00370	e59d2008	 ldr         r2, [sp, #8]
  00374	e5933000	 ldr         r3, [r3]
  00378	e0823003	 add         r3, r2, r3
  0037c	e58d3014	 str         r3, [sp, #0x14]

; 2447 :             if( dwTimeout < dwCountStart )

  00380	e59d2014	 ldr         r2, [sp, #0x14]
  00384	e59d3008	 ldr         r3, [sp, #8]
  00388	e1520003	 cmp         r2, r3
  0038c	2a000002	 bcs         |$LN3@SDIPolling|

; 2448 :                 fTimeoutOverflow = TRUE;

  00390	e3a03001	 mov         r3, #1
  00394	e58d3000	 str         r3, [sp]

; 2449 :             else

  00398	ea000001	 b           |$LN2@SDIPolling|
  0039c		 |$LN3@SDIPolling|

; 2450 :                 fTimeoutOverflow = FALSE;

  0039c	e3a03000	 mov         r3, #0
  003a0	e58d3000	 str         r3, [sp]
  003a4		 |$LN2@SDIPolling|
  003a4		 |$LN12@SDIPolling|

; 2451 :         }
; 2452 : 
; 2453 :         MMC_STAT = Read_MMC_STAT();

  003a4	e59d0054	 ldr         r0, [sp, #0x54]
  003a8	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  003ac	e1cd04b8	 strh        r0, [sp, #0x48]
  003b0	e1dd34b8	 ldrh        r3, [sp, #0x48]
  003b4	e1cd30b6	 strh        r3, [sp, #6]

; 2454 :     } // while

  003b8	eaffff3a	 b           |$LN22@SDIPolling|
  003bc		 |$LN21@SDIPolling|

; 2455 : 
; 2456 :     Write_MMC_STAT( MMC_STAT_BRS );

  003bc	e59d3054	 ldr         r3, [sp, #0x54]
  003c0	e2830014	 add         r0, r3, #0x14
  003c4	eb000000	 bl          EnterCriticalSection
  003c8	e59d3054	 ldr         r3, [sp, #0x54]
  003cc	e2833088	 add         r3, r3, #0x88
  003d0	e5933000	 ldr         r3, [r3]
  003d4	e2832010	 add         r2, r3, #0x10
  003d8	e3a03008	 mov         r3, #8
  003dc	e1c230b0	 strh        r3, [r2]
  003e0	e59d3054	 ldr         r3, [sp, #0x54]
  003e4	e2830014	 add         r0, r3, #0x14
  003e8	eb000000	 bl          LeaveCriticalSection

; 2457 : 
; 2458 :     if( ( MMC_STAT & MMC_STAT_CB ) && (!(MMC_STAT & MMC_STAT_EOFB)) )
; 2459 :     {
; 2460 :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingReceive: "
; 2461 :             L"Card in busy state after data receive!  Delaying...\r\n"
; 2462 :         ));
; 2463 :     }
; 2464 : 
; 2465 :     return TRUE;  

  003ec	e3a03001	 mov         r3, #1
  003f0	e58d3024	 str         r3, [sp, #0x24]
  003f4	ea000001	 b           |$LN25@SDIPolling|
  003f8		 |$LN13@SDIPolling|
  003f8		 |$LN15@SDIPolling|
  003f8		 |$LN17@SDIPolling|
  003f8		 |$LN19@SDIPolling|
  003f8		 |$READ_ERROR$40896|

; 2466 : 
; 2467 : READ_ERROR:
; 2468 :     return FALSE;

  003f8	e3a03000	 mov         r3, #0
  003fc	e58d3024	 str         r3, [sp, #0x24]
  00400		 |$LN25@SDIPolling|

; 2469 : }

  00400	e59d0024	 ldr         r0, [sp, #0x24]
  00404	e28dd04c	 add         sp, sp, #0x4C
  00408	e89d6000	 ldmia       sp, {sp, lr}
  0040c	e12fff1e	 bx          lr
  00410		 |$M42360|

			 ENDP  ; |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDIPollingReceive

	EXPORT	|?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDIPollingTransmit
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T42406| DCD	|$LN94@SDIPolling@2|
	DCD	0x40020504
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDIPollingTransmit

; 2474 : {

  00000		 |$LN94@SDIPolling@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd0a8	 sub         sp, sp, #0xA8
  00010		 |$M42403|

; 2475 :     DWORD dwCurrentTickCount;
; 2476 :     DWORD dwTimeout;
; 2477 :     DWORD dwCountStart;
; 2478 :     BOOL fTimeoutOverflow = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 2479 : 
; 2480 :     WORD wFIFOAlmostEmptyLevel = ((INREG16(&m_vpSDIOReg->MMC_BUF) & 0x1F) + 1) * 2;

  00018	e59d30b0	 ldr         r3, [sp, #0xB0]
  0001c	e2833088	 add         r3, r3, #0x88
  00020	e5933000	 ldr         r3, [r3]
  00024	e283302c	 add         r3, r3, #0x2C
  00028	e1d330b0	 ldrh        r3, [r3]
  0002c	e203301f	 and         r3, r3, #0x1F
  00030	e2832001	 add         r2, r3, #1
  00034	e3a03002	 mov         r3, #2
  00038	e0030392	 mul         r3, r2, r3
  0003c	e1a03803	 mov         r3, r3, lsl #16
  00040	e1a03823	 mov         r3, r3, lsr #16
  00044	e1cd30b4	 strh        r3, [sp, #4]

; 2481 : 
; 2482 :     WORD MMC_STAT = Read_MMC_STAT();

  00048	e59d00b0	 ldr         r0, [sp, #0xB0]
  0004c	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00050	e1cd02bc	 strh        r0, [sp, #0x2C]
  00054	e1dd32bc	 ldrh        r3, [sp, #0x2C]
  00058	e1cd30b6	 strh        r3, [sp, #6]

; 2483 : 
; 2484 :     if( ( MMC_STAT & MMC_STAT_CB ) && (!(MMC_STAT & MMC_STAT_EOFB)) )
; 2485 :     {
; 2486 :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2487 :             L"Card in busy state before data transfer!  Delaying...\r\n"
; 2488 :         ));
; 2489 :     }
; 2490 : 
; 2491 :     ASSERT( ( MMC_STAT & MMC_STAT_BRS ) == 0 );
; 2492 : 
; 2493 :     // calculate timeout conditions
; 2494 :     dwCountStart = GetTickCount();

  0005c	eb000000	 bl          GetTickCount
  00060	e58d0030	 str         r0, [sp, #0x30]
  00064	e59d3030	 ldr         r3, [sp, #0x30]
  00068	e58d3008	 str         r3, [sp, #8]

; 2495 :     dwTimeout = dwCountStart + m_dwMaxTimeout;

  0006c	e59d30b0	 ldr         r3, [sp, #0xB0]
  00070	e283307c	 add         r3, r3, #0x7C
  00074	e59d2008	 ldr         r2, [sp, #8]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e0823003	 add         r3, r2, r3
  00080	e58d3010	 str         r3, [sp, #0x10]

; 2496 :     if( dwTimeout < dwCountStart )

  00084	e59d2010	 ldr         r2, [sp, #0x10]
  00088	e59d3008	 ldr         r3, [sp, #8]
  0008c	e1520003	 cmp         r2, r3
  00090	2a000001	 bcs         |$LN48@SDIPolling@2|

; 2497 :         fTimeoutOverflow = TRUE;

  00094	e3a03001	 mov         r3, #1
  00098	e58d3000	 str         r3, [sp]
  0009c		 |$LN48@SDIPolling@2|
  0009c		 |$LN47@SDIPolling@2|

; 2498 : 
; 2499 :     while( dwLen > 0 ) 

  0009c	e59d30b8	 ldr         r3, [sp, #0xB8]
  000a0	e3530000	 cmp         r3, #0
  000a4	9a00011c	 bls         |$LN46@SDIPolling@2|

; 2500 :     {
; 2501 :         // check for a timeout
; 2502 :         dwCurrentTickCount = GetTickCount();

  000a8	eb000000	 bl          GetTickCount
  000ac	e58d0034	 str         r0, [sp, #0x34]
  000b0	e59d3034	 ldr         r3, [sp, #0x34]
  000b4	e58d300c	 str         r3, [sp, #0xC]

; 2503 :         if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 2504 :             : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  000b8	e59d3000	 ldr         r3, [sp]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a00000f	 beq         |$LN56@SDIPolling@2|
  000c4	e59d2010	 ldr         r2, [sp, #0x10]
  000c8	e59d300c	 ldr         r3, [sp, #0xC]
  000cc	e1520003	 cmp         r2, r3
  000d0	2a000006	 bcs         |$LN52@SDIPolling@2|
  000d4	e59d200c	 ldr         r2, [sp, #0xC]
  000d8	e59d3008	 ldr         r3, [sp, #8]
  000dc	e1520003	 cmp         r2, r3
  000e0	2a000002	 bcs         |$LN52@SDIPolling@2|
  000e4	e3a03001	 mov         r3, #1
  000e8	e58d3038	 str         r3, [sp, #0x38]
  000ec	ea000001	 b           |$LN55@SDIPolling@2|
  000f0		 |$LN52@SDIPolling@2|
  000f0	e3a03000	 mov         r3, #0
  000f4	e58d3038	 str         r3, [sp, #0x38]
  000f8		 |$LN55@SDIPolling@2|
  000f8	e59d3038	 ldr         r3, [sp, #0x38]
  000fc	e58d303c	 str         r3, [sp, #0x3C]
  00100	ea00000e	 b           |$LN57@SDIPolling@2|
  00104		 |$LN56@SDIPolling@2|
  00104	e59d2010	 ldr         r2, [sp, #0x10]
  00108	e59d300c	 ldr         r3, [sp, #0xC]
  0010c	e1520003	 cmp         r2, r3
  00110	3a000006	 bcc         |$LN53@SDIPolling@2|
  00114	e59d200c	 ldr         r2, [sp, #0xC]
  00118	e59d3008	 ldr         r3, [sp, #8]
  0011c	e1520003	 cmp         r2, r3
  00120	3a000002	 bcc         |$LN53@SDIPolling@2|
  00124	e3a03000	 mov         r3, #0
  00128	e58d3040	 str         r3, [sp, #0x40]
  0012c	ea000001	 b           |$LN54@SDIPolling@2|
  00130		 |$LN53@SDIPolling@2|
  00130	e3a03001	 mov         r3, #1
  00134	e58d3040	 str         r3, [sp, #0x40]
  00138		 |$LN54@SDIPolling@2|
  00138	e59d3040	 ldr         r3, [sp, #0x40]
  0013c	e58d303c	 str         r3, [sp, #0x3C]
  00140		 |$LN57@SDIPolling@2|
  00140	e59d303c	 ldr         r3, [sp, #0x3C]
  00144	e3530000	 cmp         r3, #0
  00148	0a000001	 beq         |$LN45@SDIPolling@2|
  0014c	ea0001aa	 b           |$LN44@SDIPolling@2|

; 2505 :         {
; 2506 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2507 :                 L"Exit: TIMEOUT.\r\n"
; 2508 :             ));
; 2509 :             goto WRITE_ERROR;

  00150	ea0001a9	 b           |$WRITE_ERROR$40959|
  00154		 |$LN45@SDIPolling@2|

; 2510 :         }
; 2511 : 
; 2512 :         if( !SDCardDetect() )

  00154	e59d30b0	 ldr         r3, [sp, #0xB0]
  00158	e5933000	 ldr         r3, [r3]
  0015c	e2833014	 add         r3, r3, #0x14
  00160	e59d00b0	 ldr         r0, [sp, #0xB0]
  00164	e5933000	 ldr         r3, [r3]
  00168	e1a0e00f	 mov         lr, pc
  0016c	e12fff13	 bx          r3
  00170	e58d0044	 str         r0, [sp, #0x44]
  00174	e59d3044	 ldr         r3, [sp, #0x44]
  00178	e3530000	 cmp         r3, #0
  0017c	1a000001	 bne         |$LN43@SDIPolling@2|
  00180	ea00019d	 b           |$LN42@SDIPolling@2|

; 2513 :         {
; 2514 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2515 :                 L"Exit: Card removed.\r\n"
; 2516 :             ));
; 2517 :             goto WRITE_ERROR;

  00184	ea00019c	 b           |$WRITE_ERROR$40959|
  00188		 |$LN43@SDIPolling@2|

; 2518 :         }
; 2519 : 
; 2520 :         if( MMC_STAT & MMC_STAT_DCRC ) // DATA CRC Error

  00188	e1dd30b6	 ldrh        r3, [sp, #6]
  0018c	e3130040	 tst         r3, #0x40
  00190	0a000001	 beq         |$LN41@SDIPolling@2|
  00194	ea000198	 b           |$LN40@SDIPolling@2|

; 2521 :         {
; 2522 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2523 :                 L"Exit: MMC_CRC_ERROR_RCVD.\r\n"
; 2524 :             ));
; 2525 :             goto WRITE_ERROR;

  00198	ea000197	 b           |$WRITE_ERROR$40959|
  0019c		 |$LN41@SDIPolling@2|

; 2526 :         }
; 2527 : 
; 2528 :         if( MMC_STAT & MMC_STAT_DTO ) // DATA Response Timeout

  0019c	e1dd30b6	 ldrh        r3, [sp, #6]
  001a0	e3130020	 tst         r3, #0x20
  001a4	0a000001	 beq         |$LN39@SDIPolling@2|
  001a8	ea000193	 b           |$LN38@SDIPolling@2|

; 2529 :         {
; 2530 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2531 :                 L"Exit: MMC_TIME_OUT_RCVD.\r\n"
; 2532 :             ));
; 2533 :             goto WRITE_ERROR;

  001ac	ea000192	 b           |$WRITE_ERROR$40959|
  001b0		 |$LN39@SDIPolling@2|

; 2534 :         }
; 2535 : 
; 2536 :         if( MMC_STAT & MMC_STAT_CB ) // card in BUSY state

  001b0	e1dd30b6	 ldrh        r3, [sp, #6]
  001b4	e3130004	 tst         r3, #4
  001b8	0a00005e	 beq         |$LN37@SDIPolling@2|
  001bc		 |$LN36@SDIPolling@2|

; 2537 :         {
; 2538 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2539 :                 L"Card in busy state during data transfer!  Delaying...\r\n"
; 2540 :             ));
; 2541 :             do {
; 2542 :                 MMC_STAT = Read_MMC_STAT();

  001bc	e59d00b0	 ldr         r0, [sp, #0xB0]
  001c0	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  001c4	e1cd04b8	 strh        r0, [sp, #0x48]
  001c8	e1dd34b8	 ldrh        r3, [sp, #0x48]
  001cc	e1cd30b6	 strh        r3, [sp, #6]

; 2543 : 
; 2544 :                 if( !SDCardDetect() )

  001d0	e59d30b0	 ldr         r3, [sp, #0xB0]
  001d4	e5933000	 ldr         r3, [r3]
  001d8	e2833014	 add         r3, r3, #0x14
  001dc	e59d00b0	 ldr         r0, [sp, #0xB0]
  001e0	e5933000	 ldr         r3, [r3]
  001e4	e1a0e00f	 mov         lr, pc
  001e8	e12fff13	 bx          r3
  001ec	e58d004c	 str         r0, [sp, #0x4C]
  001f0	e59d304c	 ldr         r3, [sp, #0x4C]
  001f4	e3530000	 cmp         r3, #0
  001f8	1a000001	 bne         |$LN33@SDIPolling@2|
  001fc	ea00017e	 b           |$LN32@SDIPolling@2|

; 2545 :                 {
; 2546 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2547 :                         L"Exit: Card removed.\r\n"
; 2548 :                     ));
; 2549 :                     goto WRITE_ERROR;

  00200	ea00017d	 b           |$WRITE_ERROR$40959|
  00204		 |$LN33@SDIPolling@2|

; 2550 :                 }
; 2551 : 
; 2552 :                 // check for a timeout
; 2553 :                 dwCurrentTickCount = GetTickCount();

  00204	eb000000	 bl          GetTickCount
  00208	e58d0050	 str         r0, [sp, #0x50]
  0020c	e59d3050	 ldr         r3, [sp, #0x50]
  00210	e58d300c	 str         r3, [sp, #0xC]

; 2554 :                 if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 2555 :                     : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  00214	e59d3000	 ldr         r3, [sp]
  00218	e3530000	 cmp         r3, #0
  0021c	0a00000f	 beq         |$LN62@SDIPolling@2|
  00220	e59d2010	 ldr         r2, [sp, #0x10]
  00224	e59d300c	 ldr         r3, [sp, #0xC]
  00228	e1520003	 cmp         r2, r3
  0022c	2a000006	 bcs         |$LN58@SDIPolling@2|
  00230	e59d200c	 ldr         r2, [sp, #0xC]
  00234	e59d3008	 ldr         r3, [sp, #8]
  00238	e1520003	 cmp         r2, r3
  0023c	2a000002	 bcs         |$LN58@SDIPolling@2|
  00240	e3a03001	 mov         r3, #1
  00244	e58d3054	 str         r3, [sp, #0x54]
  00248	ea000001	 b           |$LN61@SDIPolling@2|
  0024c		 |$LN58@SDIPolling@2|
  0024c	e3a03000	 mov         r3, #0
  00250	e58d3054	 str         r3, [sp, #0x54]
  00254		 |$LN61@SDIPolling@2|
  00254	e59d3054	 ldr         r3, [sp, #0x54]
  00258	e58d3058	 str         r3, [sp, #0x58]
  0025c	ea00000e	 b           |$LN63@SDIPolling@2|
  00260		 |$LN62@SDIPolling@2|
  00260	e59d2010	 ldr         r2, [sp, #0x10]
  00264	e59d300c	 ldr         r3, [sp, #0xC]
  00268	e1520003	 cmp         r2, r3
  0026c	3a000006	 bcc         |$LN59@SDIPolling@2|
  00270	e59d200c	 ldr         r2, [sp, #0xC]
  00274	e59d3008	 ldr         r3, [sp, #8]
  00278	e1520003	 cmp         r2, r3
  0027c	3a000002	 bcc         |$LN59@SDIPolling@2|
  00280	e3a03000	 mov         r3, #0
  00284	e58d305c	 str         r3, [sp, #0x5C]
  00288	ea000001	 b           |$LN60@SDIPolling@2|
  0028c		 |$LN59@SDIPolling@2|
  0028c	e3a03001	 mov         r3, #1
  00290	e58d305c	 str         r3, [sp, #0x5C]
  00294		 |$LN60@SDIPolling@2|
  00294	e59d305c	 ldr         r3, [sp, #0x5C]
  00298	e58d3058	 str         r3, [sp, #0x58]
  0029c		 |$LN63@SDIPolling@2|
  0029c	e59d3058	 ldr         r3, [sp, #0x58]
  002a0	e3530000	 cmp         r3, #0
  002a4	0a000001	 beq         |$LN31@SDIPolling@2|
  002a8	ea000153	 b           |$LN30@SDIPolling@2|

; 2556 :                 {
; 2557 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2558 :                         L"Exit: TIMEOUT.\r\n"
; 2559 :                     ));
; 2560 :                     goto WRITE_ERROR;

  002ac	ea000152	 b           |$WRITE_ERROR$40959|
  002b0		 |$LN31@SDIPolling@2|

; 2561 :                 }
; 2562 : 
; 2563 :             } while( !( MMC_STAT & ( MMC_STAT_EOFB | MMC_STAT_DCRC | MMC_STAT_DTO ) ) );

  002b0	e1dd30b6	 ldrh        r3, [sp, #6]
  002b4	e3130070	 tst         r3, #0x70
  002b8	0affffbf	 beq         |$LN36@SDIPolling@2|

; 2564 : 
; 2565 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2566 :                 L"Card exited busy state.\r\n"
; 2567 :             ));
; 2568 :             ASSERT( MMC_STAT & MMC_STAT_EOFB );
; 2569 :             Write_MMC_STAT( MMC_STAT_CB | MMC_STAT_EOFB );

  002bc	e59d30b0	 ldr         r3, [sp, #0xB0]
  002c0	e2830014	 add         r0, r3, #0x14
  002c4	eb000000	 bl          EnterCriticalSection
  002c8	e59d30b0	 ldr         r3, [sp, #0xB0]
  002cc	e2833088	 add         r3, r3, #0x88
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e2832010	 add         r2, r3, #0x10
  002d8	e3a03014	 mov         r3, #0x14
  002dc	e1c230b0	 strh        r3, [r2]
  002e0	e59d30b0	 ldr         r3, [sp, #0xB0]
  002e4	e2830014	 add         r0, r3, #0x14
  002e8	eb000000	 bl          LeaveCriticalSection

; 2570 : 
; 2571 :             // recalculate timeout conditions
; 2572 :             dwCountStart = GetTickCount();

  002ec	eb000000	 bl          GetTickCount
  002f0	e58d0060	 str         r0, [sp, #0x60]
  002f4	e59d3060	 ldr         r3, [sp, #0x60]
  002f8	e58d3008	 str         r3, [sp, #8]

; 2573 :             dwTimeout = dwCountStart + m_dwMaxTimeout;

  002fc	e59d30b0	 ldr         r3, [sp, #0xB0]
  00300	e283307c	 add         r3, r3, #0x7C
  00304	e59d2008	 ldr         r2, [sp, #8]
  00308	e5933000	 ldr         r3, [r3]
  0030c	e0823003	 add         r3, r2, r3
  00310	e58d3010	 str         r3, [sp, #0x10]

; 2574 :             if( dwTimeout < dwCountStart )

  00314	e59d2010	 ldr         r2, [sp, #0x10]
  00318	e59d3008	 ldr         r3, [sp, #8]
  0031c	e1520003	 cmp         r2, r3
  00320	2a000002	 bcs         |$LN29@SDIPolling@2|

; 2575 :                 fTimeoutOverflow = TRUE;

  00324	e3a03001	 mov         r3, #1
  00328	e58d3000	 str         r3, [sp]

; 2576 :             else

  0032c	ea000001	 b           |$LN28@SDIPolling@2|
  00330		 |$LN29@SDIPolling@2|

; 2577 :                 fTimeoutOverflow = FALSE;

  00330	e3a03000	 mov         r3, #0
  00334	e58d3000	 str         r3, [sp]
  00338		 |$LN28@SDIPolling@2|
  00338		 |$LN37@SDIPolling@2|

; 2578 :         }
; 2579 : 
; 2580 :         if( MMC_STAT & MMC_STAT_AE ) // Almost empty

  00338	e1dd30b6	 ldrh        r3, [sp, #6]
  0033c	e3130b02	 tst         r3, #2, 22
  00340	0a00006f	 beq         |$LN27@SDIPolling@2|

; 2581 :         {
; 2582 :             Write_MMC_STAT(MMC_STAT_AE);

  00344	e59d30b0	 ldr         r3, [sp, #0xB0]
  00348	e2830014	 add         r0, r3, #0x14
  0034c	eb000000	 bl          EnterCriticalSection
  00350	e59d30b0	 ldr         r3, [sp, #0xB0]
  00354	e2833088	 add         r3, r3, #0x88
  00358	e5933000	 ldr         r3, [r3]
  0035c	e2832010	 add         r2, r3, #0x10
  00360	e3a03b02	 mov         r3, #2, 22
  00364	e1c230b0	 strh        r3, [r2]
  00368	e59d30b0	 ldr         r3, [sp, #0xB0]
  0036c	e2830014	 add         r0, r3, #0x14
  00370	eb000000	 bl          LeaveCriticalSection

; 2583 : 
; 2584 :             DWORD dwTransferSize = wFIFOAlmostEmptyLevel;

  00374	e1dd30b4	 ldrh        r3, [sp, #4]
  00378	e58d3014	 str         r3, [sp, #0x14]

; 2585 :             if( dwLen < dwTransferSize )

  0037c	e59d20b8	 ldr         r2, [sp, #0xB8]
  00380	e59d3014	 ldr         r3, [sp, #0x14]
  00384	e1520003	 cmp         r2, r3
  00388	2a000001	 bcs         |$LN26@SDIPolling@2|

; 2586 :             {
; 2587 :                 dwTransferSize = dwLen;

  0038c	e59d30b8	 ldr         r3, [sp, #0xB8]
  00390	e58d3014	 str         r3, [sp, #0x14]
  00394		 |$LN26@SDIPolling@2|

; 2588 :             }
; 2589 : 
; 2590 :             dwLen = dwLen - dwTransferSize;

  00394	e59d20b8	 ldr         r2, [sp, #0xB8]
  00398	e59d3014	 ldr         r3, [sp, #0x14]
  0039c	e0423003	 sub         r3, r2, r3
  003a0	e58d30b8	 str         r3, [sp, #0xB8]

; 2591 : 
; 2592 :             if( ((DWORD)pBuff) % 2 ) // if the data buffer is not aligned

  003a4	e59d10b4	 ldr         r1, [sp, #0xB4]
  003a8	e3a00002	 mov         r0, #2
  003ac	eb000000	 bl          __rt_udiv
  003b0	e3510000	 cmp         r1, #0
  003b4	0a00001e	 beq         |$LN25@SDIPolling@2|
  003b8		 |$LN24@SDIPolling@2|

; 2593 :             {
; 2594 :                 while( dwTransferSize > 1)

  003b8	e59d3014	 ldr         r3, [sp, #0x14]
  003bc	e3530001	 cmp         r3, #1
  003c0	9a00001a	 bls         |$LN23@SDIPolling@2|

; 2595 :                 {
; 2596 :                     BYTE bLo = *((BYTE*)pBuff);

  003c4	e59d30b4	 ldr         r3, [sp, #0xB4]
  003c8	e5d33000	 ldrb        r3, [r3]
  003cc	e5cd301a	 strb        r3, [sp, #0x1A]

; 2597 :                     BYTE bHi = *((BYTE*)pBuff + 1);

  003d0	e59d30b4	 ldr         r3, [sp, #0xB4]
  003d4	e2833001	 add         r3, r3, #1
  003d8	e5d33000	 ldrb        r3, [r3]
  003dc	e5cd301b	 strb        r3, [sp, #0x1B]

; 2598 :                     WORD wData = ( bHi << 8 ) | bLo; // assume little endian

  003e0	e5dd301b	 ldrb        r3, [sp, #0x1B]
  003e4	e1a02403	 mov         r2, r3, lsl #8
  003e8	e5dd301a	 ldrb        r3, [sp, #0x1A]
  003ec	e1823003	 orr         r3, r2, r3
  003f0	e1a03803	 mov         r3, r3, lsl #16
  003f4	e1a03823	 mov         r3, r3, lsr #16
  003f8	e1cd31b8	 strh        r3, [sp, #0x18]

; 2599 :                     OUTREG16(&m_vpSDIOReg->MMC_DATA, wData);

  003fc	e59d30b0	 ldr         r3, [sp, #0xB0]
  00400	e2833088	 add         r3, r3, #0x88
  00404	e5933000	 ldr         r3, [r3]
  00408	e2832020	 add         r2, r3, #0x20
  0040c	e1dd31b8	 ldrh        r3, [sp, #0x18]
  00410	e1c230b0	 strh        r3, [r2]

; 2600 :                     dwTransferSize -= 2;

  00414	e59d3014	 ldr         r3, [sp, #0x14]
  00418	e2433002	 sub         r3, r3, #2
  0041c	e58d3014	 str         r3, [sp, #0x14]

; 2601 :                     pBuff += 2;

  00420	e59d30b4	 ldr         r3, [sp, #0xB4]
  00424	e2833002	 add         r3, r3, #2
  00428	e58d30b4	 str         r3, [sp, #0xB4]

; 2602 :                 } // while

  0042c	eaffffe1	 b           |$LN24@SDIPolling@2|
  00430		 |$LN23@SDIPolling@2|

; 2603 :             }
; 2604 :             else

  00430	ea000010	 b           |$LN22@SDIPolling@2|
  00434		 |$LN25@SDIPolling@2|
  00434		 |$LN21@SDIPolling@2|

; 2605 :             {
; 2606 :                 while( dwTransferSize > 1)

  00434	e59d3014	 ldr         r3, [sp, #0x14]
  00438	e3530001	 cmp         r3, #1
  0043c	9a00000d	 bls         |$LN20@SDIPolling@2|

; 2607 :                 {
; 2608 :                     OUTREG16(&m_vpSDIOReg->MMC_DATA,*((WORD*)pBuff));

  00440	e59d30b0	 ldr         r3, [sp, #0xB0]
  00444	e2833088	 add         r3, r3, #0x88
  00448	e5933000	 ldr         r3, [r3]
  0044c	e2832020	 add         r2, r3, #0x20
  00450	e59d30b4	 ldr         r3, [sp, #0xB4]
  00454	e1d330b0	 ldrh        r3, [r3]
  00458	e1c230b0	 strh        r3, [r2]

; 2609 :                     dwTransferSize -= 2;

  0045c	e59d3014	 ldr         r3, [sp, #0x14]
  00460	e2433002	 sub         r3, r3, #2
  00464	e58d3014	 str         r3, [sp, #0x14]

; 2610 :                     pBuff += 2;

  00468	e59d30b4	 ldr         r3, [sp, #0xB4]
  0046c	e2833002	 add         r3, r3, #2
  00470	e58d30b4	 str         r3, [sp, #0xB4]

; 2611 :                 } // while

  00474	eaffffee	 b           |$LN21@SDIPolling@2|
  00478		 |$LN20@SDIPolling@2|
  00478		 |$LN22@SDIPolling@2|

; 2612 :             }
; 2613 :             if( dwTransferSize == 1 )

  00478	e59d3014	 ldr         r3, [sp, #0x14]
  0047c	e3530001	 cmp         r3, #1
  00480	1a00000c	 bne         |$LN19@SDIPolling@2|

; 2614 :             {
; 2615 :                 OUTREG16(&m_vpSDIOReg->MMC_DATA, (WORD)(*((BYTE*)pBuff)));

  00484	e59d30b4	 ldr         r3, [sp, #0xB4]
  00488	e5d32000	 ldrb        r2, [r3]
  0048c	e59d30b0	 ldr         r3, [sp, #0xB0]
  00490	e2833088	 add         r3, r3, #0x88
  00494	e5933000	 ldr         r3, [r3]
  00498	e2833020	 add         r3, r3, #0x20
  0049c	e1c320b0	 strh        r2, [r3]

; 2616 :                 dwTransferSize -= 1;

  004a0	e59d3014	 ldr         r3, [sp, #0x14]
  004a4	e2433001	 sub         r3, r3, #1
  004a8	e58d3014	 str         r3, [sp, #0x14]

; 2617 :                 pBuff += 1;

  004ac	e59d30b4	 ldr         r3, [sp, #0xB4]
  004b0	e2833001	 add         r3, r3, #1
  004b4	e58d30b4	 str         r3, [sp, #0xB4]
  004b8		 |$LN19@SDIPolling@2|

; 2618 :             }
; 2619 : 
; 2620 :             // recalculate timeout conditions
; 2621 :             dwCountStart = GetTickCount();

  004b8	eb000000	 bl          GetTickCount
  004bc	e58d0064	 str         r0, [sp, #0x64]
  004c0	e59d3064	 ldr         r3, [sp, #0x64]
  004c4	e58d3008	 str         r3, [sp, #8]

; 2622 :             dwTimeout = dwCountStart + m_dwMaxTimeout;

  004c8	e59d30b0	 ldr         r3, [sp, #0xB0]
  004cc	e283307c	 add         r3, r3, #0x7C
  004d0	e59d2008	 ldr         r2, [sp, #8]
  004d4	e5933000	 ldr         r3, [r3]
  004d8	e0823003	 add         r3, r2, r3
  004dc	e58d3010	 str         r3, [sp, #0x10]

; 2623 :             if( dwTimeout < dwCountStart )

  004e0	e59d2010	 ldr         r2, [sp, #0x10]
  004e4	e59d3008	 ldr         r3, [sp, #8]
  004e8	e1520003	 cmp         r2, r3
  004ec	2a000002	 bcs         |$LN18@SDIPolling@2|

; 2624 :                 fTimeoutOverflow = TRUE;

  004f0	e3a03001	 mov         r3, #1
  004f4	e58d3000	 str         r3, [sp]

; 2625 :             else

  004f8	ea000001	 b           |$LN17@SDIPolling@2|
  004fc		 |$LN18@SDIPolling@2|

; 2626 :                 fTimeoutOverflow = FALSE;

  004fc	e3a03000	 mov         r3, #0
  00500	e58d3000	 str         r3, [sp]
  00504		 |$LN17@SDIPolling@2|
  00504		 |$LN27@SDIPolling@2|

; 2627 :         }
; 2628 : 
; 2629 :         MMC_STAT = Read_MMC_STAT();

  00504	e59d00b0	 ldr         r0, [sp, #0xB0]
  00508	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  0050c	e1cd06b8	 strh        r0, [sp, #0x68]
  00510	e1dd36b8	 ldrh        r3, [sp, #0x68]
  00514	e1cd30b6	 strh        r3, [sp, #6]

; 2630 :     } // while

  00518	eafffedf	 b           |$LN47@SDIPolling@2|
  0051c		 |$LN46@SDIPolling@2|

; 2631 : 
; 2632 :     // recalculate timeout conditions
; 2633 :     dwCountStart = GetTickCount();

  0051c	eb000000	 bl          GetTickCount
  00520	e58d006c	 str         r0, [sp, #0x6C]
  00524	e59d306c	 ldr         r3, [sp, #0x6C]
  00528	e58d3008	 str         r3, [sp, #8]

; 2634 :     dwTimeout = dwCountStart + m_dwMaxTimeout;

  0052c	e59d30b0	 ldr         r3, [sp, #0xB0]
  00530	e283307c	 add         r3, r3, #0x7C
  00534	e59d2008	 ldr         r2, [sp, #8]
  00538	e5933000	 ldr         r3, [r3]
  0053c	e0823003	 add         r3, r2, r3
  00540	e58d3010	 str         r3, [sp, #0x10]

; 2635 :     if( dwTimeout < dwCountStart )

  00544	e59d2010	 ldr         r2, [sp, #0x10]
  00548	e59d3008	 ldr         r3, [sp, #8]
  0054c	e1520003	 cmp         r2, r3
  00550	2a000002	 bcs         |$LN16@SDIPolling@2|

; 2636 :         fTimeoutOverflow = TRUE;

  00554	e3a03001	 mov         r3, #1
  00558	e58d3000	 str         r3, [sp]

; 2637 :     else

  0055c	ea000001	 b           |$LN15@SDIPolling@2|
  00560		 |$LN16@SDIPolling@2|

; 2638 :         fTimeoutOverflow = FALSE;

  00560	e3a03000	 mov         r3, #0
  00564	e58d3000	 str         r3, [sp]
  00568		 |$LN15@SDIPolling@2|

; 2639 : 
; 2640 :     // Wait for data to be transmitted to the card
; 2641 :     MMC_STAT = Read_MMC_STAT();

  00568	e59d00b0	 ldr         r0, [sp, #0xB0]
  0056c	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00570	e1cd07b0	 strh        r0, [sp, #0x70]
  00574	e1dd37b0	 ldrh        r3, [sp, #0x70]
  00578	e1cd30b6	 strh        r3, [sp, #6]

; 2642 :     if( !( MMC_STAT & MMC_STAT_BRS ) )

  0057c	e1dd30b6	 ldrh        r3, [sp, #6]
  00580	e3130008	 tst         r3, #8
  00584	1a000041	 bne         |$LN14@SDIPolling@2|
  00588		 |$LN13@SDIPolling@2|

; 2643 :     {
; 2644 :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2645 :             L"Waiting for BRS bit...\r\n"
; 2646 :         ));
; 2647 : 
; 2648 :         while( !( MMC_STAT & MMC_STAT_BRS ) )

  00588	e1dd30b6	 ldrh        r3, [sp, #6]
  0058c	e3130008	 tst         r3, #8
  00590	1a00003e	 bne         |$LN12@SDIPolling@2|

; 2649 :         {
; 2650 :             if( !SDCardDetect() )

  00594	e59d30b0	 ldr         r3, [sp, #0xB0]
  00598	e5933000	 ldr         r3, [r3]
  0059c	e2833014	 add         r3, r3, #0x14
  005a0	e59d00b0	 ldr         r0, [sp, #0xB0]
  005a4	e5933000	 ldr         r3, [r3]
  005a8	e1a0e00f	 mov         lr, pc
  005ac	e12fff13	 bx          r3
  005b0	e58d0074	 str         r0, [sp, #0x74]
  005b4	e59d3074	 ldr         r3, [sp, #0x74]
  005b8	e3530000	 cmp         r3, #0
  005bc	1a000000	 bne         |$LN11@SDIPolling@2|

; 2651 :             {
; 2652 :                 break;

  005c0	ea000032	 b           |$LN12@SDIPolling@2|
  005c4		 |$LN11@SDIPolling@2|

; 2653 :             }
; 2654 : 
; 2655 :             // check for a timeout
; 2656 :             dwCurrentTickCount = GetTickCount();

  005c4	eb000000	 bl          GetTickCount
  005c8	e58d0078	 str         r0, [sp, #0x78]
  005cc	e59d3078	 ldr         r3, [sp, #0x78]
  005d0	e58d300c	 str         r3, [sp, #0xC]

; 2657 :             if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 2658 :                 : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  005d4	e59d3000	 ldr         r3, [sp]
  005d8	e3530000	 cmp         r3, #0
  005dc	0a00000f	 beq         |$LN68@SDIPolling@2|
  005e0	e59d2010	 ldr         r2, [sp, #0x10]
  005e4	e59d300c	 ldr         r3, [sp, #0xC]
  005e8	e1520003	 cmp         r2, r3
  005ec	2a000006	 bcs         |$LN64@SDIPolling@2|
  005f0	e59d200c	 ldr         r2, [sp, #0xC]
  005f4	e59d3008	 ldr         r3, [sp, #8]
  005f8	e1520003	 cmp         r2, r3
  005fc	2a000002	 bcs         |$LN64@SDIPolling@2|
  00600	e3a03001	 mov         r3, #1
  00604	e58d307c	 str         r3, [sp, #0x7C]
  00608	ea000001	 b           |$LN67@SDIPolling@2|
  0060c		 |$LN64@SDIPolling@2|
  0060c	e3a03000	 mov         r3, #0
  00610	e58d307c	 str         r3, [sp, #0x7C]
  00614		 |$LN67@SDIPolling@2|
  00614	e59d307c	 ldr         r3, [sp, #0x7C]
  00618	e58d3080	 str         r3, [sp, #0x80]
  0061c	ea00000e	 b           |$LN69@SDIPolling@2|
  00620		 |$LN68@SDIPolling@2|
  00620	e59d2010	 ldr         r2, [sp, #0x10]
  00624	e59d300c	 ldr         r3, [sp, #0xC]
  00628	e1520003	 cmp         r2, r3
  0062c	3a000006	 bcc         |$LN65@SDIPolling@2|
  00630	e59d200c	 ldr         r2, [sp, #0xC]
  00634	e59d3008	 ldr         r3, [sp, #8]
  00638	e1520003	 cmp         r2, r3
  0063c	3a000002	 bcc         |$LN65@SDIPolling@2|
  00640	e3a03000	 mov         r3, #0
  00644	e58d3084	 str         r3, [sp, #0x84]
  00648	ea000001	 b           |$LN66@SDIPolling@2|
  0064c		 |$LN65@SDIPolling@2|
  0064c	e3a03001	 mov         r3, #1
  00650	e58d3084	 str         r3, [sp, #0x84]
  00654		 |$LN66@SDIPolling@2|
  00654	e59d3084	 ldr         r3, [sp, #0x84]
  00658	e58d3080	 str         r3, [sp, #0x80]
  0065c		 |$LN69@SDIPolling@2|
  0065c	e59d3080	 ldr         r3, [sp, #0x80]
  00660	e3530000	 cmp         r3, #0
  00664	0a000001	 beq         |$LN10@SDIPolling@2|
  00668	ea000063	 b           |$LN9@SDIPolling@2|

; 2659 :             {
; 2660 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2661 :                     L"Exit: TIMEOUT.\r\n"
; 2662 :                 ));
; 2663 :                 goto WRITE_ERROR;

  0066c	ea000062	 b           |$WRITE_ERROR$40959|
  00670		 |$LN10@SDIPolling@2|

; 2664 :             }
; 2665 : 
; 2666 :             Sleep(1);

  00670	e3a00001	 mov         r0, #1
  00674	eb000000	 bl          Sleep

; 2667 :             MMC_STAT = Read_MMC_STAT();

  00678	e59d00b0	 ldr         r0, [sp, #0xB0]
  0067c	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00680	e1cd08b8	 strh        r0, [sp, #0x88]
  00684	e1dd38b8	 ldrh        r3, [sp, #0x88]
  00688	e1cd30b6	 strh        r3, [sp, #6]

; 2668 :         }

  0068c	eaffffbd	 b           |$LN13@SDIPolling@2|
  00690		 |$LN12@SDIPolling@2|
  00690		 |$LN14@SDIPolling@2|

; 2669 :         DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2670 :             L"Got the BRS bit.\r\n"
; 2671 :         ));
; 2672 :     }
; 2673 : 
; 2674 :     // recalculate timeout conditions
; 2675 :     dwCountStart = GetTickCount();

  00690	eb000000	 bl          GetTickCount
  00694	e58d008c	 str         r0, [sp, #0x8C]
  00698	e59d308c	 ldr         r3, [sp, #0x8C]
  0069c	e58d3008	 str         r3, [sp, #8]

; 2676 :     dwTimeout = dwCountStart + m_dwMaxTimeout;

  006a0	e59d30b0	 ldr         r3, [sp, #0xB0]
  006a4	e283307c	 add         r3, r3, #0x7C
  006a8	e59d2008	 ldr         r2, [sp, #8]
  006ac	e5933000	 ldr         r3, [r3]
  006b0	e0823003	 add         r3, r2, r3
  006b4	e58d3010	 str         r3, [sp, #0x10]

; 2677 :     if( dwTimeout < dwCountStart )

  006b8	e59d2010	 ldr         r2, [sp, #0x10]
  006bc	e59d3008	 ldr         r3, [sp, #8]
  006c0	e1520003	 cmp         r2, r3
  006c4	2a000002	 bcs         |$LN8@SDIPolling@2|

; 2678 :         fTimeoutOverflow = TRUE;

  006c8	e3a03001	 mov         r3, #1
  006cc	e58d3000	 str         r3, [sp]

; 2679 :     else

  006d0	ea000001	 b           |$LN7@SDIPolling@2|
  006d4		 |$LN8@SDIPolling@2|

; 2680 :         fTimeoutOverflow = FALSE;

  006d4	e3a03000	 mov         r3, #0
  006d8	e58d3000	 str         r3, [sp]
  006dc		 |$LN7@SDIPolling@2|

; 2681 : 
; 2682 :     // Wait for card if it is busy?
; 2683 :     if( MMC_STAT & MMC_STAT_CB )

  006dc	e1dd30b6	 ldrh        r3, [sp, #6]
  006e0	e3130004	 tst         r3, #4
  006e4	0a000041	 beq         |$LN6@SDIPolling@2|
  006e8		 |$LN5@SDIPolling@2|

; 2684 :     {
; 2685 :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2686 :             L"Card in busy state after data transfer!  Delaying...\r\n"
; 2687 :         ));
; 2688 : 
; 2689 :         while( !(MMC_STAT & MMC_STAT_EOFB) )

  006e8	e1dd30b6	 ldrh        r3, [sp, #6]
  006ec	e3130010	 tst         r3, #0x10
  006f0	1a00003e	 bne         |$LN4@SDIPolling@2|

; 2690 :         {
; 2691 :             if( !SDCardDetect() )

  006f4	e59d30b0	 ldr         r3, [sp, #0xB0]
  006f8	e5933000	 ldr         r3, [r3]
  006fc	e2833014	 add         r3, r3, #0x14
  00700	e59d00b0	 ldr         r0, [sp, #0xB0]
  00704	e5933000	 ldr         r3, [r3]
  00708	e1a0e00f	 mov         lr, pc
  0070c	e12fff13	 bx          r3
  00710	e58d0090	 str         r0, [sp, #0x90]
  00714	e59d3090	 ldr         r3, [sp, #0x90]
  00718	e3530000	 cmp         r3, #0
  0071c	1a000000	 bne         |$LN3@SDIPolling@2|

; 2692 :             {
; 2693 :                 break;

  00720	ea000032	 b           |$LN4@SDIPolling@2|
  00724		 |$LN3@SDIPolling@2|

; 2694 :             }
; 2695 : 
; 2696 :             // check for a timeout
; 2697 :             dwCurrentTickCount = GetTickCount();

  00724	eb000000	 bl          GetTickCount
  00728	e58d0094	 str         r0, [sp, #0x94]
  0072c	e59d3094	 ldr         r3, [sp, #0x94]
  00730	e58d300c	 str         r3, [sp, #0xC]

; 2698 :             if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 2699 :                 : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  00734	e59d3000	 ldr         r3, [sp]
  00738	e3530000	 cmp         r3, #0
  0073c	0a00000f	 beq         |$LN74@SDIPolling@2|
  00740	e59d2010	 ldr         r2, [sp, #0x10]
  00744	e59d300c	 ldr         r3, [sp, #0xC]
  00748	e1520003	 cmp         r2, r3
  0074c	2a000006	 bcs         |$LN70@SDIPolling@2|
  00750	e59d200c	 ldr         r2, [sp, #0xC]
  00754	e59d3008	 ldr         r3, [sp, #8]
  00758	e1520003	 cmp         r2, r3
  0075c	2a000002	 bcs         |$LN70@SDIPolling@2|
  00760	e3a03001	 mov         r3, #1
  00764	e58d3098	 str         r3, [sp, #0x98]
  00768	ea000001	 b           |$LN73@SDIPolling@2|
  0076c		 |$LN70@SDIPolling@2|
  0076c	e3a03000	 mov         r3, #0
  00770	e58d3098	 str         r3, [sp, #0x98]
  00774		 |$LN73@SDIPolling@2|
  00774	e59d3098	 ldr         r3, [sp, #0x98]
  00778	e58d309c	 str         r3, [sp, #0x9C]
  0077c	ea00000e	 b           |$LN75@SDIPolling@2|
  00780		 |$LN74@SDIPolling@2|
  00780	e59d2010	 ldr         r2, [sp, #0x10]
  00784	e59d300c	 ldr         r3, [sp, #0xC]
  00788	e1520003	 cmp         r2, r3
  0078c	3a000006	 bcc         |$LN71@SDIPolling@2|
  00790	e59d200c	 ldr         r2, [sp, #0xC]
  00794	e59d3008	 ldr         r3, [sp, #8]
  00798	e1520003	 cmp         r2, r3
  0079c	3a000002	 bcc         |$LN71@SDIPolling@2|
  007a0	e3a03000	 mov         r3, #0
  007a4	e58d30a0	 str         r3, [sp, #0xA0]
  007a8	ea000001	 b           |$LN72@SDIPolling@2|
  007ac		 |$LN71@SDIPolling@2|
  007ac	e3a03001	 mov         r3, #1
  007b0	e58d30a0	 str         r3, [sp, #0xA0]
  007b4		 |$LN72@SDIPolling@2|
  007b4	e59d30a0	 ldr         r3, [sp, #0xA0]
  007b8	e58d309c	 str         r3, [sp, #0x9C]
  007bc		 |$LN75@SDIPolling@2|
  007bc	e59d309c	 ldr         r3, [sp, #0x9C]
  007c0	e3530000	 cmp         r3, #0
  007c4	0a000001	 beq         |$LN2@SDIPolling@2|
  007c8	ea00000b	 b           |$LN1@SDIPolling@2|

; 2700 :             {
; 2701 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2702 :                     L"Exit: TIMEOUT.\r\n"
; 2703 :                 ));
; 2704 :                 goto WRITE_ERROR;

  007cc	ea00000a	 b           |$WRITE_ERROR$40959|
  007d0		 |$LN2@SDIPolling@2|

; 2705 :             }
; 2706 : 
; 2707 :             Sleep(1);

  007d0	e3a00001	 mov         r0, #1
  007d4	eb000000	 bl          Sleep

; 2708 :             MMC_STAT = Read_MMC_STAT();

  007d8	e59d00b0	 ldr         r0, [sp, #0xB0]
  007dc	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  007e0	e1cd0ab4	 strh        r0, [sp, #0xA4]
  007e4	e1dd3ab4	 ldrh        r3, [sp, #0xA4]
  007e8	e1cd30b6	 strh        r3, [sp, #6]

; 2709 :         } 

  007ec	eaffffbd	 b           |$LN5@SDIPolling@2|
  007f0		 |$LN4@SDIPolling@2|
  007f0		 |$LN6@SDIPolling@2|

; 2710 :         DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::SDIPollingTransmit: "
; 2711 :             L"Card exited busy state!\r\n"
; 2712 :         ));
; 2713 :     }
; 2714 : 
; 2715 :     return TRUE;

  007f0	e3a03001	 mov         r3, #1
  007f4	e58d3028	 str         r3, [sp, #0x28]
  007f8	ea000001	 b           |$LN50@SDIPolling@2|
  007fc		 |$LN1@SDIPolling@2|
  007fc		 |$LN9@SDIPolling@2|
  007fc		 |$LN30@SDIPolling@2|
  007fc		 |$LN32@SDIPolling@2|
  007fc		 |$LN38@SDIPolling@2|
  007fc		 |$LN40@SDIPolling@2|
  007fc		 |$LN42@SDIPolling@2|
  007fc		 |$LN44@SDIPolling@2|
  007fc		 |$WRITE_ERROR$40959|

; 2716 : 
; 2717 : WRITE_ERROR:
; 2718 :     return FALSE;

  007fc	e3a03000	 mov         r3, #0
  00800	e58d3028	 str         r3, [sp, #0x28]
  00804		 |$LN50@SDIPolling@2|

; 2719 : }

  00804	e59d0028	 ldr         r0, [sp, #0x28]
  00808	e28dd0a8	 add         sp, sp, #0xA8
  0080c	e89d6000	 ldmia       sp, {sp, lr}
  00810	e12fff1e	 bx          lr
  00814		 |$M42404|

			 ENDP  ; |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDIPollingTransmit

	EXPORT	|?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|	; CReg::Open
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T42421| DCD	|$LN10@Open|
	DCD	0x40002804
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z| PROC ; CReg::Open

; 49   : 	BOOL Open(HKEY hkRoot, LPCTSTR pszKey, REGSAM sam=KEY_READ) {

  00000		 |$LN10@Open|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M42418|

; 50   : 		Reset();

  00010	e59d301c	 ldr         r3, [sp, #0x1C]
  00014	e5933000	 ldr         r3, [r3]
  00018	e3530000	 cmp         r3, #0
  0001c	0a000005	 beq         |$LN5@Open|
  00020	e59d301c	 ldr         r3, [sp, #0x1C]
  00024	e5930000	 ldr         r0, [r3]
  00028	eb000000	 bl          RegCloseKey
  0002c	e59d201c	 ldr         r2, [sp, #0x1C]
  00030	e3a03000	 mov         r3, #0
  00034	e5823000	 str         r3, [r2]
  00038		 |$LN5@Open|
  00038	e59d301c	 ldr         r3, [sp, #0x1C]
  0003c	e2832004	 add         r2, r3, #4
  00040	e3a03000	 mov         r3, #0
  00044	e5823000	 str         r3, [r2]

; 51   : 		return ERROR_SUCCESS==RegOpenKeyEx(hkRoot, pszKey, 0, sam, &m_hKey);

  00048	e59d301c	 ldr         r3, [sp, #0x1C]
  0004c	e58d3000	 str         r3, [sp]
  00050	e59d3028	 ldr         r3, [sp, #0x28]
  00054	e3a02000	 mov         r2, #0
  00058	e59d1024	 ldr         r1, [sp, #0x24]
  0005c	e59d0020	 ldr         r0, [sp, #0x20]
  00060	eb000000	 bl          RegOpenKeyExW
  00064	e58d000c	 str         r0, [sp, #0xC]
  00068	e59d300c	 ldr         r3, [sp, #0xC]
  0006c	e3530000	 cmp         r3, #0
  00070	1a000002	 bne         |$LN3@Open|
  00074	e3a03001	 mov         r3, #1
  00078	e58d3010	 str         r3, [sp, #0x10]
  0007c	ea000001	 b           |$LN4@Open|
  00080		 |$LN3@Open|
  00080	e3a03000	 mov         r3, #0
  00084	e58d3010	 str         r3, [sp, #0x10]
  00088		 |$LN4@Open|
  00088	e59d3010	 ldr         r3, [sp, #0x10]
  0008c	e58d3008	 str         r3, [sp, #8]

; 52   : 	}

  00090	e59d0008	 ldr         r0, [sp, #8]
  00094	e28dd014	 add         sp, sp, #0x14
  00098	e89d6000	 ldmia       sp, {sp, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M42419|

			 ENDP  ; |?Open@CReg@@QAAHPAUHKEY__@@PBGK@Z|, CReg::Open

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T42429| DCD	|$LN6@scalar|
	DCD	0x40001104
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCSDIOControllerBase@@UAAPAXI@Z| PROC ; CSDIOControllerBase::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M42426|
  00010	e59d000c	 ldr         r0, [sp, #0xC]
  00014	eb000000	 bl          |??1CSDIOControllerBase@@UAA@XZ|
  00018	e59d3010	 ldr         r3, [sp, #0x10]
  0001c	e3130001	 tst         r3, #1
  00020	0a000001	 beq         |$LN1@scalar|
  00024	e59d000c	 ldr         r0, [sp, #0xC]
  00028	eb000000	 bl          |??3@YAXPAX@Z|
  0002c		 |$LN1@scalar|
  0002c	e59d300c	 ldr         r3, [sp, #0xC]
  00030	e58d3000	 str         r3, [sp]
  00034	e59d0000	 ldr         r0, [sp]
  00038	e28dd004	 add         sp, sp, #4
  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42427|

			 ENDP  ; |??_GCSDIOControllerBase@@UAAPAXI@Z|, CSDIOControllerBase::`scalar deleting destructor'

	EXPORT	|?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE@@@Z| ; CSDIOControllerBase::SetInterface
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T42436| DCD	|$LN9@SetInterfa|
	DCD	0x40003804
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE@@@Z| PROC ; CSDIOControllerBase::SetInterface

; 269  : {            

  00000		 |$LN9@SetInterfa|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M42433|

; 270  :     DEBUGCHK(pInterface);
; 271  : 
; 272  :     WORD wRegValue;
; 273  : 
; 274  :     if (SD_INTERFACE_SD_MMC_1BIT == pInterface->InterfaceMode) 

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e5933000	 ldr         r3, [r3]
  00018	e3530000	 cmp         r3, #0
  0001c	1a000011	 bne         |$LN4@SetInterfa|

; 275  :     {
; 276  :         DEBUGMSG(SDCARD_ZONE_INIT, (L"CSDIOControllerBase::SetInterface: "
; 277  :             L"Setting for 1 bit mode\r\n"
; 278  :         ));
; 279  :         wRegValue = INREG16(&m_vpSDIOReg->MMC_CON);

  00020	e59d300c	 ldr         r3, [sp, #0xC]
  00024	e2833088	 add         r3, r3, #0x88
  00028	e5933000	 ldr         r3, [r3]
  0002c	e283300c	 add         r3, r3, #0xC
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e1cd30b0	 strh        r3, [sp]

; 280  :         OUTREG16(&m_vpSDIOReg->MMC_CON, (wRegValue & (~VALUE_MMC_CON_DW_4BIT)));

  00038	e1dd30b0	 ldrh        r3, [sp]
  0003c	e1a02003	 mov         r2, r3
  00040	e3e03902	 mvn         r3, #2, 18
  00044	e0023003	 and         r3, r2, r3
  00048	e1a02803	 mov         r2, r3, lsl #16
  0004c	e1a02822	 mov         r2, r2, lsr #16
  00050	e59d300c	 ldr         r3, [sp, #0xC]
  00054	e2833088	 add         r3, r3, #0x88
  00058	e5933000	 ldr         r3, [r3]
  0005c	e283300c	 add         r3, r3, #0xC
  00060	e1c320b0	 strh        r2, [r3]
  00064	ea000012	 b           |$LN3@SetInterfa|
  00068		 |$LN4@SetInterfa|

; 281  : 
; 282  :         DEBUGMSG(SDCARD_ZONE_INIT, (L"CSDIOControllerBase::SetInterface: "
; 283  :             L"MMC1_CON value = %X\r\n", INREG16(&m_vpSDIOReg->MMC_CON)
; 284  :         ));
; 285  :     } 
; 286  :     else if (SD_INTERFACE_SD_4BIT == pInterface->InterfaceMode) 

  00068	e59d3010	 ldr         r3, [sp, #0x10]
  0006c	e5933000	 ldr         r3, [r3]
  00070	e3530001	 cmp         r3, #1
  00074	1a00000e	 bne         |$LN2@SetInterfa|

; 287  :     {
; 288  :         DEBUGMSG(SDCARD_ZONE_INIT, (L"CSDIOControllerBase::SetInterface: "
; 289  :             L"Setting for 4 bit mode \r\n"
; 290  :         ));
; 291  :         wRegValue = INREG16(&m_vpSDIOReg->MMC_CON);

  00078	e59d300c	 ldr         r3, [sp, #0xC]
  0007c	e2833088	 add         r3, r3, #0x88
  00080	e5933000	 ldr         r3, [r3]
  00084	e283300c	 add         r3, r3, #0xC
  00088	e1d330b0	 ldrh        r3, [r3]
  0008c	e1cd30b0	 strh        r3, [sp]

; 292  :         OUTREG16(&m_vpSDIOReg->MMC_CON, (wRegValue | (VALUE_MMC_CON_DW_4BIT)));

  00090	e1dd30b0	 ldrh        r3, [sp]
  00094	e3833902	 orr         r3, r3, #2, 18
  00098	e1a02803	 mov         r2, r3, lsl #16
  0009c	e1a02822	 mov         r2, r2, lsr #16
  000a0	e59d300c	 ldr         r3, [sp, #0xC]
  000a4	e2833088	 add         r3, r3, #0x88
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e283300c	 add         r3, r3, #0xC
  000b0	e1c320b0	 strh        r2, [r3]
  000b4		 |$LN2@SetInterfa|
  000b4		 |$LN3@SetInterfa|

; 293  : 
; 294  :         DEBUGMSG(SDCARD_ZONE_INIT, (L"CSDIOControllerBase::SetInterface: "
; 295  :             L"MMC1_CON value = %X\r\n", INREG16(&m_vpSDIOReg->MMC_CON)
; 296  :         ));
; 297  :     } 
; 298  :     else 
; 299  :     {
; 300  :         DEBUGCHK(FALSE);
; 301  :     }
; 302  : 
; 303  :     ClockOff();

  000b4	e59d000c	 ldr         r0, [sp, #0xC]
  000b8	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 304  :     SetClockRate(&pInterface->ClockRate);

  000bc	e59d3010	 ldr         r3, [sp, #0x10]
  000c0	e2831004	 add         r1, r3, #4
  000c4	e59d000c	 ldr         r0, [sp, #0xC]
  000c8	eb000000	 bl          |?SetClockRate@CSDIOControllerBase@@QAAXPAK@Z|

; 305  :     ClockOn();

  000cc	e59d000c	 ldr         r0, [sp, #0xC]
  000d0	eb000000	 bl          |?ClockOn@CSDIOControllerBase@@QAAXXZ|

; 306  : }

  000d4	e28dd004	 add         sp, sp, #4
  000d8	e89d6000	 ldmia       sp, {sp, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M42434|

			 ENDP  ; |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE@@@Z|, CSDIOControllerBase::SetInterface

	EXPORT	|?Init@CSDIOControllerBase@@QAAHPBG@Z|	; CSDIOControllerBase::Init
	IMPORT	|SDHCDRegisterHostController|
	IMPORT	|MmMapIoSpace|
	IMPORT	|SDHCDAllocateContext|
	IMPORT	|OpenDeviceKey|
; File c:\wince600\public\common\sdk\inc\creg.hxx

  00000			 AREA	 |.pdata|, PDATA
|$T42472| DCD	|$LN41@Init|
	DCD	0x4000eb04
; Function compile flags: /Odsp
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@CSDIOControllerBase@@QAAHPBG@Z| PROC ; CSDIOControllerBase::Init

; 747  : {

  00000		 |$LN41@Init|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd068	 sub         sp, sp, #0x68
  00010		 |$M42469|

; 748  :     PSDCARD_HC_CONTEXT pHostContext = NULL; // new HC context

  00010	e3a03000	 mov         r3, #0
  00014	e58d3028	 str         r3, [sp, #0x28]

; 749  :     SD_API_STATUS      status;              // SD status
; 750  :     HKEY               hKeyDevice = NULL;   // device key

  00018	e3a03000	 mov         r3, #0
  0001c	e58d3030	 str         r3, [sp, #0x30]

; 751  :     CReg               regDevice;           // encapsulated device key

  00020	e3a03000	 mov         r3, #0
  00024	e58d3014	 str         r3, [sp, #0x14]
  00028	e28d3014	 add         r3, sp, #0x14
  0002c	e2832004	 add         r2, r3, #4
  00030	e3a03000	 mov         r3, #0
  00034	e5823000	 str         r3, [r2]
  00038	e28d3014	 add         r3, sp, #0x14
  0003c	e2832008	 add         r2, r3, #8
  00040	e3a03000	 mov         r3, #0
  00044	e5823000	 str         r3, [r2]
  00048	e28d3014	 add         r3, sp, #0x14
  0004c	e283200c	 add         r2, r3, #0xC
  00050	e3a03000	 mov         r3, #0
  00054	e5823000	 str         r3, [r2]

; 752  :     DWORD              dwRet = 0;           // return value    

  00058	e3a03000	 mov         r3, #0
  0005c	e58d3004	 str         r3, [sp, #4]

; 753  :     BOOL               fRegisteredWithBusDriver = FALSE;

  00060	e3a03000	 mov         r3, #0
  00064	e58d3008	 str         r3, [sp, #8]

; 754  :     BOOL               fHardwareInitialized = FALSE;

  00068	e3a03000	 mov         r3, #0
  0006c	e58d3024	 str         r3, [sp, #0x24]

; 755  :     PHYSICAL_ADDRESS   pa;
; 756  :     
; 757  :     DEBUGMSG(SDCARD_ZONE_INIT, (L"+CSDIOControllerBase::Init: "
; 758  :         L"Active RegPath: %s\r\n", pszActiveKey
; 759  :     ));
; 760  :    
; 761  :     m_pCurrentRequest = NULL;

  00070	e59d3070	 ldr         r3, [sp, #0x70]
  00074	e2832090	 add         r2, r3, #0x90
  00078	e3a03000	 mov         r3, #0
  0007c	e5823000	 str         r3, [r2]

; 762  :     m_pszActiveKey = pszActiveKey; //save the activity key for power mgt

  00080	e59d3070	 ldr         r3, [sp, #0x70]
  00084	e283200c	 add         r2, r3, #0xC
  00088	e59d3074	 ldr         r3, [sp, #0x74]
  0008c	e5823000	 str         r3, [r2]

; 763  :     
; 764  :     hKeyDevice = OpenDeviceKey(pszActiveKey);

  00090	e59d0074	 ldr         r0, [sp, #0x74]
  00094	eb000000	 bl          OpenDeviceKey
  00098	e58d0040	 str         r0, [sp, #0x40]
  0009c	e59d3040	 ldr         r3, [sp, #0x40]
  000a0	e58d3030	 str         r3, [sp, #0x30]

; 765  :     if ( (hKeyDevice == NULL) || !regDevice.Open(hKeyDevice, NULL) ) {

  000a4	e59d3030	 ldr         r3, [sp, #0x30]
  000a8	e3530000	 cmp         r3, #0
  000ac	0a00001e	 beq         |$LN18@Init|
  000b0	e59d3014	 ldr         r3, [sp, #0x14]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000003	 beq         |$LN30@Init|
  000bc	e59d0014	 ldr         r0, [sp, #0x14]
  000c0	eb000000	 bl          RegCloseKey
  000c4	e3a03000	 mov         r3, #0
  000c8	e58d3014	 str         r3, [sp, #0x14]
  000cc		 |$LN30@Init|
  000cc	e28d3014	 add         r3, sp, #0x14
  000d0	e2832004	 add         r2, r3, #4
  000d4	e3a03000	 mov         r3, #0
  000d8	e5823000	 str         r3, [r2]
  000dc	e28d3014	 add         r3, sp, #0x14
  000e0	e58d3000	 str         r3, [sp]
  000e4	e3a03802	 mov         r3, #2, 16
  000e8	e3833019	 orr         r3, r3, #0x19
  000ec	e3a02000	 mov         r2, #0
  000f0	e3a01000	 mov         r1, #0
  000f4	e59d0030	 ldr         r0, [sp, #0x30]
  000f8	eb000000	 bl          RegOpenKeyExW
  000fc	e58d0044	 str         r0, [sp, #0x44]
  00100	e59d3044	 ldr         r3, [sp, #0x44]
  00104	e3530000	 cmp         r3, #0
  00108	1a000002	 bne         |$LN28@Init|
  0010c	e3a03001	 mov         r3, #1
  00110	e58d3048	 str         r3, [sp, #0x48]
  00114	ea000001	 b           |$LN29@Init|
  00118		 |$LN28@Init|
  00118	e3a03000	 mov         r3, #0
  0011c	e58d3048	 str         r3, [sp, #0x48]
  00120		 |$LN29@Init|
  00120	e59d3048	 ldr         r3, [sp, #0x48]
  00124	e3530000	 cmp         r3, #0
  00128	1a000000	 bne         |$LN19@Init|
  0012c		 |$LN18@Init|

; 766  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 767  :             L"Failed to open device key\r\n"
; 768  :         ));
; 769  :         goto EXIT;

  0012c	ea000083	 b           |$EXIT$40292|
  00130		 |$LN19@Init|

; 770  :     }
; 771  : 
; 772  :     // allocate the context - support for 2 Slots - BUT 1 controller
; 773  :     status = SDHCDAllocateContext(1, &m_pHCContext);

  00130	e59d3070	 ldr         r3, [sp, #0x70]
  00134	e2831004	 add         r1, r3, #4
  00138	e3a00001	 mov         r0, #1
  0013c	eb000000	 bl          SDHCDAllocateContext
  00140	e58d004c	 str         r0, [sp, #0x4C]
  00144	e59d304c	 ldr         r3, [sp, #0x4C]
  00148	e58d302c	 str         r3, [sp, #0x2C]

; 774  :     if (!SD_API_SUCCESS(status)) {

  0014c	e59d302c	 ldr         r3, [sp, #0x2C]
  00150	e3530000	 cmp         r3, #0
  00154	aa000000	 bge         |$LN16@Init|

; 775  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 776  :             L"Failed to allocate context : 0x%08X\r\n",
; 777  :             status
; 778  :         ));
; 779  :         goto EXIT;

  00158	ea000078	 b           |$EXIT$40292|
  0015c		 |$LN16@Init|

; 780  :     }
; 781  : 
; 782  :     // Set our extension
; 783  :     m_pHCContext->pHCSpecificContext = this;

  0015c	e59d3070	 ldr         r3, [sp, #0x70]
  00160	e2833004	 add         r3, r3, #4
  00164	e5933000	 ldr         r3, [r3]
  00168	e283204c	 add         r2, r3, #0x4C
  0016c	e59d3070	 ldr         r3, [sp, #0x70]
  00170	e5823000	 str         r3, [r2]

; 784  : 
; 785  :     if( !GetRegistrySettings(&regDevice) )

  00174	e28d1014	 add         r1, sp, #0x14
  00178	e59d3070	 ldr         r3, [sp, #0x70]
  0017c	e5933000	 ldr         r3, [r3]
  00180	e2833024	 add         r3, r3, #0x24
  00184	e59d0070	 ldr         r0, [sp, #0x70]
  00188	e5933000	 ldr         r3, [r3]
  0018c	e1a0e00f	 mov         lr, pc
  00190	e12fff13	 bx          r3
  00194	e58d0050	 str         r0, [sp, #0x50]
  00198	e59d3050	 ldr         r3, [sp, #0x50]
  0019c	e3530000	 cmp         r3, #0
  001a0	1a000002	 bne         |$LN14@Init|

; 786  :     {
; 787  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 788  :             L"Error reading registry settings\r\n"
; 789  :         ));
; 790  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  001a4	e3a0313b	 mov         r3, #0x3B, 2
  001a8	e58d302c	 str         r3, [sp, #0x2C]

; 791  :         goto EXIT;

  001ac	ea000063	 b           |$EXIT$40292|
  001b0		 |$LN14@Init|

; 792  :     }
; 793  : 
; 794  :     // map hardware memory space
; 795  :     pa.QuadPart = OMAP2420_MSDI1_REGS_PA;

  001b0	e3a03312	 mov         r3, #0x12, 6
  001b4	e3833927	 orr         r3, r3, #0x27, 18
  001b8	e58d300c	 str         r3, [sp, #0xC]
  001bc	e3a03000	 mov         r3, #0
  001c0	e58d3010	 str         r3, [sp, #0x10]

; 796  :     m_vpSDIOReg = (OMAP2420_SDIO_REGS*)MmMapIoSpace( pa, sizeof(OMAP2420_SDIO_REGS), FALSE );

  001c4	e3a03000	 mov         r3, #0
  001c8	e3a0206a	 mov         r2, #0x6A
  001cc	e59d000c	 ldr         r0, [sp, #0xC]
  001d0	e59d1010	 ldr         r1, [sp, #0x10]
  001d4	eb000000	 bl          MmMapIoSpace
  001d8	e58d0054	 str         r0, [sp, #0x54]
  001dc	e59d3070	 ldr         r3, [sp, #0x70]
  001e0	e2832088	 add         r2, r3, #0x88
  001e4	e59d3054	 ldr         r3, [sp, #0x54]
  001e8	e5823000	 str         r3, [r2]

; 797  :     if ( !m_vpSDIOReg )

  001ec	e59d3070	 ldr         r3, [sp, #0x70]
  001f0	e2833088	 add         r3, r3, #0x88
  001f4	e5933000	 ldr         r3, [r3]
  001f8	e3530000	 cmp         r3, #0
  001fc	1a000002	 bne         |$LN12@Init|

; 798  :     {
; 799  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 800  :             L"Error allocating MMC controller register\r\n"
; 801  :         ));
; 802  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00200	e3a0313b	 mov         r3, #0x3B, 2
  00204	e58d302c	 str         r3, [sp, #0x2C]

; 803  :         goto EXIT;

  00208	ea00004c	 b           |$EXIT$40292|
  0020c		 |$LN12@Init|

; 804  :     }
; 805  : 
; 806  :     pa.QuadPart = OMAP2420_PRCM_REGS_PA;

  0020c	e3a03312	 mov         r3, #0x12, 6
  00210	e3833902	 orr         r3, r3, #2, 18
  00214	e58d300c	 str         r3, [sp, #0xC]
  00218	e3a03000	 mov         r3, #0
  0021c	e58d3010	 str         r3, [sp, #0x10]

; 807  :     m_vpPRCMReg = (OMAP2420_PRCM_REGS*)MmMapIoSpace( pa, sizeof(OMAP2420_PRCM_REGS), FALSE );

  00220	e3a03000	 mov         r3, #0
  00224	e3a02c09	 mov         r2, #9, 24
  00228	e59d000c	 ldr         r0, [sp, #0xC]
  0022c	e59d1010	 ldr         r1, [sp, #0x10]
  00230	eb000000	 bl          MmMapIoSpace
  00234	e58d0058	 str         r0, [sp, #0x58]
  00238	e59d3070	 ldr         r3, [sp, #0x70]
  0023c	e283208c	 add         r2, r3, #0x8C
  00240	e59d3058	 ldr         r3, [sp, #0x58]
  00244	e5823000	 str         r3, [r2]

; 808  :     if ( !m_vpPRCMReg )

  00248	e59d3070	 ldr         r3, [sp, #0x70]
  0024c	e283308c	 add         r3, r3, #0x8C
  00250	e5933000	 ldr         r3, [r3]
  00254	e3530000	 cmp         r3, #0
  00258	1a000002	 bne         |$LN10@Init|

; 809  :     {
; 810  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 811  :             L"Error allocating Power Reset and Clock Managment Registers\r\n"
; 812  :         ));
; 813  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  0025c	e3a0313b	 mov         r3, #0x3B, 2
  00260	e58d302c	 str         r3, [sp, #0x2C]

; 814  :         goto EXIT;

  00264	ea000035	 b           |$EXIT$40292|
  00268		 |$LN10@Init|

; 815  :     }
; 816  : 
; 817  :     
; 818  :     if( !InitializeHardware() )

  00268	e59d3070	 ldr         r3, [sp, #0x70]
  0026c	e5933000	 ldr         r3, [r3]
  00270	e2833008	 add         r3, r3, #8
  00274	e59d0070	 ldr         r0, [sp, #0x70]
  00278	e5933000	 ldr         r3, [r3]
  0027c	e1a0e00f	 mov         lr, pc
  00280	e12fff13	 bx          r3
  00284	e58d005c	 str         r0, [sp, #0x5C]
  00288	e59d305c	 ldr         r3, [sp, #0x5C]
  0028c	e3530000	 cmp         r3, #0
  00290	1a000002	 bne         |$LN8@Init|

; 819  :     {
; 820  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 821  :             L"Error allocating CD/RW GPIO registers\r\n"
; 822  :         ));
; 823  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00294	e3a0313b	 mov         r3, #0x3B, 2
  00298	e58d302c	 str         r3, [sp, #0x2C]

; 824  :         goto EXIT;

  0029c	ea000027	 b           |$EXIT$40292|
  002a0		 |$LN8@Init|

; 825  :     }
; 826  : 
; 827  :     // turn the SDHC controller to fully on!
; 828  :     ClockOn();

  002a0	e59d0070	 ldr         r0, [sp, #0x70]
  002a4	eb000000	 bl          |?ClockOn@CSDIOControllerBase@@QAAXXZ|

; 829  :     this->m_PowerState = D0;

  002a8	e59d3070	 ldr         r3, [sp, #0x70]
  002ac	e2832010	 add         r2, r3, #0x10
  002b0	e3a03000	 mov         r3, #0
  002b4	e5823000	 str         r3, [r2]

; 830  : 
; 831  :     fHardwareInitialized = TRUE;

  002b8	e3a03001	 mov         r3, #1
  002bc	e58d3024	 str         r3, [sp, #0x24]

; 832  : 
; 833  :     // Initialize the slot
; 834  :     SoftwareReset(SOFT_RESET_ALL);

  002c0	e3a01002	 mov         r1, #2
  002c4	e59d0070	 ldr         r0, [sp, #0x70]
  002c8	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXE@Z|

; 835  :     Sleep(10); // Allow time for card to power down after a device reset

  002cc	e3a0000a	 mov         r0, #0xA
  002d0	eb000000	 bl          Sleep

; 836  :     DumpRegisters();
; 837  : 
; 838  :     // Read SD Host Controller Info from register.
; 839  :     if (!InterpretCapabilities()) 

  002d4	e59d3070	 ldr         r3, [sp, #0x70]
  002d8	e5933000	 ldr         r3, [r3]
  002dc	e2833028	 add         r3, r3, #0x28
  002e0	e59d0070	 ldr         r0, [sp, #0x70]
  002e4	e5933000	 ldr         r3, [r3]
  002e8	e1a0e00f	 mov         lr, pc
  002ec	e12fff13	 bx          r3
  002f0	e58d0060	 str         r0, [sp, #0x60]
  002f4	e59d3060	 ldr         r3, [sp, #0x60]
  002f8	e3530000	 cmp         r3, #0
  002fc	1a000000	 bne         |$LN6@Init|

; 840  :     {
; 841  :         goto EXIT;

  00300	ea00000e	 b           |$EXIT$40292|
  00304		 |$LN6@Init|

; 842  :     }
; 843  : 
; 844  :     // now register the host controller 
; 845  :     status = SDHCDRegisterHostController(m_pHCContext);

  00304	e59d3070	 ldr         r3, [sp, #0x70]
  00308	e2833004	 add         r3, r3, #4
  0030c	e5930000	 ldr         r0, [r3]
  00310	eb000000	 bl          SDHCDRegisterHostController
  00314	e58d0064	 str         r0, [sp, #0x64]
  00318	e59d3064	 ldr         r3, [sp, #0x64]
  0031c	e58d302c	 str         r3, [sp, #0x2C]

; 846  : 
; 847  :     if (!SD_API_SUCCESS(status)) {

  00320	e59d302c	 ldr         r3, [sp, #0x2C]
  00324	e3530000	 cmp         r3, #0
  00328	aa000000	 bge         |$LN4@Init|

; 848  :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 849  :             L"Failed to register host controller: %0x08X\r\n", status
; 850  :         ));
; 851  :         goto EXIT;

  0032c	ea000003	 b           |$EXIT$40292|
  00330		 |$LN4@Init|

; 852  :     }
; 853  : 
; 854  :     fRegisteredWithBusDriver = TRUE;

  00330	e3a03001	 mov         r3, #1
  00334	e58d3008	 str         r3, [sp, #8]

; 855  : 
; 856  :     // return the controller context
; 857  :     dwRet = (DWORD) this;

  00338	e59d3070	 ldr         r3, [sp, #0x70]
  0033c	e58d3004	 str         r3, [sp, #4]
  00340		 |$EXIT$40292|

; 858  : 
; 859  : EXIT:
; 860  :     if (hKeyDevice) RegCloseKey(hKeyDevice);

  00340	e59d3030	 ldr         r3, [sp, #0x30]
  00344	e3530000	 cmp         r3, #0
  00348	0a000001	 beq         |$LN2@Init|
  0034c	e59d0030	 ldr         r0, [sp, #0x30]
  00350	eb000000	 bl          RegCloseKey
  00354		 |$LN2@Init|

; 861  : 
; 862  :     if ( (dwRet == 0) && m_pHCContext ) {

  00354	e59d3004	 ldr         r3, [sp, #4]
  00358	e3530000	 cmp         r3, #0
  0035c	1a000008	 bne         |$LN1@Init|
  00360	e59d3070	 ldr         r3, [sp, #0x70]
  00364	e2833004	 add         r3, r3, #4
  00368	e5933000	 ldr         r3, [r3]
  0036c	e3530000	 cmp         r3, #0
  00370	0a000003	 beq         |$LN1@Init|

; 863  :         FreeHostContext( fRegisteredWithBusDriver, fHardwareInitialized );

  00374	e59d2024	 ldr         r2, [sp, #0x24]
  00378	e59d1008	 ldr         r1, [sp, #8]
  0037c	e59d0070	 ldr         r0, [sp, #0x70]
  00380	eb000000	 bl          |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|
  00384		 |$LN1@Init|

; 864  :     }
; 865  : 
; 866  :     DEBUGMSG(SDCARD_ZONE_INIT, (L"-CSDIOControllerBase::Init\r\n"));
; 867  : 
; 868  :     return dwRet;

  00384	e59d3004	 ldr         r3, [sp, #4]
  00388	e58d3034	 str         r3, [sp, #0x34]
  0038c	e28d0014	 add         r0, sp, #0x14
  00390	eb000000	 bl          |??1CReg@@QAA@XZ|
  00394	e59d3034	 ldr         r3, [sp, #0x34]
  00398	e58d303c	 str         r3, [sp, #0x3C]

; 869  : }

  0039c	e59d003c	 ldr         r0, [sp, #0x3C]
  003a0	e28dd068	 add         sp, sp, #0x68
  003a4	e89d6000	 ldmia       sp, {sp, lr}
  003a8	e12fff1e	 bx          lr
  003ac		 |$M42470|

			 ENDP  ; |?Init@CSDIOControllerBase@@QAAHPBG@Z|, CSDIOControllerBase::Init

	EXPORT	|?IOControl@CSDIOControllerBase@@QAAHKPAEK0KPAK@Z| ; CSDIOControllerBase::IOControl
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T42481| DCD	|$LN27@IOControl|
	DCD	0x40008c04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IOControl@CSDIOControllerBase@@QAAHKPAEK0KPAK@Z| PROC ; CSDIOControllerBase::IOControl

; 903  : {

  00000		 |$LN27@IOControl|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd04c	 sub         sp, sp, #0x4C
  00010		 |$M42478|

; 904  :     BOOL bRetVal = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 905  :     
; 906  :     DEBUGMSG(SDCARD_ZONE_FUNC, (L"+CSDIOControllerBase::IOControl(0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 907  :         dwCode, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 908  :     ));
; 909  : 
; 910  :     switch (dwCode) {

  00018	e59d3058	 ldr         r3, [sp, #0x58]
  0001c	e58d303c	 str         r3, [sp, #0x3C]
  00020	e59d203c	 ldr         r2, [sp, #0x3C]
  00024	e3a03832	 mov         r3, #0x32, 16
  00028	e3833a01	 orr         r3, r3, #1, 20
  0002c	e1520003	 cmp         r2, r3
  00030	0a00000c	 beq         |$LN20@IOControl|
  00034	e59d203c	 ldr         r2, [sp, #0x3C]
  00038	e59f31ec	 ldr         r3, [pc, #0x1EC]
  0003c	e1520003	 cmp         r2, r3
  00040	0a000058	 beq         |$LN6@IOControl|
  00044	e59d203c	 ldr         r2, [sp, #0x3C]
  00048	e59f31d8	 ldr         r3, [pc, #0x1D8]
  0004c	e1520003	 cmp         r2, r3
  00050	0a000026	 beq         |$LN14@IOControl|
  00054	e59d203c	 ldr         r2, [sp, #0x3C]
  00058	e59f31c4	 ldr         r3, [pc, #0x1C4]
  0005c	e1520003	 cmp         r2, r3
  00060	0a00001f	 beq         |$LN15@IOControl|
  00064	ea000068	 b           |$LN1@IOControl|
  00068		 |$LN20@IOControl|

; 911  :     // Power management functions.
; 912  :     // Return device specific power capabilities.
; 913  :     case IOCTL_POWER_CAPABILITIES:
; 914  :     {
; 915  :         POWER_CAPABILITIES pc;
; 916  : 
; 917  :         // Check arguments.
; 918  :         if ( pOutBuffer == NULL || outSize < sizeof(POWER_CAPABILITIES))

  00068	e59d3064	 ldr         r3, [sp, #0x64]
  0006c	e3530000	 cmp         r3, #0
  00070	0a000002	 beq         |$LN18@IOControl|
  00074	e59d3068	 ldr         r3, [sp, #0x68]
  00078	e3530030	 cmp         r3, #0x30
  0007c	2a000000	 bcs         |$LN19@IOControl|
  00080		 |$LN18@IOControl|

; 919  :         {
; 920  :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 921  :                 L"IOCTL_POWER_CAPABILITIES Invalid parameter.\r\n"
; 922  :             ));
; 923  :             break;

  00080	ea000061	 b           |$LN21@IOControl|
  00084		 |$LN19@IOControl|

; 924  :         }
; 925  : 
; 926  :         // Clear capabilities structure.
; 927  :         memset(&pc, 0, sizeof(POWER_CAPABILITIES));

  00084	e3a02030	 mov         r2, #0x30
  00088	e3a01000	 mov         r1, #0
  0008c	e28d0004	 add         r0, sp, #4
  00090	eb000000	 bl          memset

; 928  : 
; 929  :         // Set power capabilities. Supports D0 and D4.
; 930  :         pc.DeviceDx = DX_MASK(D0)|DX_MASK(D4);

  00094	e3a03011	 mov         r3, #0x11
  00098	e5cd3004	 strb        r3, [sp, #4]

; 931  : 
; 932  :         DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 933  :             L"IOCTL_POWER_CAPABILITIES = 0x%x\r\n", pc.DeviceDx
; 934  :         ));
; 935  : 
; 936  :         if (CeSafeCopyMemory(pOutBuffer, &pc, sizeof(pc)) == 0)

  0009c	e3a02030	 mov         r2, #0x30
  000a0	e28d1004	 add         r1, sp, #4
  000a4	e59d0064	 ldr         r0, [sp, #0x64]
  000a8	eb000000	 bl          CeSafeCopyMemory
  000ac	e58d0040	 str         r0, [sp, #0x40]
  000b0	e59d3040	 ldr         r3, [sp, #0x40]
  000b4	e3530000	 cmp         r3, #0
  000b8	1a000000	 bne         |$LN17@IOControl|

; 937  :         {
; 938  :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 939  :                 L"CeSafeCopyMemory Failed\r\n"
; 940  :             ));
; 941  :             break;

  000bc	ea000052	 b           |$LN21@IOControl|
  000c0		 |$LN17@IOControl|

; 942  :         }
; 943  : 
; 944  :         // Update returned data size.
; 945  :         if (pOutSize)

  000c0	e59d306c	 ldr         r3, [sp, #0x6C]
  000c4	e3530000	 cmp         r3, #0
  000c8	0a000002	 beq         |$LN16@IOControl|

; 946  :         {
; 947  :             *pOutSize = sizeof(pc);

  000cc	e59d206c	 ldr         r2, [sp, #0x6C]
  000d0	e3a03030	 mov         r3, #0x30
  000d4	e5823000	 str         r3, [r2]
  000d8		 |$LN16@IOControl|

; 948  :         }
; 949  :         bRetVal = TRUE;

  000d8	e3a03001	 mov         r3, #1
  000dc	e58d3000	 str         r3, [sp]

; 950  :         break;

  000e0	ea000049	 b           |$LN21@IOControl|
  000e4		 |$LN15@IOControl|

; 951  :     }
; 952  : 
; 953  :     // Indicate if the device is ready to enter a new device power state.
; 954  :     case IOCTL_POWER_QUERY:
; 955  :     {
; 956  :         DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 957  :             L"IOCTL_POWER_QUERY Deprecated Function Called\r\n"
; 958  :         ));
; 959  :         bRetVal = FALSE;

  000e4	e3a03000	 mov         r3, #0
  000e8	e58d3000	 str         r3, [sp]

; 960  :         break;

  000ec	ea000046	 b           |$LN21@IOControl|
  000f0		 |$LN14@IOControl|

; 961  :     }
; 962  : 
; 963  :     // Request a change from one device power state to another
; 964  :     // This driver self-manages it's internal power state by controlling
; 965  :     // functional and interface clocks as needed in the Read and Write
; 966  :     // functions rather than waiting for PM to tell it to save power
; 967  :     // So the set calls below just update the power state variable
; 968  :     case IOCTL_POWER_SET:
; 969  :     {
; 970  :         CEDEVICE_POWER_STATE dxState;
; 971  : 
; 972  :         // Check arguments.
; 973  :         if (pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE))

  000f0	e59d3064	 ldr         r3, [sp, #0x64]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000002	 beq         |$LN12@IOControl|
  000fc	e59d3068	 ldr         r3, [sp, #0x68]
  00100	e3530004	 cmp         r3, #4
  00104	2a000000	 bcs         |$LN13@IOControl|
  00108		 |$LN12@IOControl|

; 974  :         {
; 975  :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 976  :                 L"IOCTL_POWER_SET Invalid parameter.\r\n"
; 977  :             ));
; 978  :             break;

  00108	ea00003f	 b           |$LN21@IOControl|
  0010c		 |$LN13@IOControl|

; 979  :         }
; 980  : 
; 981  :         if (CeSafeCopyMemory(&dxState, pOutBuffer, sizeof(dxState)) == 0) break;

  0010c	e3a02004	 mov         r2, #4
  00110	e59d1064	 ldr         r1, [sp, #0x64]
  00114	e28d0034	 add         r0, sp, #0x34
  00118	eb000000	 bl          CeSafeCopyMemory
  0011c	e58d0044	 str         r0, [sp, #0x44]
  00120	e59d3044	 ldr         r3, [sp, #0x44]
  00124	e3530000	 cmp         r3, #0
  00128	1a000000	 bne         |$LN11@IOControl|
  0012c	ea000036	 b           |$LN21@IOControl|
  00130		 |$LN11@IOControl|

; 982  : 
; 983  :         DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 984  :             L"IOCTL_POWER_SET = %d.\r\n", dxState
; 985  :         ));
; 986  : 
; 987  :         // Check for any valid power state.
; 988  :         if (VALID_DX(dxState))

  00130	e59d3034	 ldr         r3, [sp, #0x34]
  00134	e3730001	 cmn         r3, #1
  00138	da000019	 ble         |$LN10@IOControl|
  0013c	e59d3034	 ldr         r3, [sp, #0x34]
  00140	e3530005	 cmp         r3, #5
  00144	aa000016	 bge         |$LN10@IOControl|

; 989  :         {
; 990  :             // Power off
; 991  :             if ( dxState == D4 )

  00148	e59d3034	 ldr         r3, [sp, #0x34]
  0014c	e3530004	 cmp         r3, #4
  00150	1a000008	 bne         |$LN9@IOControl|

; 992  :             {
; 993  :                 DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 994  :                     L"IOCTL_POWER_set PowerDown\r\n"
; 995  :                 ));
; 996  :                 
; 997  :                 //SDHCDPowerUpDown(m_pHCContext, FALSE, FALSE, 0);
; 998  :                 this->m_PowerState = dxState;

  00154	e59d3054	 ldr         r3, [sp, #0x54]
  00158	e2832010	 add         r2, r3, #0x10
  0015c	e59d3034	 ldr         r3, [sp, #0x34]
  00160	e5823000	 str         r3, [r2]

; 999  :                 this->FreeHostContext(TRUE, TRUE);        

  00164	e3a02001	 mov         r2, #1
  00168	e3a01001	 mov         r1, #1
  0016c	e59d0054	 ldr         r0, [sp, #0x54]
  00170	eb000000	 bl          |?FreeHostContext@CSDIOControllerBase@@QAAXHH@Z|

; 1000 :             }
; 1001 :             // Power on.
; 1002 :             else

  00174	ea000008	 b           |$LN8@IOControl|
  00178		 |$LN9@IOControl|

; 1003 :             {
; 1004 :                 DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 1005 :                     L"IOCTL_POWER_set PowerUp\r\n"
; 1006 :                 ));
; 1007 :                 
; 1008 :                 this->m_PowerState = dxState;

  00178	e59d3054	 ldr         r3, [sp, #0x54]
  0017c	e2832010	 add         r2, r3, #0x10
  00180	e59d3034	 ldr         r3, [sp, #0x34]
  00184	e5823000	 str         r3, [r2]

; 1009 :                 this->Init(m_pszActiveKey);

  00188	e59d3054	 ldr         r3, [sp, #0x54]
  0018c	e283300c	 add         r3, r3, #0xC
  00190	e5931000	 ldr         r1, [r3]
  00194	e59d0054	 ldr         r0, [sp, #0x54]
  00198	eb000000	 bl          |?Init@CSDIOControllerBase@@QAAHPBG@Z|
  0019c		 |$LN8@IOControl|

; 1010 :                 
; 1011 :                 // Notify the SD Bus driver of the PowerUp event
; 1012 :                 //SDHCDPowerUpDown(m_pHCContext, TRUE, FALSE, 0);
; 1013 :             }
; 1014 :             bRetVal = TRUE;

  0019c	e3a03001	 mov         r3, #1
  001a0	e58d3000	 str         r3, [sp]
  001a4		 |$LN10@IOControl|

; 1015 :         }
; 1016 :         else
; 1017 :         {
; 1018 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 1019 :                 L"IOCTL_POWER_SET invalid power state.\r\n"
; 1020 :             ));
; 1021 :         }
; 1022 :         break;

  001a4	ea000018	 b           |$LN21@IOControl|
  001a8		 |$LN6@IOControl|

; 1023 :     }
; 1024 : 
; 1025 :     // Return the current device power state.
; 1026 :     case IOCTL_POWER_GET:
; 1027 :     {
; 1028 :         // Check arguments.
; 1029 :         if (pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE))

  001a8	e59d3064	 ldr         r3, [sp, #0x64]
  001ac	e3530000	 cmp         r3, #0
  001b0	0a000002	 beq         |$LN4@IOControl|
  001b4	e59d3068	 ldr         r3, [sp, #0x68]
  001b8	e3530004	 cmp         r3, #4
  001bc	2a000000	 bcs         |$LN5@IOControl|
  001c0		 |$LN4@IOControl|

; 1030 :         {
; 1031 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 1032 :                 L"IOCTL_POWER_GET Invalid parameter.\r\n"
; 1033 :             ));
; 1034 :             break;

  001c0	ea000011	 b           |$LN21@IOControl|
  001c4		 |$LN5@IOControl|

; 1035 :         }
; 1036 : 
; 1037 :         //Copy current state
; 1038 :         if (CeSafeCopyMemory(pOutBuffer, &this->m_PowerState, sizeof(this->m_PowerState)) == 0)

  001c4	e3a02004	 mov         r2, #4
  001c8	e59d3054	 ldr         r3, [sp, #0x54]
  001cc	e2831010	 add         r1, r3, #0x10
  001d0	e59d0064	 ldr         r0, [sp, #0x64]
  001d4	eb000000	 bl          CeSafeCopyMemory
  001d8	e58d0048	 str         r0, [sp, #0x48]
  001dc	e59d3048	 ldr         r3, [sp, #0x48]
  001e0	e3530000	 cmp         r3, #0
  001e4	1a000000	 bne         |$LN3@IOControl|

; 1039 :         {
; 1040 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 1041 :                 L"CeSafeCopyMemory Failed\r\n"
; 1042 :             ));
; 1043 :             break;

  001e8	ea000007	 b           |$LN21@IOControl|
  001ec		 |$LN3@IOControl|

; 1044 :         }
; 1045 : 
; 1046 :         // Update returned data size.
; 1047 :         if (pOutSize)

  001ec	e59d306c	 ldr         r3, [sp, #0x6C]
  001f0	e3530000	 cmp         r3, #0
  001f4	0a000002	 beq         |$LN2@IOControl|

; 1048 :         {
; 1049 :             *pOutSize = sizeof(this->m_PowerState);

  001f8	e59d206c	 ldr         r2, [sp, #0x6C]
  001fc	e3a03004	 mov         r3, #4
  00200	e5823000	 str         r3, [r2]
  00204		 |$LN2@IOControl|

; 1050 :         }
; 1051 : 
; 1052 :         DEBUGMSG(SDCARD_ZONE_POWER, (L"CSDIOControllerBase::IOControl: "
; 1053 :             L"IOCTL_POWER_GET: %d\r\n", this->m_PowerState
; 1054 :         ));
; 1055 :         bRetVal = TRUE;

  00204	e3a03001	 mov         r3, #1
  00208	e58d3000	 str         r3, [sp]
  0020c		 |$LN1@IOControl|
  0020c		 |$LN21@IOControl|

; 1056 :         break;
; 1057 :     }
; 1058 : 
; 1059 :     default:
; 1060 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::IOControl: "
; 1061 :             L"Unknown IOCTL_xxx(0x%0.8X)\r\n", dwCode
; 1062 :         ));
; 1063 :         break;
; 1064 : 
; 1065 :     }
; 1066 : 
; 1067 :     DEBUGMSG(SDCARD_ZONE_FUNC, (L"-CSDIOControllerBase::IOControl(rc = %d)\r\n", bRetVal));
; 1068 :     return bRetVal;    

  0020c	e59d3000	 ldr         r3, [sp]
  00210	e58d3038	 str         r3, [sp, #0x38]

; 1069 : }

  00214	e59d0038	 ldr         r0, [sp, #0x38]
  00218	e28dd04c	 add         sp, sp, #0x4C
  0021c	e89d6000	 ldmia       sp, {sp, lr}
  00220	e12fff1e	 bx          lr
  00224		 |$LN28@IOControl|
  00224		 |$LN29@IOControl|
  00224	0032100c	 DCD         0x32100c
  00228		 |$LN30@IOControl|
  00228	00321008	 DCD         0x321008
  0022c		 |$LN31@IOControl|
  0022c	00321004	 DCD         0x321004
  00230		 |$M42479|

			 ENDP  ; |?IOControl@CSDIOControllerBase@@QAAHKPAEK0KPAK@Z|, CSDIOControllerBase::IOControl

	EXPORT	|?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDIOControllerBase::SDHCSlotOptionHandlerImpl

  00000			 AREA	 |.pdata|, PDATA
|$T42507| DCD	|$LN45@SDHCSlotOp|
	DCD	0x4000bd04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDIOControllerBase::SDHCSlotOptionHandlerImpl

; 1946 : {

  00000		 |$LN45@SDHCSlotOp|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd028	 sub         sp, sp, #0x28
  00010		 |$M42504|

; 1947 :     SD_API_STATUS status = SD_API_STATUS_SUCCESS;   // status

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 1948 : 
; 1949 :     SDHCDAcquireHCLock(m_pHCContext);

  00018	e59d3030	 ldr         r3, [sp, #0x30]
  0001c	e2833004	 add         r3, r3, #4
  00020	e5933000	 ldr         r3, [r3]
  00024	e2830024	 add         r0, r3, #0x24
  00028	eb000000	 bl          EnterCriticalSection

; 1950 : 
; 1951 :     switch (Option) {

  0002c	e59d3038	 ldr         r3, [sp, #0x38]
  00030	e58d3020	 str         r3, [sp, #0x20]
  00034	e59d3020	 ldr         r3, [sp, #0x20]
  00038	e353000b	 cmp         r3, #0xB
  0003c	8a00009f	 bhi         |$LN1@SDHCSlotOp|
  00040	e59d2020	 ldr         r2, [sp, #0x20]
  00044	e1a03102	 mov         r3, r2, lsl #2
  00048	e083300f	 add         r3, r3, pc
  0004c	e5933004	 ldr         r3, [r3, #4]
  00050	e08ff003	 add         pc, pc, r3
  00054		 |$LN30@SDHCSlotOp|
  00054		 |$LN29@SDHCSlotOp|
  00054		 |$LN31@SDHCSlotOp|
  00054	0000002c	 DCD         0x2c
  00058		 |$LN32@SDHCSlotOp|
  00058	00000030	 DCD         0x30
  0005c		 |$LN33@SDHCSlotOp|
  0005c	00000048	 DCD         0x48
  00060		 |$LN34@SDHCSlotOp|
  00060	000000e8	 DCD         0xe8
  00064		 |$LN35@SDHCSlotOp|
  00064	000000dc	 DCD         0xdc
  00068		 |$LN36@SDHCSlotOp|
  00068	000000ec	 DCD         0xec
  0006c		 |$LN37@SDHCSlotOp|
  0006c	00000128	 DCD         0x128
  00070		 |$LN38@SDHCSlotOp|
  00070	00000268	 DCD         0x268
  00074		 |$LN39@SDHCSlotOp|
  00074	00000054	 DCD         0x54
  00078		 |$LN40@SDHCSlotOp|
  00078	00000098	 DCD         0x98
  0007c		 |$LN41@SDHCSlotOp|
  0007c	00000268	 DCD         0x268
  00080		 |$LN42@SDHCSlotOp|
  00080	000001e4	 DCD         0x1e4
  00084		 |$LN24@SDHCSlotOp|

; 1952 : 
; 1953 : case SDHCDSetSlotPower:
; 1954 :     {
; 1955 :         DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 1956 :             L"Called - SDHCDSetSlotPower\r\n"));
; 1957 :         // Nothing to do because this system only operates at the reported 3.2V
; 1958 :     }
; 1959 :     break;

  00084	ea00008f	 b           |$LN25@SDHCSlotOp|
  00088		 |$LN23@SDHCSlotOp|

; 1960 : 
; 1961 : case SDHCDSetSlotInterface:
; 1962 :     {
; 1963 :         PSD_CARD_INTERFACE pInterface = (PSD_CARD_INTERFACE) pData;

  00088	e59d303c	 ldr         r3, [sp, #0x3C]
  0008c	e58d3004	 str         r3, [sp, #4]

; 1964 : 
; 1965 :         DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 1966 :             L"Called - SetSlotInterface : Clock Setting: %d\r\n", pInterface->ClockRate
; 1967 :         ));
; 1968 : 
; 1969 :         SetInterface(pInterface);

  00090	e59d1004	 ldr         r1, [sp, #4]
  00094	e59d0030	 ldr         r0, [sp, #0x30]
  00098	eb000000	 bl          |?SetInterface@CSDIOControllerBase@@QAAXPAU_SD_CARD_INTERFACE@@@Z|

; 1970 :     }
; 1971 :     break;

  0009c	ea000089	 b           |$LN25@SDHCSlotOp|
  000a0		 |$LN22@SDHCSlotOp|

; 1972 : 
; 1973 : case SDHCDEnableSDIOInterrupts:
; 1974 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 1975 :         L"Called - EnableSDIOInterrupts : on slot %d\r\n", SlotNumber
; 1976 :     ));
; 1977 :     EnableSDIOInterrupts();

  000a0	e59d0030	 ldr         r0, [sp, #0x30]
  000a4	eb000000	 bl          |?EnableSDIOInterrupts@CSDIOControllerBase@@QAAXXZ|

; 1978 :     break;

  000a8	ea000086	 b           |$LN25@SDHCSlotOp|
  000ac		 |$LN21@SDHCSlotOp|

; 1979 : 
; 1980 : case SDHCDSetSlotPowerState:
; 1981 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 1982 :         L"Called - SetSlotPowerState : on slot %d\r\n", SlotNumber
; 1983 :     ));
; 1984 :     if( pData == NULL || OptionSize != sizeof(CEDEVICE_POWER_STATE) )

  000ac	e59d303c	 ldr         r3, [sp, #0x3C]
  000b0	e3530000	 cmp         r3, #0
  000b4	0a000002	 beq         |$LN19@SDHCSlotOp|
  000b8	e59d3040	 ldr         r3, [sp, #0x40]
  000bc	e3530004	 cmp         r3, #4
  000c0	0a000002	 beq         |$LN20@SDHCSlotOp|
  000c4		 |$LN19@SDHCSlotOp|

; 1985 :     {
; 1986 :         status = SD_API_STATUS_INVALID_PARAMETER;

  000c4	e3a0311f	 mov         r3, #0x1F, 2
  000c8	e58d3000	 str         r3, [sp]

; 1987 :     }
; 1988 :     else

  000cc	ea000006	 b           |$LN18@SDHCSlotOp|
  000d0		 |$LN20@SDHCSlotOp|

; 1989 :     {
; 1990 :         PCEDEVICE_POWER_STATE pcps = (PCEDEVICE_POWER_STATE) pData;

  000d0	e59d303c	 ldr         r3, [sp, #0x3C]
  000d4	e58d3008	 str         r3, [sp, #8]

; 1991 :         this->m_PowerState = *pcps;

  000d8	e59d3030	 ldr         r3, [sp, #0x30]
  000dc	e2832010	 add         r2, r3, #0x10
  000e0	e59d3008	 ldr         r3, [sp, #8]
  000e4	e5933000	 ldr         r3, [r3]
  000e8	e5823000	 str         r3, [r2]
  000ec		 |$LN18@SDHCSlotOp|

; 1992 :     }
; 1993 :     break;

  000ec	ea000075	 b           |$LN25@SDHCSlotOp|
  000f0		 |$LN17@SDHCSlotOp|

; 1994 : 
; 1995 : case SDHCDGetSlotPowerState:
; 1996 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 1997 :         L"Called - GetSlotPowerState : on slot %d\r\n", SlotNumber
; 1998 :     ));
; 1999 :     if( pData == NULL || OptionSize != sizeof(CEDEVICE_POWER_STATE) )

  000f0	e59d303c	 ldr         r3, [sp, #0x3C]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000002	 beq         |$LN15@SDHCSlotOp|
  000fc	e59d3040	 ldr         r3, [sp, #0x40]
  00100	e3530004	 cmp         r3, #4
  00104	0a000002	 beq         |$LN16@SDHCSlotOp|
  00108		 |$LN15@SDHCSlotOp|

; 2000 :     {
; 2001 :         status = SD_API_STATUS_INVALID_PARAMETER;

  00108	e3a0311f	 mov         r3, #0x1F, 2
  0010c	e58d3000	 str         r3, [sp]

; 2002 :     }
; 2003 :     else

  00110	ea000006	 b           |$LN14@SDHCSlotOp|
  00114		 |$LN16@SDHCSlotOp|

; 2004 :     {
; 2005 :         PCEDEVICE_POWER_STATE pcps = (PCEDEVICE_POWER_STATE) pData;

  00114	e59d303c	 ldr         r3, [sp, #0x3C]
  00118	e58d300c	 str         r3, [sp, #0xC]

; 2006 :         *pcps = this->m_PowerState;

  0011c	e59d3030	 ldr         r3, [sp, #0x30]
  00120	e2833010	 add         r3, r3, #0x10
  00124	e5932000	 ldr         r2, [r3]
  00128	e59d300c	 ldr         r3, [sp, #0xC]
  0012c	e5832000	 str         r2, [r3]
  00130		 |$LN14@SDHCSlotOp|

; 2007 :     }
; 2008 :     break;

  00130	ea000064	 b           |$LN25@SDHCSlotOp|
  00134		 |$LN13@SDHCSlotOp|

; 2009 : 
; 2010 : case SDHCDAckSDIOInterrupt:
; 2011 :     AckSDIOInterrupt();

  00134	e59d0030	 ldr         r0, [sp, #0x30]
  00138	eb000000	 bl          |?AckSDIOInterrupt@CSDIOControllerBase@@QAAXXZ|

; 2012 :     break;

  0013c	ea000061	 b           |$LN25@SDHCSlotOp|
  00140		 |$LN12@SDHCSlotOp|

; 2013 : 
; 2014 : case SDHCDDisableSDIOInterrupts:
; 2015 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 2016 :         L"Called - DisableSDIOInterrupts : on slot %d\r\n", SlotNumber
; 2017 :     ));
; 2018 :     break;

  00140	ea000060	 b           |$LN25@SDHCSlotOp|
  00144		 |$LN11@SDHCSlotOp|

; 2019 : 
; 2020 : case SDHCDGetWriteProtectStatus:
; 2021 :     DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 2022 :         L"Called - SDHCDGetWriteProtectStatus : on slot %d\r\n", SlotNumber
; 2023 :     )); 
; 2024 :     {
; 2025 :         PSD_CARD_INTERFACE pInterface = (PSD_CARD_INTERFACE) pData;

  00144	e59d303c	 ldr         r3, [sp, #0x3C]
  00148	e58d3010	 str         r3, [sp, #0x10]

; 2026 :         pInterface->WriteProtected = IsWriteProtected();

  0014c	e59d3030	 ldr         r3, [sp, #0x30]
  00150	e5933000	 ldr         r3, [r3]
  00154	e2833010	 add         r3, r3, #0x10
  00158	e59d0030	 ldr         r0, [sp, #0x30]
  0015c	e5933000	 ldr         r3, [r3]
  00160	e1a0e00f	 mov         lr, pc
  00164	e12fff13	 bx          r3
  00168	e58d0024	 str         r0, [sp, #0x24]
  0016c	e59d3010	 ldr         r3, [sp, #0x10]
  00170	e2832008	 add         r2, r3, #8
  00174	e59d3024	 ldr         r3, [sp, #0x24]
  00178	e5823000	 str         r3, [r2]

; 2027 :     }
; 2028 : 
; 2029 :     break;

  0017c	ea000051	 b           |$LN25@SDHCSlotOp|
  00180		 |$LN10@SDHCSlotOp|

; 2030 : 
; 2031 : case SDHCDQueryBlockCapability:
; 2032 :     {
; 2033 :         PSD_HOST_BLOCK_CAPABILITY pBlockCaps = 
; 2034 :             (PSD_HOST_BLOCK_CAPABILITY)pData;

  00180	e59d303c	 ldr         r3, [sp, #0x3C]
  00184	e58d3014	 str         r3, [sp, #0x14]

; 2035 : 
; 2036 :         DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 2037 :             L"Read Block Length: %d , Read Blocks: %d\r\n", pBlockCaps->ReadBlockSize, pBlockCaps->ReadBlocks
; 2038 :         ));
; 2039 :         DEBUGMSG(SDCARD_ZONE_INFO, (L"CSDIOControllerBase::SDHCSlotOptionHandlerImpl: "
; 2040 :             L"Write Block Length: %d , Write Blocks: %d\r\n", pBlockCaps->WriteBlockSize, pBlockCaps->WriteBlocks
; 2041 :         ));
; 2042 : 
; 2043 :         if (pBlockCaps->ReadBlockSize < STD_HC_MIN_BLOCK_LENGTH) {

  00188	e59d3014	 ldr         r3, [sp, #0x14]
  0018c	e1d330b0	 ldrh        r3, [r3]
  00190	e3530001	 cmp         r3, #1
  00194	aa000002	 bge         |$LN9@SDHCSlotOp|

; 2044 :             pBlockCaps->ReadBlockSize = STD_HC_MIN_BLOCK_LENGTH;

  00198	e59d2014	 ldr         r2, [sp, #0x14]
  0019c	e3a03001	 mov         r3, #1
  001a0	e1c230b0	 strh        r3, [r2]
  001a4		 |$LN9@SDHCSlotOp|

; 2045 :         }
; 2046 : 
; 2047 :         if (pBlockCaps->ReadBlockSize > m_usMaxBlockLen) {

  001a4	e59d3014	 ldr         r3, [sp, #0x14]
  001a8	e1d330b0	 ldrh        r3, [r3]
  001ac	e1a02003	 mov         r2, r3
  001b0	e59d3030	 ldr         r3, [sp, #0x30]
  001b4	e2833078	 add         r3, r3, #0x78
  001b8	e1d330b0	 ldrh        r3, [r3]
  001bc	e1520003	 cmp         r2, r3
  001c0	da000004	 ble         |$LN8@SDHCSlotOp|

; 2048 :             pBlockCaps->ReadBlockSize = m_usMaxBlockLen;

  001c4	e59d3030	 ldr         r3, [sp, #0x30]
  001c8	e2833078	 add         r3, r3, #0x78
  001cc	e1d320b0	 ldrh        r2, [r3]
  001d0	e59d3014	 ldr         r3, [sp, #0x14]
  001d4	e1c320b0	 strh        r2, [r3]
  001d8		 |$LN8@SDHCSlotOp|

; 2049 :         }
; 2050 : 
; 2051 :         if (pBlockCaps->WriteBlockSize < STD_HC_MIN_BLOCK_LENGTH) {

  001d8	e59d3014	 ldr         r3, [sp, #0x14]
  001dc	e2833002	 add         r3, r3, #2
  001e0	e1d330b0	 ldrh        r3, [r3]
  001e4	e3530001	 cmp         r3, #1
  001e8	aa000003	 bge         |$LN7@SDHCSlotOp|

; 2052 :             pBlockCaps->WriteBlockSize = STD_HC_MIN_BLOCK_LENGTH;

  001ec	e59d3014	 ldr         r3, [sp, #0x14]
  001f0	e2832002	 add         r2, r3, #2
  001f4	e3a03001	 mov         r3, #1
  001f8	e1c230b0	 strh        r3, [r2]
  001fc		 |$LN7@SDHCSlotOp|

; 2053 :         }
; 2054 : 
; 2055 :         if (pBlockCaps->WriteBlockSize > m_usMaxBlockLen) {

  001fc	e59d3014	 ldr         r3, [sp, #0x14]
  00200	e2833002	 add         r3, r3, #2
  00204	e1d330b0	 ldrh        r3, [r3]
  00208	e1a02003	 mov         r2, r3
  0020c	e59d3030	 ldr         r3, [sp, #0x30]
  00210	e2833078	 add         r3, r3, #0x78
  00214	e1d330b0	 ldrh        r3, [r3]
  00218	e1520003	 cmp         r2, r3
  0021c	da000005	 ble         |$LN6@SDHCSlotOp|

; 2056 :             pBlockCaps->WriteBlockSize = m_usMaxBlockLen;

  00220	e59d3030	 ldr         r3, [sp, #0x30]
  00224	e2831078	 add         r1, r3, #0x78
  00228	e59d3014	 ldr         r3, [sp, #0x14]
  0022c	e2832002	 add         r2, r3, #2
  00230	e1d130b0	 ldrh        r3, [r1]
  00234	e1c230b0	 strh        r3, [r2]
  00238		 |$LN6@SDHCSlotOp|

; 2057 :         }
; 2058 :     }
; 2059 :     break;

  00238	ea000022	 b           |$LN25@SDHCSlotOp|
  0023c		 |$LN5@SDHCSlotOp|

; 2060 : 
; 2061 : case SDHCDGetSlotInfo:
; 2062 :     if( OptionSize != sizeof(SDCARD_HC_SLOT_INFO) || pData == NULL )

  0023c	e59d3040	 ldr         r3, [sp, #0x40]
  00240	e3530014	 cmp         r3, #0x14
  00244	1a000002	 bne         |$LN3@SDHCSlotOp|
  00248	e59d303c	 ldr         r3, [sp, #0x3C]
  0024c	e3530000	 cmp         r3, #0
  00250	1a000002	 bne         |$LN4@SDHCSlotOp|
  00254		 |$LN3@SDHCSlotOp|

; 2063 :     {
; 2064 :         status = SD_API_STATUS_INVALID_PARAMETER;

  00254	e3a0311f	 mov         r3, #0x1F, 2
  00258	e58d3000	 str         r3, [sp]

; 2065 :     }
; 2066 :     else

  0025c	ea000016	 b           |$LN2@SDHCSlotOp|
  00260		 |$LN4@SDHCSlotOp|

; 2067 :     {
; 2068 :         PSDCARD_HC_SLOT_INFO pSlotInfo = (PSDCARD_HC_SLOT_INFO)pData;

  00260	e59d303c	 ldr         r3, [sp, #0x3C]
  00264	e58d3018	 str         r3, [sp, #0x18]

; 2069 : 
; 2070 :         // set the slot capabilities
; 2071 :         SDHCDSetSlotCapabilities( pSlotInfo, 
; 2072 :                 SD_SLOT_SD_1BIT_CAPABLE |
; 2073 :                 SD_SLOT_SD_4BIT_CAPABLE |
; 2074 :                 SD_SLOT_SDIO_CAPABLE );

  00268	e59d2018	 ldr         r2, [sp, #0x18]
  0026c	e3a0302c	 mov         r3, #0x2C
  00270	e5823000	 str         r3, [r2]

; 2075 : 
; 2076 :         SDHCDSetVoltageWindowMask(pSlotInfo, (SD_VDD_WINDOW_3_0_TO_3_1 | SD_VDD_WINDOW_3_1_TO_3_2)); 

  00274	e59d3018	 ldr         r3, [sp, #0x18]
  00278	e2832004	 add         r2, r3, #4
  0027c	e3a03703	 mov         r3, #3, 14
  00280	e5823000	 str         r3, [r2]

; 2077 : 
; 2078 : 
; 2079 :         // Set optimal voltage
; 2080 :         SDHCDSetDesiredSlotVoltage(pSlotInfo, SD_VDD_WINDOW_3_2_TO_3_3);     

  00284	e59d3018	 ldr         r3, [sp, #0x18]
  00288	e2832008	 add         r2, r3, #8
  0028c	e3a03601	 mov         r3, #1, 12
  00290	e5823000	 str         r3, [r2]

; 2081 : 
; 2082 :         // Set maximum supported clock rate
; 2083 :         SDHCDSetMaxClockRate(pSlotInfo, m_dwMaxClockRate);

  00294	e59d3030	 ldr         r3, [sp, #0x30]
  00298	e2831074	 add         r1, r3, #0x74
  0029c	e59d3018	 ldr         r3, [sp, #0x18]
  002a0	e283200c	 add         r2, r3, #0xC
  002a4	e5913000	 ldr         r3, [r1]
  002a8	e5823000	 str         r3, [r2]

; 2084 : 
; 2085 :         // set power up delay
; 2086 :         SDHCDSetPowerUpDelay(pSlotInfo, 100); 

  002ac	e59d3018	 ldr         r3, [sp, #0x18]
  002b0	e2832010	 add         r2, r3, #0x10
  002b4	e3a03064	 mov         r3, #0x64
  002b8	e5823000	 str         r3, [r2]
  002bc		 |$LN2@SDHCSlotOp|

; 2087 :     }
; 2088 :     break;

  002bc	ea000001	 b           |$LN25@SDHCSlotOp|
  002c0		 |$LN1@SDHCSlotOp|

; 2089 : 
; 2090 : default:
; 2091 :     status = SD_API_STATUS_INVALID_PARAMETER;

  002c0	e3a0311f	 mov         r3, #0x1F, 2
  002c4	e58d3000	 str         r3, [sp]
  002c8		 |$LN25@SDHCSlotOp|

; 2092 : 
; 2093 :     }
; 2094 : 
; 2095 :     SDHCDReleaseHCLock(m_pHCContext);

  002c8	e59d3030	 ldr         r3, [sp, #0x30]
  002cc	e2833004	 add         r3, r3, #4
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e2830024	 add         r0, r3, #0x24
  002d8	eb000000	 bl          LeaveCriticalSection

; 2096 :     return status;

  002dc	e59d3000	 ldr         r3, [sp]
  002e0	e58d301c	 str         r3, [sp, #0x1C]

; 2097 : }

  002e4	e59d001c	 ldr         r0, [sp, #0x1C]
  002e8	e28dd028	 add         sp, sp, #0x28
  002ec	e89d6000	 ldmia       sp, {sp, lr}
  002f0	e12fff1e	 bx          lr
  002f4		 |$M42505|

			 ENDP  ; |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDIOControllerBase::SDHCSlotOptionHandlerImpl

	EXPORT	|?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z| ; CSDIOControllerBase::SDHCSlotOptionHandler

  00000			 AREA	 |.pdata|, PDATA
|$T42516| DCD	|$LN5@SDHCSlotOp@2|
	DCD	0x40001704
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z| PROC ; CSDIOControllerBase::SDHCSlotOptionHandler

; 2126 : {

  00000		 |$LN5@SDHCSlotOp@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M42513|

; 2127 :     // get our extension 
; 2128 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00010	e59d301c	 ldr         r3, [sp, #0x1C]
  00014	e283304c	 add         r3, r3, #0x4C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3004	 str         r3, [sp, #4]

; 2129 :     return pController->SDHCSlotOptionHandlerImpl((UCHAR)SlotNumber,
; 2130 :         Option,
; 2131 :         pData,
; 2132 :         OptionSize );

  00020	e59d302c	 ldr         r3, [sp, #0x2C]
  00024	e58d3000	 str         r3, [sp]
  00028	e59d3028	 ldr         r3, [sp, #0x28]
  0002c	e59d2024	 ldr         r2, [sp, #0x24]
  00030	e59d1020	 ldr         r1, [sp, #0x20]
  00034	e20110ff	 and         r1, r1, #0xFF
  00038	e59d0004	 ldr         r0, [sp, #4]
  0003c	eb000000	 bl          |?SDHCSlotOptionHandlerImpl@CSDIOControllerBase@@QAAJEW4_SD_SLOT_OPTION_CODE@@PAXK@Z|
  00040	e58d0010	 str         r0, [sp, #0x10]
  00044	e59d3010	 ldr         r3, [sp, #0x10]
  00048	e58d300c	 str         r3, [sp, #0xC]

; 2133 : }

  0004c	e59d000c	 ldr         r0, [sp, #0xC]
  00050	e28dd014	 add         sp, sp, #0x14
  00054	e89d6000	 ldmia       sp, {sp, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M42514|

			 ENDP  ; |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z|, CSDIOControllerBase::SDHCSlotOptionHandler

	EXPORT	|?SDIReceive@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDIReceive

  00000			 AREA	 |.pdata|, PDATA
|$T42524| DCD	|$LN5@SDIReceive|
	DCD	0x40000f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDIReceive@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDIReceive

; 2322 : {

  00000		 |$LN5@SDIReceive|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42521|

; 2323 :     return SDIPollingReceive( pBuff, dwLen );

  00010	e59d2018	 ldr         r2, [sp, #0x18]
  00014	e59d1014	 ldr         r1, [sp, #0x14]
  00018	e59d0010	 ldr         r0, [sp, #0x10]
  0001c	eb000000	 bl          |?SDIPollingReceive@CSDIOControllerBase@@QAAHPAEK@Z|
  00020	e58d0004	 str         r0, [sp, #4]
  00024	e59d3004	 ldr         r3, [sp, #4]
  00028	e58d3000	 str         r3, [sp]

; 2324 : }

  0002c	e59d0000	 ldr         r0, [sp]
  00030	e28dd008	 add         sp, sp, #8
  00034	e89d6000	 ldmia       sp, {sp, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M42522|

			 ENDP  ; |?SDIReceive@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDIReceive

	EXPORT	|?SDITransmit@CSDIOControllerBase@@QAAHPAEK@Z| ; CSDIOControllerBase::SDITransmit

  00000			 AREA	 |.pdata|, PDATA
|$T42532| DCD	|$LN5@SDITransmi|
	DCD	0x40000f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDITransmit@CSDIOControllerBase@@QAAHPAEK@Z| PROC ; CSDIOControllerBase::SDITransmit

; 2327 : {

  00000		 |$LN5@SDITransmi|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42529|

; 2328 :     return SDIPollingTransmit( pBuff, dwLen );

  00010	e59d2018	 ldr         r2, [sp, #0x18]
  00014	e59d1014	 ldr         r1, [sp, #0x14]
  00018	e59d0010	 ldr         r0, [sp, #0x10]
  0001c	eb000000	 bl          |?SDIPollingTransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  00020	e58d0004	 str         r0, [sp, #4]
  00024	e59d3004	 ldr         r3, [sp, #4]
  00028	e58d3000	 str         r3, [sp]

; 2329 : }

  0002c	e59d0000	 ldr         r0, [sp]
  00030	e28dd008	 add         sp, sp, #8
  00034	e89d6000	 ldmia       sp, {sp, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M42530|

			 ENDP  ; |?SDITransmit@CSDIOControllerBase@@QAAHPAEK@Z|, CSDIOControllerBase::SDITransmit

	EXPORT	|?CommandCompleteHandler@CSDIOControllerBase@@QAAHXZ| ; CSDIOControllerBase::CommandCompleteHandler
	IMPORT	|SDProcessException|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T42587| DCD	|$LN92@CommandCom|
	DCD	0xc0018505

  00000			 AREA	 |.pdata|, PDATA
|$T42589| DCD	|$LN61@CommandCom|
	DCD	0x40000a02

  00000			 AREA	 |.pdata|, PDATA
|$T42591| DCD	|$LN54@CommandCom|
	DCD	0x40000a02

  00000			 AREA	 |.xdata|, DATA
|$T42585| DCD	0x2
	DCD	|$LN65@CommandCom|
	DCD	|$LN66@CommandCom|
	DCD	|$LN61@CommandCom|
	DCD	|$LN62@CommandCom|
	DCD	|$LN58@CommandCom|
	DCD	|$LN59@CommandCom|
	DCD	|$LN54@CommandCom|
	DCD	|$LN55@CommandCom|
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T42585|

  00008		 |?CommandCompleteHandler@CSDIOControllerBase@@QAAHXZ| PROC ; CSDIOControllerBase::CommandCompleteHandler

; 1598 : {

  00008		 |$LN92@CommandCom|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0001	 stmdb       sp!, {r0}
  00010	e92d5800	 stmdb       sp!, {r11, r12, lr}
  00014	e28db00c	 add         r11, sp, #0xC
  00018	e24dd08c	 sub         sp, sp, #0x8C
  0001c		 |$LN90@CommandCom|

; 1599 :     DWORD               dwCurrentTickCount;
; 1600 :     DWORD               dwTimeout;
; 1601 :     DWORD               dwCountStart;
; 1602 :     BOOL                fTimeoutOverflow = FALSE;

  0001c	e3a03000	 mov         r3, #0
  00020	e50b3098	 str         r3, [r11, #-0x98]

; 1603 :     PSD_BUS_REQUEST     pRequest = NULL;       // the request to complete

  00024	e3a03000	 mov         r3, #0
  00028	e50b3090	 str         r3, [r11, #-0x90]

; 1604 :     SD_API_STATUS       status = SD_API_STATUS_PENDING;

  0002c	e3a03001	 mov         r3, #1
  00030	e50b3080	 str         r3, [r11, #-0x80]

; 1605 : 
; 1606 :     DEBUGMSG(SHC_INTERRUPT_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1607 :         L"Got the command response\r\n"
; 1608 :     ));
; 1609 :     
; 1610 : #ifdef SDIO_INAB_INTERRUPT_WORKAROUND
; 1611 :     if( m_fINABworkaroundEnabled )
; 1612 :     {
; 1613 :         if( m_CurrentState == SendingINAB )
; 1614 :             goto PROCESS_INAB_STATE;
; 1615 :     }
; 1616 : #endif
; 1617 : 
; 1618 :     // get and lock the current bus request
; 1619 :     if((pRequest = SDHCDGetAndLockCurrentRequest(m_pHCContext, 0)) == NULL)

  00034	e3a01000	 mov         r1, #0
  00038	e59b3000	 ldr         r3, [r11]
  0003c	e2833004	 add         r3, r3, #4
  00040	e5930000	 ldr         r0, [r3]
  00044	eb000000	 bl          SDHCDGetAndLockCurrentRequest
  00048	e50b0058	 str         r0, [r11, #-0x58]
  0004c	e51b3058	 ldr         r3, [r11, #-0x58]
  00050	e50b3090	 str         r3, [r11, #-0x90]
  00054	e51b3090	 ldr         r3, [r11, #-0x90]
  00058	e3530000	 cmp         r3, #0
  0005c	1a000002	 bne         |$LN44@CommandCom|

; 1620 :     {
; 1621 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1622 :             L"Unable to get/lock current request!\r\n"
; 1623 :         ));
; 1624 :         status = SD_API_STATUS_INVALID_DEVICE_REQUEST;

  00060	e3a03127	 mov         r3, #0x27, 2
  00064	e50b3080	 str         r3, [r11, #-0x80]

; 1625 :         goto TRANSFER_DONE;

  00068	ea0000de	 b           |$TRANSFER_DONE$40583|
  0006c		 |$LN44@CommandCom|

; 1626 :     } 
; 1627 : 
; 1628 : #ifdef DEBUG
; 1629 :     EnterCriticalSection( &m_critSec );
; 1630 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"+DebugSDHCRegs-------------------------\r\n"));
; 1631 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_CMD 0x%04X \r\n", m_vpSDIOReg->MMC_CMD    ));
; 1632 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_ARG1 0x%04X \r\n", m_vpSDIOReg->MMC_ARG1  ));
; 1633 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_ARG2 0x%04X \r\n", m_vpSDIOReg->MMC_ARG2  ));
; 1634 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_CON  0x%04X \r\n", m_vpSDIOReg->MMC_CON   ));
; 1635 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_STAT 0x%04X \r\n", m_vpSDIOReg->MMC_STAT  ));
; 1636 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_IE 0x%04X \r\n", m_vpSDIOReg->MMC_IE  ));
; 1637 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_CTO 0x%04X \r\n", m_vpSDIOReg->MMC_CTO    ));
; 1638 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_DTO 0x%04X \r\n", m_vpSDIOReg->MMC_DTO    ));
; 1639 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_BLEN 0x%04X \r\n", m_vpSDIOReg->MMC_BLEN  ));
; 1640 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_NBLK 0x%04X \r\n", m_vpSDIOReg->MMC_NBLK  ));
; 1641 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_BUF 0x%04X \r\n", m_vpSDIOReg->MMC_BUF    ));
; 1642 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_SDIO 0x%04X \r\n", m_vpSDIOReg->MMC_SDIO  ));
; 1643 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_REV 0x%04X \r\n", m_vpSDIOReg->MMC_REV    ));
; 1644 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP0 0x%04X \r\n", m_vpSDIOReg->MMC_RSP0  ));
; 1645 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP1 0x%04X \r\n", m_vpSDIOReg->MMC_RSP1  ));
; 1646 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP2 0x%04X \r\n", m_vpSDIOReg->MMC_RSP2  ));
; 1647 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP3 0x%04X \r\n", m_vpSDIOReg->MMC_RSP3  ));
; 1648 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP4 0x%04X \r\n", m_vpSDIOReg->MMC_RSP4  ));
; 1649 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP5 0x%04X \r\n", m_vpSDIOReg->MMC_RSP5  ));
; 1650 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP6 0x%04X \r\n", m_vpSDIOReg->MMC_RSP6  ));
; 1651 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_RSP7 0x%04X \r\n", m_vpSDIOReg->MMC_RSP7  ));
; 1652 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_IOSR 0x%04X \r\n", m_vpSDIOReg->MMC_IOSR  ));
; 1653 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_SYSC 0x%04X \r\n", m_vpSDIOReg->MMC_SYSC  ));
; 1654 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"MMC_SISS 0x%04X \r\n", m_vpSDIOReg->MMC_SISS  ));
; 1655 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"PRCM_PM_WKEN1 0x%04X \r\n", m_vpPRCMReg->ulPM_WKEN1_CORE));
; 1656 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"PRCM_PM_WKST1 0x%04X \r\n", m_vpPRCMReg->ulPM_WKST1_CORE));
; 1657 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"PRCM_PM_AUTOIDEL1 0x%04X \r\n", m_vpPRCMReg->ulCM_AUTOIDLE1_CORE));
; 1658 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"PRCM_PM_FCLKEN1 0x%04X \r\n", m_vpPRCMReg->ulCM_FCLKEN1_CORE));
; 1659 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"PRCM_PM_ICLKEN1 0x%04X \r\n", m_vpPRCMReg->ulCM_ICLKEN1_CORE));
; 1660 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"-DebugSDHCRegs-------------------------\r\n"));
; 1661 :     LeaveCriticalSection( &m_critSec );
; 1662 : #endif
; 1663 :     
; 1664 :     WORD MMC_STAT = Read_MMC_STAT();

  0006c	e59b0000	 ldr         r0, [r11]
  00070	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00074	e14b05b4	 strh        r0, [r11, #-0x54]
  00078	e15b35b4	 ldrh        r3, [r11, #-0x54]
  0007c	e14b39b4	 strh        r3, [r11, #-0x94]

; 1665 :     if( MMC_STAT & MMC_STAT_CB )

  00080	e15b39b4	 ldrh        r3, [r11, #-0x94]
  00084	e3130004	 tst         r3, #4
  00088	0a000062	 beq         |$LN42@CommandCom|

; 1666 :     {
; 1667 :         ASSERT( pRequest->CommandResponse.ResponseType == ResponseR1b );
; 1668 : 
; 1669 :         if( pRequest->CommandResponse.ResponseType == ResponseR1b )

  0008c	e51b3090	 ldr         r3, [r11, #-0x90]
  00090	e283301c	 add         r3, r3, #0x1C
  00094	e5933000	 ldr         r3, [r3]
  00098	e3530002	 cmp         r3, #2
  0009c	1a00005d	 bne         |$LN41@CommandCom|

; 1670 :         {
; 1671 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1672 :                 L"Card in busy state after command!  Delaying...\r\n"));
; 1673 : 
; 1674 :             // calculate timeout conditions
; 1675 :             dwCountStart = GetTickCount();

  000a0	eb000000	 bl          GetTickCount
  000a4	e50b0050	 str         r0, [r11, #-0x50]
  000a8	e51b3050	 ldr         r3, [r11, #-0x50]
  000ac	e50b308c	 str         r3, [r11, #-0x8C]

; 1676 :             dwTimeout = dwCountStart + m_dwMaxTimeout;

  000b0	e59b3000	 ldr         r3, [r11]
  000b4	e283307c	 add         r3, r3, #0x7C
  000b8	e51b208c	 ldr         r2, [r11, #-0x8C]
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e0823003	 add         r3, r2, r3
  000c4	e50b307c	 str         r3, [r11, #-0x7C]

; 1677 :             if( dwTimeout < dwCountStart )

  000c8	e51b207c	 ldr         r2, [r11, #-0x7C]
  000cc	e51b308c	 ldr         r3, [r11, #-0x8C]
  000d0	e1520003	 cmp         r2, r3
  000d4	2a000001	 bcs         |$LN40@CommandCom|

; 1678 :                 fTimeoutOverflow = TRUE;

  000d8	e3a03001	 mov         r3, #1
  000dc	e50b3098	 str         r3, [r11, #-0x98]
  000e0		 |$LN40@CommandCom|
  000e0		 |$LN39@CommandCom|

; 1679 : 
; 1680 :             do {
; 1681 :                 MMC_STAT = Read_MMC_STAT();

  000e0	e59b0000	 ldr         r0, [r11]
  000e4	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  000e8	e14b04bc	 strh        r0, [r11, #-0x4C]
  000ec	e15b34bc	 ldrh        r3, [r11, #-0x4C]
  000f0	e14b39b4	 strh        r3, [r11, #-0x94]

; 1682 : 
; 1683 :                 // check for card ejection
; 1684 :                 if( !SDCardDetect() )

  000f4	e59b3000	 ldr         r3, [r11]
  000f8	e5933000	 ldr         r3, [r3]
  000fc	e2833014	 add         r3, r3, #0x14
  00100	e59b0000	 ldr         r0, [r11]
  00104	e5933000	 ldr         r3, [r3]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff13	 bx          r3
  00110	e50b0048	 str         r0, [r11, #-0x48]
  00114	e51b3048	 ldr         r3, [r11, #-0x48]
  00118	e3530000	 cmp         r3, #0
  0011c	1a000002	 bne         |$LN36@CommandCom|

; 1685 :                 { 
; 1686 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1687 :                         L"Card removed!\r\n"));
; 1688 :                     status = SD_API_STATUS_DEVICE_REMOVED;

  00120	e3a03147	 mov         r3, #0x47, 2
  00124	e50b3080	 str         r3, [r11, #-0x80]

; 1689 :                     goto TRANSFER_DONE;

  00128	ea0000ae	 b           |$TRANSFER_DONE$40583|
  0012c		 |$LN36@CommandCom|

; 1690 :                 }
; 1691 : 
; 1692 :                 // check for a timeout
; 1693 :                 dwCurrentTickCount = GetTickCount();

  0012c	eb000000	 bl          GetTickCount
  00130	e50b0044	 str         r0, [r11, #-0x44]
  00134	e51b3044	 ldr         r3, [r11, #-0x44]
  00138	e50b3084	 str         r3, [r11, #-0x84]

; 1694 :                 if( fTimeoutOverflow ? ( dwTimeout < dwCurrentTickCount && dwCurrentTickCount < dwCountStart )
; 1695 :                     : ( dwTimeout < dwCurrentTickCount || dwCurrentTickCount < dwCountStart ) )

  0013c	e51b3098	 ldr         r3, [r11, #-0x98]
  00140	e3530000	 cmp         r3, #0
  00144	0a00000f	 beq         |$LN51@CommandCom|
  00148	e51b207c	 ldr         r2, [r11, #-0x7C]
  0014c	e51b3084	 ldr         r3, [r11, #-0x84]
  00150	e1520003	 cmp         r2, r3
  00154	2a000006	 bcs         |$LN47@CommandCom|
  00158	e51b2084	 ldr         r2, [r11, #-0x84]
  0015c	e51b308c	 ldr         r3, [r11, #-0x8C]
  00160	e1520003	 cmp         r2, r3
  00164	2a000002	 bcs         |$LN47@CommandCom|
  00168	e3a03001	 mov         r3, #1
  0016c	e50b3040	 str         r3, [r11, #-0x40]
  00170	ea000001	 b           |$LN50@CommandCom|
  00174		 |$LN47@CommandCom|
  00174	e3a03000	 mov         r3, #0
  00178	e50b3040	 str         r3, [r11, #-0x40]
  0017c		 |$LN50@CommandCom|
  0017c	e51b3040	 ldr         r3, [r11, #-0x40]
  00180	e50b303c	 str         r3, [r11, #-0x3C]
  00184	ea00000e	 b           |$LN52@CommandCom|
  00188		 |$LN51@CommandCom|
  00188	e51b207c	 ldr         r2, [r11, #-0x7C]
  0018c	e51b3084	 ldr         r3, [r11, #-0x84]
  00190	e1520003	 cmp         r2, r3
  00194	3a000006	 bcc         |$LN48@CommandCom|
  00198	e51b2084	 ldr         r2, [r11, #-0x84]
  0019c	e51b308c	 ldr         r3, [r11, #-0x8C]
  001a0	e1520003	 cmp         r2, r3
  001a4	3a000002	 bcc         |$LN48@CommandCom|
  001a8	e3a03000	 mov         r3, #0
  001ac	e50b3038	 str         r3, [r11, #-0x38]
  001b0	ea000001	 b           |$LN49@CommandCom|
  001b4		 |$LN48@CommandCom|
  001b4	e3a03001	 mov         r3, #1
  001b8	e50b3038	 str         r3, [r11, #-0x38]
  001bc		 |$LN49@CommandCom|
  001bc	e51b3038	 ldr         r3, [r11, #-0x38]
  001c0	e50b303c	 str         r3, [r11, #-0x3C]
  001c4		 |$LN52@CommandCom|
  001c4	e51b303c	 ldr         r3, [r11, #-0x3C]
  001c8	e3530000	 cmp         r3, #0
  001cc	0a000002	 beq         |$LN34@CommandCom|

; 1696 :                 {
; 1697 :                     DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1698 :                         L"Card BUSY timeout!\r\n"));
; 1699 :                     status = SD_API_STATUS_RESPONSE_TIMEOUT;

  001d0	e3a03153	 mov         r3, #0x53, 2
  001d4	e50b3080	 str         r3, [r11, #-0x80]

; 1700 :                     goto TRANSFER_DONE;

  001d8	ea000082	 b           |$TRANSFER_DONE$40583|
  001dc		 |$LN34@CommandCom|

; 1701 :                 }
; 1702 :             } while( !( MMC_STAT & ( MMC_STAT_EOFB | MMC_STAT_CCRC | MMC_STAT_CTO | MMC_STAT_DCRC | MMC_STAT_DTO ) ) );

  001dc	e15b39b4	 ldrh        r3, [r11, #-0x94]
  001e0	e3130e1f	 tst         r3, #0x1F, 28
  001e4	0affffbd	 beq         |$LN39@CommandCom|

; 1703 : 
; 1704 :             DEBUGMSG(SHC_BUSY_STATE_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1705 :                 L"Card exited busy state.\r\n"));
; 1706 :             ASSERT( MMC_STAT & MMC_STAT_EOFB );
; 1707 :             Write_MMC_STAT( MMC_STAT_CB | MMC_STAT_EOFB );

  001e8	e59b3000	 ldr         r3, [r11]
  001ec	e2830014	 add         r0, r3, #0x14
  001f0	eb000000	 bl          EnterCriticalSection
  001f4	e59b3000	 ldr         r3, [r11]
  001f8	e2833088	 add         r3, r3, #0x88
  001fc	e5933000	 ldr         r3, [r3]
  00200	e2832010	 add         r2, r3, #0x10
  00204	e3a03014	 mov         r3, #0x14
  00208	e1c230b0	 strh        r3, [r2]
  0020c	e59b3000	 ldr         r3, [r11]
  00210	e2830014	 add         r0, r3, #0x14
  00214	eb000000	 bl          LeaveCriticalSection
  00218		 |$LN41@CommandCom|
  00218		 |$LN42@CommandCom|

; 1708 :         }
; 1709 :     }
; 1710 :     //    }
; 1711 : 
; 1712 :     WORD MMC_STAT_OVERWRITE = 0;

  00218	e3a03000	 mov         r3, #0
  0021c	e14b38b8	 strh        r3, [r11, #-0x88]

; 1713 :     if( MMC_STAT & MMC_STAT_CCRC ) // command CRC error

  00220	e15b39b4	 ldrh        r3, [r11, #-0x94]
  00224	e3130c01	 tst         r3, #1, 24
  00228	0a000006	 beq         |$LN32@CommandCom|

; 1714 :     {
; 1715 :         status = SD_API_STATUS_CRC_ERROR;

  0022c	e3a03137	 mov         r3, #0x37, 2
  00230	e50b3080	 str         r3, [r11, #-0x80]

; 1716 :         MMC_STAT_OVERWRITE |= MMC_STAT_CCRC;

  00234	e15b38b8	 ldrh        r3, [r11, #-0x88]
  00238	e3833c01	 orr         r3, r3, #1, 24
  0023c	e1a03803	 mov         r3, r3, lsl #16
  00240	e1a03823	 mov         r3, r3, lsr #16
  00244	e14b38b8	 strh        r3, [r11, #-0x88]
  00248		 |$LN32@CommandCom|

; 1717 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1718 :             L"Got command CRC error!\r\n"));
; 1719 :     }
; 1720 :     if( MMC_STAT & MMC_STAT_CTO ) // command response timeout

  00248	e15b39b4	 ldrh        r3, [r11, #-0x94]
  0024c	e3130080	 tst         r3, #0x80
  00250	0a000006	 beq         |$LN31@CommandCom|

; 1721 :     {
; 1722 :         status = SD_API_STATUS_RESPONSE_TIMEOUT;

  00254	e3a03153	 mov         r3, #0x53, 2
  00258	e50b3080	 str         r3, [r11, #-0x80]

; 1723 :         MMC_STAT_OVERWRITE |= MMC_STAT_CTO;

  0025c	e15b38b8	 ldrh        r3, [r11, #-0x88]
  00260	e3833080	 orr         r3, r3, #0x80
  00264	e1a03803	 mov         r3, r3, lsl #16
  00268	e1a03823	 mov         r3, r3, lsr #16
  0026c	e14b38b8	 strh        r3, [r11, #-0x88]
  00270		 |$LN31@CommandCom|

; 1724 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1725 :             L"Got command response timeout!\r\n"));
; 1726 :     }
; 1727 : 
; 1728 :     if( MMC_STAT_OVERWRITE ) // clear the status error bits

  00270	e15b38b8	 ldrh        r3, [r11, #-0x88]
  00274	e3530000	 cmp         r3, #0
  00278	0a00000c	 beq         |$LN30@CommandCom|

; 1729 :     {
; 1730 :         Write_MMC_STAT(MMC_STAT_OVERWRITE);

  0027c	e59b3000	 ldr         r3, [r11]
  00280	e2830014	 add         r0, r3, #0x14
  00284	eb000000	 bl          EnterCriticalSection
  00288	e59b3000	 ldr         r3, [r11]
  0028c	e2833088	 add         r3, r3, #0x88
  00290	e5933000	 ldr         r3, [r3]
  00294	e2832010	 add         r2, r3, #0x10
  00298	e15b38b8	 ldrh        r3, [r11, #-0x88]
  0029c	e1c230b0	 strh        r3, [r2]
  002a0	e59b3000	 ldr         r3, [r11]
  002a4	e2830014	 add         r0, r3, #0x14
  002a8	eb000000	 bl          LeaveCriticalSection

; 1731 :         goto TRANSFER_DONE;

  002ac	ea00004d	 b           |$TRANSFER_DONE$40583|
  002b0		 |$LN30@CommandCom|

; 1732 :     }
; 1733 : 
; 1734 :     // get the response information
; 1735 :     if(pRequest->CommandResponse.ResponseType == NoResponse)

  002b0	e51b3090	 ldr         r3, [r11, #-0x90]
  002b4	e283301c	 add         r3, r3, #0x1C
  002b8	e5933000	 ldr         r3, [r3]
  002bc	e3530000	 cmp         r3, #0
  002c0	1a000001	 bne         |$LN28@CommandCom|

; 1736 :     {
; 1737 :         DEBUGMSG (SHC_SDBUS_INTERACT_ZONE,(L"CSDIOControllerBase::CommandCompleteHandler: "
; 1738 :             L"GetCmdResponse returned no response (no response expected)\r\n"));
; 1739 :         goto TRANSFER_DONE;

  002c4	ea000047	 b           |$TRANSFER_DONE$40583|

; 1740 :     }
; 1741 :     else{

  002c8	ea000009	 b           |$LN26@CommandCom|
  002cc		 |$LN28@CommandCom|

; 1742 : 
; 1743 :         status =  GetCommandResponse(pRequest);

  002cc	e51b1090	 ldr         r1, [r11, #-0x90]
  002d0	e59b0000	 ldr         r0, [r11]
  002d4	eb000000	 bl          |?GetCommandResponse@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  002d8	e50b0034	 str         r0, [r11, #-0x34]
  002dc	e51b3034	 ldr         r3, [r11, #-0x34]
  002e0	e50b3080	 str         r3, [r11, #-0x80]

; 1744 : 
; 1745 :         if(!SD_API_SUCCESS(status))

  002e4	e51b3080	 ldr         r3, [r11, #-0x80]
  002e8	e3530000	 cmp         r3, #0
  002ec	aa000000	 bge         |$LN25@CommandCom|

; 1746 :         {
; 1747 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1748 :                 L"Error getting response for command:0x%02x\r\n", pRequest->CommandCode
; 1749 :             ));
; 1750 :             goto TRANSFER_DONE;     

  002f0	ea00003c	 b           |$TRANSFER_DONE$40583|
  002f4		 |$LN25@CommandCom|
  002f4		 |$LN26@CommandCom|

; 1751 :         }
; 1752 :     }
; 1753 : 
; 1754 :     if (SD_COMMAND != pRequest->TransferClass) // data transfer

  002f4	e51b3090	 ldr         r3, [r11, #-0x90]
  002f8	e2833010	 add         r3, r3, #0x10
  002fc	e5933000	 ldr         r3, [r3]
  00300	e3530002	 cmp         r3, #2
  00304	0a000037	 beq         |$LN23@CommandCom|

; 1755 :     {
; 1756 :         DWORD cbTransfer = TRANSFER_SIZE(pRequest);

  00308	e51b3090	 ldr         r3, [r11, #-0x90]
  0030c	e2832040	 add         r2, r3, #0x40
  00310	e51b3090	 ldr         r3, [r11, #-0x90]
  00314	e283303c	 add         r3, r3, #0x3C
  00318	e5922000	 ldr         r2, [r2]
  0031c	e5933000	 ldr         r3, [r3]
  00320	e0030392	 mul         r3, r2, r3
  00324	e50b3078	 str         r3, [r11, #-0x78]

; 1757 :         BOOL     fRet;
; 1758 : 
; 1759 :         switch(pRequest->TransferClass)

  00328	e51b3090	 ldr         r3, [r11, #-0x90]
  0032c	e2833010	 add         r3, r3, #0x10
  00330	e5933000	 ldr         r3, [r3]
  00334	e50b3030	 str         r3, [r11, #-0x30]
  00338	e51b3030	 ldr         r3, [r11, #-0x30]
  0033c	e3530000	 cmp         r3, #0
  00340	0a000003	 beq         |$LN20@CommandCom|
  00344	e51b3030	 ldr         r3, [r11, #-0x30]
  00348	e3530001	 cmp         r3, #1
  0034c	0a000012	 beq         |$LN15@CommandCom|
  00350	ea000022	 b           |$LN21@CommandCom|
  00354		 |$LN20@CommandCom|
  00354		 |$LN58@CommandCom|

; 1760 :         {
; 1761 :         case SD_READ:
; 1762 :             __try {
; 1763 :                 fRet = SDIReceive(pRequest->pBlockBuffer, cbTransfer);

  00354	e51b2078	 ldr         r2, [r11, #-0x78]
  00358	e51b3090	 ldr         r3, [r11, #-0x90]
  0035c	e2833048	 add         r3, r3, #0x48
  00360	e5931000	 ldr         r1, [r3]
  00364	e59b0000	 ldr         r0, [r11]
  00368	eb000000	 bl          |?SDIReceive@CSDIOControllerBase@@QAAHPAEK@Z|
  0036c	e50b002c	 str         r0, [r11, #-0x2C]
  00370	e51b302c	 ldr         r3, [r11, #-0x2C]
  00374	e50b3074	 str         r3, [r11, #-0x74]
  00378		 |$LN59@CommandCom|

; 1764 :             }

  00378	ea000002	 b           |$LN60@CommandCom|
  0037c		 |$LN55@CommandCom|

; 1766 :                 fRet = FALSE;

  0037c	e3a03000	 mov         r3, #0
  00380	e50b3074	 str         r3, [r11, #-0x74]
  00384	eaffffff	 b           |$LN60@CommandCom|
  00388		 |$LN60@CommandCom|

; 1767 :             }
; 1768 : 
; 1769 :             if(!fRet)

  00388	e51b3074	 ldr         r3, [r11, #-0x74]
  0038c	e3530000	 cmp         r3, #0
  00390	1a000000	 bne         |$LN18@CommandCom|

; 1770 :             {
; 1771 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1772 :                     L"SDIPollingReceive() failed\r\n"
; 1773 :                 ));
; 1774 :                 goto TRANSFER_DONE;

  00394	ea000013	 b           |$TRANSFER_DONE$40583|
  00398		 |$LN18@CommandCom|

; 1775 :             }
; 1776 :             else
; 1777 :             {
; 1778 : #ifdef ENABLE_DEBUG
; 1779 :                 DWORD dwTemp = 0;
; 1780 :                 while( dwTemp < cbTransfer && (dwTemp < (HEXBUFSIZE / 2 - 1) ) )
; 1781 :                 {
; 1782 :                     szHexBuf[dwTemp*2] = pRequest->pBlockBuffer[dwTemp] / 16;
; 1783 :                     szHexBuf[dwTemp*2+1] = pRequest->pBlockBuffer[dwTemp] % 16;
; 1784 : 
; 1785 :                     if( szHexBuf[dwTemp*2] < 10 )
; 1786 :                         szHexBuf[dwTemp*2] += '0';
; 1787 :                     else
; 1788 :                         szHexBuf[dwTemp*2] += 'a' - 10;
; 1789 : 
; 1790 :                     if( szHexBuf[dwTemp*2+1] < 10 )
; 1791 :                         szHexBuf[dwTemp*2+1] += '0';
; 1792 :                     else
; 1793 :                         szHexBuf[dwTemp*2+1] += 'a' - 10;
; 1794 : 
; 1795 :                     dwTemp++;
; 1796 :                 }
; 1797 :                 szHexBuf[dwTemp*2] = 0;
; 1798 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1799 :                     L"PollingReceive succesfully received %d bytes {%S}\r\n", cbTransfer, szHexBuf
; 1800 :                 ));
; 1801 : #endif
; 1802 :             }
; 1803 :             break;

  00398	ea000010	 b           |$LN21@CommandCom|
  0039c		 |$LN15@CommandCom|
  0039c		 |$LN65@CommandCom|

; 1804 : 
; 1805 :         case SD_WRITE:
; 1806 :             {
; 1807 : #ifdef ENABLE_DEBUG
; 1808 :                 DWORD dwTemp = 0;
; 1809 :                 while( dwTemp < cbTransfer && (dwTemp < (HEXBUFSIZE / 2 - 1) ) )
; 1810 :                 {
; 1811 :                     szHexBuf[dwTemp*2] = pRequest->pBlockBuffer[dwTemp] / 16;
; 1812 :                     szHexBuf[dwTemp*2+1] = pRequest->pBlockBuffer[dwTemp] % 16;
; 1813 : 
; 1814 :                     if( szHexBuf[dwTemp*2] < 10 )
; 1815 :                         szHexBuf[dwTemp*2] += '0';
; 1816 :                     else
; 1817 :                         szHexBuf[dwTemp*2] += 'a' - 10;
; 1818 : 
; 1819 :                     if( szHexBuf[dwTemp*2+1] < 10 )
; 1820 :                         szHexBuf[dwTemp*2+1] += '0';
; 1821 :                     else
; 1822 :                         szHexBuf[dwTemp*2+1] += 'a' - 10;
; 1823 : 
; 1824 :                     dwTemp++;
; 1825 :                 }
; 1826 :                 szHexBuf[dwTemp*2] = 0;
; 1827 : #endif
; 1828 :             }
; 1829 : 
; 1830 :             __try {
; 1831 :                 fRet = SDITransmit(pRequest->pBlockBuffer, cbTransfer);

  0039c	e51b2078	 ldr         r2, [r11, #-0x78]
  003a0	e51b3090	 ldr         r3, [r11, #-0x90]
  003a4	e2833048	 add         r3, r3, #0x48
  003a8	e5931000	 ldr         r1, [r3]
  003ac	e59b0000	 ldr         r0, [r11]
  003b0	eb000000	 bl          |?SDITransmit@CSDIOControllerBase@@QAAHPAEK@Z|
  003b4	e50b0020	 str         r0, [r11, #-0x20]
  003b8	e51b3020	 ldr         r3, [r11, #-0x20]
  003bc	e50b3074	 str         r3, [r11, #-0x74]
  003c0		 |$LN66@CommandCom|

; 1832 :             }

  003c0	ea000002	 b           |$LN67@CommandCom|
  003c4		 |$LN62@CommandCom|

; 1834 :                 fRet = FALSE;

  003c4	e3a03000	 mov         r3, #0
  003c8	e50b3074	 str         r3, [r11, #-0x74]
  003cc	eaffffff	 b           |$LN67@CommandCom|
  003d0		 |$LN67@CommandCom|

; 1835 :             }
; 1836 : 
; 1837 :             if( !fRet )

  003d0	e51b3074	 ldr         r3, [r11, #-0x74]
  003d4	e3530000	 cmp         r3, #0
  003d8	1a000000	 bne         |$LN13@CommandCom|

; 1838 :             {
; 1839 :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1840 :                     L"SDIPollingTransmit() failed\r\n"));
; 1841 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1842 :                     L"PollingTransmit failed to send %d bytes {%S}\r\n", cbTransfer, szHexBuf
; 1843 :                 ));
; 1844 :                 goto TRANSFER_DONE;

  003dc	ea000001	 b           |$TRANSFER_DONE$40583|
  003e0		 |$LN13@CommandCom|
  003e0		 |$LN21@CommandCom|

; 1845 :             }
; 1846 :             else
; 1847 :             {
; 1848 :                 DEBUGMSG (SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1849 :                     L"PollingTransmit succesfully sent %d bytes {%S}\r\n", cbTransfer, szHexBuf
; 1850 :                 ));
; 1851 :             }
; 1852 : 
; 1853 :             break;
; 1854 :         }
; 1855 :         status = SD_API_STATUS_SUCCESS;

  003e0	e3a03000	 mov         r3, #0
  003e4	e50b3080	 str         r3, [r11, #-0x80]
  003e8		 |$LN23@CommandCom|
  003e8		 |$TRANSFER_DONE$40583|

; 1856 :     }
; 1857 : 
; 1858 : TRANSFER_DONE:
; 1859 :     if( pRequest != NULL )

  003e8	e51b3090	 ldr         r3, [r11, #-0x90]
  003ec	e3530000	 cmp         r3, #0
  003f0	0a00003c	 beq         |$LN10@CommandCom|

; 1860 :     {
; 1861 :         if ( ( !( m_fAppCmdMode ) ) && 
; 1862 :             ( (pRequest->CommandCode == SD_CMD_IO_RW_DIRECT) || 
; 1863 :             (pRequest->CommandCode == SD_CMD_IO_RW_EXTENDED) ) )

  003f4	e59b3000	 ldr         r3, [r11]
  003f8	e2833044	 add         r3, r3, #0x44
  003fc	e5933000	 ldr         r3, [r3]
  00400	e3530000	 cmp         r3, #0
  00404	1a00001e	 bne         |$LN9@CommandCom|
  00408	e51b3090	 ldr         r3, [r11, #-0x90]
  0040c	e2833014	 add         r3, r3, #0x14
  00410	e5d33000	 ldrb        r3, [r3]
  00414	e3530034	 cmp         r3, #0x34
  00418	0a000004	 beq         |$LN8@CommandCom|
  0041c	e51b3090	 ldr         r3, [r11, #-0x90]
  00420	e2833014	 add         r3, r3, #0x14
  00424	e5d33000	 ldrb        r3, [r3]
  00428	e3530035	 cmp         r3, #0x35
  0042c	1a000014	 bne         |$LN9@CommandCom|
  00430		 |$LN8@CommandCom|

; 1864 :         {
; 1865 :             Write_MMC_SDIO( Read_MMC_SDIO() & ~( BIT15 | BIT6 ) );

  00430	e59b0000	 ldr         r0, [r11]
  00434	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  00438	e14b01b4	 strh        r0, [r11, #-0x14]
  0043c	e59b3000	 ldr         r3, [r11]
  00440	e2830014	 add         r0, r3, #0x14
  00444	eb000000	 bl          EnterCriticalSection
  00448	e59b3000	 ldr         r3, [r11]
  0044c	e2833088	 add         r3, r3, #0x88
  00450	e5933000	 ldr         r3, [r3]
  00454	e2831034	 add         r1, r3, #0x34
  00458	e15b31b4	 ldrh        r3, [r11, #-0x14]
  0045c	e1a02003	 mov         r2, r3
  00460	e3e03902	 mvn         r3, #2, 18
  00464	e2233040	 eor         r3, r3, #0x40
  00468	e0023003	 and         r3, r2, r3
  0046c	e1a03803	 mov         r3, r3, lsl #16
  00470	e1a03823	 mov         r3, r3, lsr #16
  00474	e1c130b0	 strh        r3, [r1]
  00478	e59b3000	 ldr         r3, [r11]
  0047c	e2830014	 add         r0, r3, #0x14
  00480	eb000000	 bl          LeaveCriticalSection
  00484		 |$LN9@CommandCom|

; 1866 :         }
; 1867 : 
; 1868 :         if( pRequest->CommandResponse.ResponseType == ResponseR4 )

  00484	e51b3090	 ldr         r3, [r11, #-0x90]
  00488	e283301c	 add         r3, r3, #0x1C
  0048c	e5933000	 ldr         r3, [r3]
  00490	e3530005	 cmp         r3, #5
  00494	1a000013	 bne         |$LN7@CommandCom|

; 1869 :         {
; 1870 :             Write_MMC_SDIO( Read_MMC_SDIO() & ~( BIT7 ) );

  00498	e59b0000	 ldr         r0, [r11]
  0049c	eb000000	 bl          |?Read_MMC_SDIO@CSDIOControllerBase@@QAAGXZ|
  004a0	e14b01b2	 strh        r0, [r11, #-0x12]
  004a4	e59b3000	 ldr         r3, [r11]
  004a8	e2830014	 add         r0, r3, #0x14
  004ac	eb000000	 bl          EnterCriticalSection
  004b0	e59b3000	 ldr         r3, [r11]
  004b4	e2833088	 add         r3, r3, #0x88
  004b8	e5933000	 ldr         r3, [r3]
  004bc	e2831034	 add         r1, r3, #0x34
  004c0	e15b31b2	 ldrh        r3, [r11, #-0x12]
  004c4	e1a02003	 mov         r2, r3
  004c8	e3e03080	 mvn         r3, #0x80
  004cc	e0023003	 and         r3, r2, r3
  004d0	e1a03803	 mov         r3, r3, lsl #16
  004d4	e1a03823	 mov         r3, r3, lsr #16
  004d8	e1c130b0	 strh        r3, [r1]
  004dc	e59b3000	 ldr         r3, [r11]
  004e0	e2830014	 add         r0, r3, #0x14
  004e4	eb000000	 bl          LeaveCriticalSection
  004e8		 |$LN7@CommandCom|
  004e8		 |$LN10@CommandCom|

; 1871 :         }
; 1872 :     }
; 1873 : 
; 1874 :     if( status == SD_API_STATUS_SUCCESS )

  004e8	e51b3080	 ldr         r3, [r11, #-0x80]
  004ec	e3530000	 cmp         r3, #0
  004f0	1a000021	 bne         |$LN6@CommandCom|

; 1875 :     {
; 1876 :         if( m_fAppCmdMode )

  004f4	e59b3000	 ldr         r3, [r11]
  004f8	e2833044	 add         r3, r3, #0x44
  004fc	e5933000	 ldr         r3, [r3]
  00500	e3530000	 cmp         r3, #0
  00504	0a000004	 beq         |$LN5@CommandCom|

; 1877 :         {
; 1878 :             m_fAppCmdMode = FALSE;

  00508	e59b3000	 ldr         r3, [r11]
  0050c	e2832044	 add         r2, r3, #0x44
  00510	e3a03000	 mov         r3, #0
  00514	e5823000	 str         r3, [r2]
  00518	ea00000b	 b           |$LN4@CommandCom|
  0051c		 |$LN5@CommandCom|

; 1879 :             DEBUGMSG(SHC_SEND_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1880 :                 L"Switched to Standard Command Mode\r\n"));
; 1881 :         }
; 1882 :         else if( pRequest && pRequest->CommandCode == 55 )

  0051c	e51b3090	 ldr         r3, [r11, #-0x90]
  00520	e3530000	 cmp         r3, #0
  00524	0a000008	 beq         |$LN3@CommandCom|
  00528	e51b3090	 ldr         r3, [r11, #-0x90]
  0052c	e2833014	 add         r3, r3, #0x14
  00530	e5d33000	 ldrb        r3, [r3]
  00534	e3530037	 cmp         r3, #0x37
  00538	1a000003	 bne         |$LN3@CommandCom|

; 1883 :         {
; 1884 :             m_fAppCmdMode = TRUE;

  0053c	e59b3000	 ldr         r3, [r11]
  00540	e2832044	 add         r2, r3, #0x44
  00544	e3a03001	 mov         r3, #1
  00548	e5823000	 str         r3, [r2]
  0054c		 |$LN3@CommandCom|
  0054c		 |$LN4@CommandCom|

; 1885 :             DEBUGMSG(SHC_SEND_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1886 :                 L"Switched to Application Specific Command Mode\r\n"));
; 1887 :         }
; 1888 : 
; 1889 :         if( pRequest && pRequest->CommandCode == SD_CMD_MMC_SEND_OPCOND )

  0054c	e51b3090	 ldr         r3, [r11, #-0x90]
  00550	e3530000	 cmp         r3, #0
  00554	0a000008	 beq         |$LN2@CommandCom|
  00558	e51b3090	 ldr         r3, [r11, #-0x90]
  0055c	e2833014	 add         r3, r3, #0x14
  00560	e5d33000	 ldrb        r3, [r3]
  00564	e3530001	 cmp         r3, #1
  00568	1a000003	 bne         |$LN2@CommandCom|

; 1890 :         {
; 1891 :             DEBUGMSG(SHC_SDBUS_INTERACT_ZONE, (L"CSDIOControllerBase::CommandCompleteHandler: "
; 1892 :                 L"Card is recognized as a MMC\r\n"
; 1893 :             ));
; 1894 :             m_fMMCMode = TRUE;

  0056c	e59b3000	 ldr         r3, [r11]
  00570	e2832040	 add         r2, r3, #0x40
  00574	e3a03001	 mov         r3, #1
  00578	e5823000	 str         r3, [r2]
  0057c		 |$LN2@CommandCom|
  0057c		 |$LN6@CommandCom|

; 1895 :         }
; 1896 :     }
; 1897 : 
; 1898 :     // Clear the MMC_STAT register
; 1899 :     Write_MMC_STAT( Read_MMC_STAT() & (~MMC_STAT_CIRQ) );

  0057c	e59b0000	 ldr         r0, [r11]
  00580	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00584	e14b01b0	 strh        r0, [r11, #-0x10]
  00588	e59b3000	 ldr         r3, [r11]
  0058c	e2830014	 add         r0, r3, #0x14
  00590	eb000000	 bl          EnterCriticalSection
  00594	e59b3000	 ldr         r3, [r11]
  00598	e2833088	 add         r3, r3, #0x88
  0059c	e5933000	 ldr         r3, [r3]
  005a0	e2831010	 add         r1, r3, #0x10
  005a4	e15b31b0	 ldrh        r3, [r11, #-0x10]
  005a8	e1a02003	 mov         r2, r3
  005ac	e3e03a02	 mvn         r3, #2, 20
  005b0	e0023003	 and         r3, r2, r3
  005b4	e1a03803	 mov         r3, r3, lsl #16
  005b8	e1a03823	 mov         r3, r3, lsr #16
  005bc	e1c130b0	 strh        r3, [r1]
  005c0	e59b3000	 ldr         r3, [r11]
  005c4	e2830014	 add         r0, r3, #0x14
  005c8	eb000000	 bl          LeaveCriticalSection

; 1900 : 
; 1901 :     ClockOff();

  005cc	e59b0000	 ldr         r0, [r11]
  005d0	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 1902 :     if( pRequest != NULL )

  005d4	e51b3090	 ldr         r3, [r11, #-0x90]
  005d8	e3530000	 cmp         r3, #0
  005dc	0a000008	 beq         |$LN1@CommandCom|

; 1903 :     {
; 1904 :         IndicateBusRequestComplete(pRequest, status);

  005e0	e51b2080	 ldr         r2, [r11, #-0x80]
  005e4	e51b1090	 ldr         r1, [r11, #-0x90]
  005e8	e59b3000	 ldr         r3, [r11]
  005ec	e5933000	 ldr         r3, [r3]
  005f0	e2833004	 add         r3, r3, #4
  005f4	e59b0000	 ldr         r0, [r11]
  005f8	e5933000	 ldr         r3, [r3]
  005fc	e1a0e00f	 mov         lr, pc
  00600	e12fff13	 bx          r3
  00604		 |$LN1@CommandCom|

; 1905 :     }
; 1906 :     return TRUE;

  00604	e3a03001	 mov         r3, #1
  00608	e50b305c	 str         r3, [r11, #-0x5C]
  0060c		 |$LN53@CommandCom|

; 1907 : }

  0060c	e51b005c	 ldr         r0, [r11, #-0x5C]
  00610	e24bd00c	 sub         sp, r11, #0xC
  00614	e89d6800	 ldmia       sp, {r11, sp, lr}
  00618	e12fff1e	 bx          lr

			 ENDP  ; |?CommandCompleteHandler@CSDIOControllerBase@@QAAHXZ|, CSDIOControllerBase::CommandCompleteHandler

  0061c		 |$LN61@CommandCom|
  0061c		 |$LN91@CommandCom|

; 1833 :             __except(SDProcessException(GetExceptionInformation())) {

  0061c	e52de004	 str         lr, [sp, #-4]!
  00620	e24bb004	 sub         r11, r11, #4
  00624		 |$LN64@CommandCom|
  00624		 |$LN95@CommandCom|
  00624	e50b0060	 str         r0, [r11, #-0x60]
  00628	e51b3060	 ldr         r3, [r11, #-0x60]
  0062c	e50b301c	 str         r3, [r11, #-0x1C]
  00630	e51b001c	 ldr         r0, [r11, #-0x1C]
  00634	eb000000	 bl          SDProcessException
  00638	e50b0018	 str         r0, [r11, #-0x18]
  0063c	e51b0018	 ldr         r0, [r11, #-0x18]
  00640		 |$LN63@CommandCom|
  00640	e49df004	 ldr         pc, [sp], #4
  00644		 |$LN96@CommandCom|
  00644		 |$LN54@CommandCom|
  00644		 |$LN93@CommandCom|

; 1765 :             __except(SDProcessException(GetExceptionInformation())) {

  00644	e52de004	 str         lr, [sp, #-4]!
  00648	e24bb004	 sub         r11, r11, #4
  0064c		 |$LN57@CommandCom|
  0064c		 |$LN97@CommandCom|
  0064c	e50b0064	 str         r0, [r11, #-0x64]
  00650	e51b3064	 ldr         r3, [r11, #-0x64]
  00654	e50b3028	 str         r3, [r11, #-0x28]
  00658	e51b0028	 ldr         r0, [r11, #-0x28]
  0065c	eb000000	 bl          SDProcessException
  00660	e50b0024	 str         r0, [r11, #-0x24]
  00664	e51b0024	 ldr         r0, [r11, #-0x24]
  00668		 |$LN56@CommandCom|
  00668	e49df004	 ldr         pc, [sp], #4
  0066c		 |$LN98@CommandCom|
  0066c		 |$LN94@CommandCom|
	EXPORT	|?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ| ; CSDIOControllerBase::SDHCControllerIstThreadImpl
	IMPORT	|InterruptDone|
	IMPORT	|CeSetThreadPriority|

  00000			 AREA	 |.pdata|, PDATA
|$T42610| DCD	|$LN16@SDHCContro|
	DCD	0x40006004
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ| PROC ; CSDIOControllerBase::SDHCControllerIstThreadImpl

; 1160 : {

  00000		 |$LN16@SDHCContro|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd018	 sub         sp, sp, #0x18
  00010		 |$M42607|

; 1161 :     DWORD dwWaitTime    = INFINITE;

  00010	e3e03000	 mvn         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 1162 : 
; 1163 :     if (!CeSetThreadPriority(GetCurrentThread(), m_dwSDIOPriority)) {

  00018	e59d3020	 ldr         r3, [sp, #0x20]
  0001c	e2833058	 add         r3, r3, #0x58
  00020	e5931000	 ldr         r1, [r3]
  00024	e3a00041	 mov         r0, #0x41
  00028	eb000000	 bl          CeSetThreadPriority
  0002c	e58d000c	 str         r0, [sp, #0xC]

; 1164 :         DEBUGMSG(SDCARD_ZONE_WARN, (L"CSDIOControllerBase::SDHCControllerIstThreadImpl: "
; 1165 :             L"Warning, failed to set CEThreadPriority\r\n"
; 1166 :         ));
; 1167 :     }
; 1168 : 
; 1169 :     InterruptDone( m_dwControllerSysIntr );

  00030	e59d3020	 ldr         r3, [sp, #0x20]
  00034	e283306c	 add         r3, r3, #0x6C
  00038	e5930000	 ldr         r0, [r3]
  0003c	eb000000	 bl          InterruptDone
  00040		 |$LN6@SDHCContro|

; 1170 : 
; 1171 :     while (TRUE) {
; 1172 :         // wait for the SDIO/controller interrupt
; 1173 :         if (WAIT_OBJECT_0 != WaitForSingleObject(m_hControllerISTEvent, dwWaitTime)) 

  00040	e59d1000	 ldr         r1, [sp]
  00044	e59d3020	 ldr         r3, [sp, #0x20]
  00048	e2833048	 add         r3, r3, #0x48
  0004c	e5930000	 ldr         r0, [r3]
  00050	eb000000	 bl          WaitForSingleObject
  00054	e58d0010	 str         r0, [sp, #0x10]
  00058	e59d3010	 ldr         r3, [sp, #0x10]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000000	 beq         |$LN4@SDHCContro|

; 1174 :         {
; 1175 :             DEBUGMSG(SDCARD_ZONE_WARN, (L"CSDIOControllerBase::SDHCControllerIstThreadImpl: "
; 1176 :                 L"Wait Failed!\r\n"
; 1177 :             ));
; 1178 :             break;

  00064	ea00003f	 b           |$LN5@SDHCContro|
  00068		 |$LN4@SDHCContro|

; 1179 :         }
; 1180 : 
; 1181 :         if (m_fDriverShutdown) {

  00068	e59d3020	 ldr         r3, [sp, #0x20]
  0006c	e2833060	 add         r3, r3, #0x60
  00070	e5933000	 ldr         r3, [r3]
  00074	e3530000	 cmp         r3, #0
  00078	0a000000	 beq         |$LN3@SDHCContro|

; 1182 :             DEBUGMSG(SDCARD_ZONE_WARN, (L"CSDIOControllerBase::SDHCControllerIstThreadImpl: "
; 1183 :                 L"Thread exiting!\r\n"
; 1184 :             ));
; 1185 :             break;

  0007c	ea000039	 b           |$LN5@SDHCContro|
  00080		 |$LN3@SDHCContro|

; 1186 :         }
; 1187 : 
; 1188 :         WORD wStat;
; 1189 : 
; 1190 :         wStat = Read_MMC_STAT() & INREG16(&m_vpSDIOReg->MMC_IE) & 0x7fff;

  00080	e59d0020	 ldr         r0, [sp, #0x20]
  00084	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00088	e1cd01b4	 strh        r0, [sp, #0x14]
  0008c	e1dd31b4	 ldrh        r3, [sp, #0x14]
  00090	e1a02003	 mov         r2, r3
  00094	e59d3020	 ldr         r3, [sp, #0x20]
  00098	e2833088	 add         r3, r3, #0x88
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e2833014	 add         r3, r3, #0x14
  000a4	e1d330b0	 ldrh        r3, [r3]
  000a8	e0022003	 and         r2, r2, r3
  000ac	e3a03c7f	 mov         r3, #0x7F, 24
  000b0	e38330ff	 orr         r3, r3, #0xFF
  000b4	e0023003	 and         r3, r2, r3
  000b8	e1a03803	 mov         r3, r3, lsl #16
  000bc	e1a03823	 mov         r3, r3, lsr #16
  000c0	e1cd30b4	 strh        r3, [sp, #4]

; 1191 : 
; 1192 :         if( wStat & (MMC_IE_EOC|MMC_STAT_CERR|MMC_STAT_CCRC|MMC_STAT_CTO) )

  000c4	e1dd30b4	 ldrh        r3, [sp, #4]
  000c8	e1a02003	 mov         r2, r3
  000cc	e3a03c41	 mov         r3, #0x41, 24
  000d0	e3833081	 orr         r3, r3, #0x81
  000d4	e1120003	 tst         r2, r3
  000d8	0a000001	 beq         |$LN2@SDHCContro|

; 1193 :         {
; 1194 :             CommandCompleteHandler();

  000dc	e59d0020	 ldr         r0, [sp, #0x20]
  000e0	eb000000	 bl          |?CommandCompleteHandler@CSDIOControllerBase@@QAAHXZ|
  000e4		 |$LN2@SDHCContro|

; 1195 :         }
; 1196 : 
; 1197 :         if( wStat & MMC_STAT_CIRQ )

  000e4	e1dd30b4	 ldrh        r3, [sp, #4]
  000e8	e3130a02	 tst         r3, #2, 20
  000ec	0a000018	 beq         |$LN1@SDHCContro|

; 1198 :         {
; 1199 :             ASSERT( m_fSDIOInterruptsEnabled );
; 1200 :             // indicate that the card is interrupting
; 1201 :             DEBUGMSG(SHC_INTERRUPT_ZONE, (L"CSDIOControllerBase::SDHCControllerIstThreadImpl: "
; 1202 :                 L"Receibed SDIO interrupt!\r\n"));
; 1203 : 
; 1204 :             // disable the SDIO interrupt
; 1205 :             CLRREG16(&m_vpSDIOReg->MMC_IE, MMC_IE_CIRQ);

  000f0	e59d3020	 ldr         r3, [sp, #0x20]
  000f4	e2833088	 add         r3, r3, #0x88
  000f8	e5933000	 ldr         r3, [r3]
  000fc	e2833014	 add         r3, r3, #0x14
  00100	e1d330b0	 ldrh        r3, [r3]
  00104	e1a02003	 mov         r2, r3
  00108	e3e03a02	 mvn         r3, #2, 20
  0010c	e0023003	 and         r3, r2, r3
  00110	e1a02803	 mov         r2, r3, lsl #16
  00114	e1a02822	 mov         r2, r2, lsr #16
  00118	e59d3020	 ldr         r3, [sp, #0x20]
  0011c	e2833088	 add         r3, r3, #0x88
  00120	e5933000	 ldr         r3, [r3]
  00124	e2833014	 add         r3, r3, #0x14
  00128	e1c320b0	 strh        r2, [r3]

; 1206 :             // notify the SDBusDriver of the SDIO interrupt
; 1207 :             m_fSDIOInterruptInService = TRUE;

  0012c	e59d3020	 ldr         r3, [sp, #0x20]
  00130	e2832028	 add         r2, r3, #0x28
  00134	e3a03001	 mov         r3, #1
  00138	e5823000	 str         r3, [r2]

; 1208 :             SDHCDIndicateSlotStateChange(m_pHCContext, 0, DeviceInterrupting);

  0013c	e3a02003	 mov         r2, #3
  00140	e3a01000	 mov         r1, #0
  00144	e59d3020	 ldr         r3, [sp, #0x20]
  00148	e2833004	 add         r3, r3, #4
  0014c	e5930000	 ldr         r0, [r3]
  00150	eb000000	 bl          SDHCDIndicateSlotStateChange
  00154		 |$LN1@SDHCContro|

; 1209 :         }
; 1210 : 
; 1211 :         InterruptDone( m_dwControllerSysIntr );

  00154	e59d3020	 ldr         r3, [sp, #0x20]
  00158	e283306c	 add         r3, r3, #0x6C
  0015c	e5930000	 ldr         r0, [r3]
  00160	eb000000	 bl          InterruptDone

; 1212 :     }

  00164	eaffffb5	 b           |$LN6@SDHCContro|
  00168		 |$LN5@SDHCContro|

; 1213 : 
; 1214 :     DEBUGMSG(SDCARD_ZONE_FUNC, (L"-CSDIOControllerBase::SDHCControllerIstThreadImpl\r\n"));
; 1215 :     return 0;

  00168	e3a03000	 mov         r3, #0
  0016c	e58d3008	 str         r3, [sp, #8]

; 1216 : }

  00170	e59d0008	 ldr         r0, [sp, #8]
  00174	e28dd018	 add         sp, sp, #0x18
  00178	e89d6000	 ldmia       sp, {sp, lr}
  0017c	e12fff1e	 bx          lr
  00180		 |$M42608|

			 ENDP  ; |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ|, CSDIOControllerBase::SDHCControllerIstThreadImpl

	EXPORT	|?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandlerImpl
	IMPORT	|InterruptMask|

  00000			 AREA	 |.pdata|, PDATA
|$T42619| DCD	|$LN17@SDHCBusReq|
	DCD	0x40008404
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandlerImpl

; 1535 : {

  00000		 |$LN17@SDHCBusReq|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd01c	 sub         sp, sp, #0x1C
  00010		 |$M42616|

; 1536 :     DEBUGCHK(pRequest);
; 1537 : 
; 1538 :     SD_API_STATUS   status;
; 1539 :     BOOL            fWriteTransferMode = FALSE;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3004	 str         r3, [sp, #4]

; 1540 : 
; 1541 :     DEBUGMSG(SHC_SEND_ZONE, (L"CSDIOControllerBase::SDHCBusRequestHandlerImpl: "
; 1542 :         L"CMD: [%d]\r\n", pRequest->CommandCode
; 1543 :     ));
; 1544 : 
; 1545 :     // acquire the device lock to protect from device removal
; 1546 :     SDHCDAcquireHCLock(m_pHCContext);

  00018	e59d3024	 ldr         r3, [sp, #0x24]
  0001c	e2833004	 add         r3, r3, #4
  00020	e5933000	 ldr         r3, [r3]
  00024	e2830024	 add         r0, r3, #0x24
  00028	eb000000	 bl          EnterCriticalSection

; 1547 : 
; 1548 :     if ( m_pCurrentRequest) {

  0002c	e59d3024	 ldr         r3, [sp, #0x24]
  00030	e2833090	 add         r3, r3, #0x90
  00034	e5933000	 ldr         r3, [r3]
  00038	e3530000	 cmp         r3, #0
  0003c	0a00000c	 beq         |$LN10@SDHCBusReq|

; 1549 :         IndicateBusRequestComplete(pRequest, SD_API_STATUS_CANCELED);

  00040	e3a0214f	 mov         r2, #0x4F, 2
  00044	e59d1028	 ldr         r1, [sp, #0x28]
  00048	e59d3024	 ldr         r3, [sp, #0x24]
  0004c	e5933000	 ldr         r3, [r3]
  00050	e2833004	 add         r3, r3, #4
  00054	e59d0024	 ldr         r0, [sp, #0x24]
  00058	e5933000	 ldr         r3, [r3]
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3

; 1550 :         m_pCurrentRequest = NULL;

  00064	e59d3024	 ldr         r3, [sp, #0x24]
  00068	e2832090	 add         r2, r3, #0x90
  0006c	e3a03000	 mov         r3, #0
  00070	e5823000	 str         r3, [r2]
  00074		 |$LN10@SDHCBusReq|

; 1551 :     }
; 1552 : 
; 1553 :     m_fCurrentRequestFastPath = FALSE;

  00074	e59d3024	 ldr         r3, [sp, #0x24]
  00078	e2832094	 add         r2, r3, #0x94
  0007c	e3a03000	 mov         r3, #0
  00080	e5823000	 str         r3, [r2]

; 1554 :     m_pCurrentRequest = pRequest ;

  00084	e59d3024	 ldr         r3, [sp, #0x24]
  00088	e2832090	 add         r2, r3, #0x90
  0008c	e59d3028	 ldr         r3, [sp, #0x28]
  00090	e5823000	 str         r3, [r2]

; 1555 :     // if no data transfer involved, use FAST PATH
; 1556 :     if (pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE && 
; 1557 :             !( SD_COMMAND != pRequest->TransferClass && 
; 1558 :                 pRequest->NumBlocks * pRequest->BlockSize >=  NUM_BYTE_FOR_POLLING_MODE)){   // We do fast path here.

  00094	e59d3028	 ldr         r3, [sp, #0x28]
  00098	e283300c	 add         r3, r3, #0xC
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e3130102	 tst         r3, #2, 2
  000a4	0a000040	 beq         |$LN9@SDHCBusReq|
  000a8	e59d3028	 ldr         r3, [sp, #0x28]
  000ac	e2833010	 add         r3, r3, #0x10
  000b0	e5933000	 ldr         r3, [r3]
  000b4	e3530002	 cmp         r3, #2
  000b8	0a000008	 beq         |$LN8@SDHCBusReq|
  000bc	e59d3028	 ldr         r3, [sp, #0x28]
  000c0	e283203c	 add         r2, r3, #0x3C
  000c4	e59d3028	 ldr         r3, [sp, #0x28]
  000c8	e2833040	 add         r3, r3, #0x40
  000cc	e5922000	 ldr         r2, [r2]
  000d0	e5933000	 ldr         r3, [r3]
  000d4	e0030392	 mul         r3, r2, r3
  000d8	e3530b02	 cmp         r3, #2, 22
  000dc	2a000032	 bcs         |$LN9@SDHCBusReq|
  000e0		 |$LN8@SDHCBusReq|

; 1559 :         m_fCurrentRequestFastPath = TRUE;

  000e0	e59d3024	 ldr         r3, [sp, #0x24]
  000e4	e2832094	 add         r2, r3, #0x94
  000e8	e3a03001	 mov         r3, #1
  000ec	e5823000	 str         r3, [r2]

; 1560 :         InterruptMask(m_dwControllerSysIntr,TRUE);

  000f0	e3a01001	 mov         r1, #1
  000f4	e59d3024	 ldr         r3, [sp, #0x24]
  000f8	e283306c	 add         r3, r3, #0x6C
  000fc	e5930000	 ldr         r0, [r3]
  00100	eb000000	 bl          InterruptMask

; 1561 :         status = SendCommand(pRequest);

  00104	e59d1028	 ldr         r1, [sp, #0x28]
  00108	e59d0024	 ldr         r0, [sp, #0x24]
  0010c	eb000000	 bl          |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  00110	e58d0010	 str         r0, [sp, #0x10]
  00114	e59d3010	 ldr         r3, [sp, #0x10]
  00118	e58d3000	 str         r3, [sp]

; 1562 :         if ( status == SD_API_STATUS_PENDING ) { // Polling for completion.

  0011c	e59d3000	 ldr         r3, [sp]
  00120	e3530001	 cmp         r3, #1
  00124	1a00001a	 bne         |$LN7@SDHCBusReq|
  00128		 |$LN6@SDHCBusReq|

; 1563 :             while (m_pCurrentRequest) {

  00128	e59d3024	 ldr         r3, [sp, #0x24]
  0012c	e2833090	 add         r3, r3, #0x90
  00130	e5933000	 ldr         r3, [r3]
  00134	e3530000	 cmp         r3, #0
  00138	0a000011	 beq         |$LN5@SDHCBusReq|

; 1564 :                 if( Read_MMC_STAT() & INREG16(&m_vpSDIOReg->MMC_IE) & (MMC_IE_EOC|MMC_STAT_CERR|MMC_STAT_CCRC|MMC_STAT_CTO)) {

  0013c	e59d0024	 ldr         r0, [sp, #0x24]
  00140	eb000000	 bl          |?Read_MMC_STAT@CSDIOControllerBase@@QAAGXZ|
  00144	e1cd01b4	 strh        r0, [sp, #0x14]
  00148	e1dd31b4	 ldrh        r3, [sp, #0x14]
  0014c	e1a02003	 mov         r2, r3
  00150	e59d3024	 ldr         r3, [sp, #0x24]
  00154	e2833088	 add         r3, r3, #0x88
  00158	e5933000	 ldr         r3, [r3]
  0015c	e2833014	 add         r3, r3, #0x14
  00160	e1d330b0	 ldrh        r3, [r3]
  00164	e0022003	 and         r2, r2, r3
  00168	e3a03c41	 mov         r3, #0x41, 24
  0016c	e3833081	 orr         r3, r3, #0x81
  00170	e1120003	 tst         r2, r3
  00174	0a000001	 beq         |$LN4@SDHCBusReq|

; 1565 :                     CommandCompleteHandler();

  00178	e59d0024	 ldr         r0, [sp, #0x24]
  0017c	eb000000	 bl          |?CommandCompleteHandler@CSDIOControllerBase@@QAAHXZ|
  00180		 |$LN4@SDHCBusReq|

; 1566 :                 }
; 1567 :             }               

  00180	eaffffe8	 b           |$LN6@SDHCBusReq|
  00184		 |$LN5@SDHCBusReq|

; 1568 :             status = FastPathStatus;

  00184	e59d3024	 ldr         r3, [sp, #0x24]
  00188	e2833098	 add         r3, r3, #0x98
  0018c	e5933000	 ldr         r3, [r3]
  00190	e58d3000	 str         r3, [sp]
  00194		 |$LN7@SDHCBusReq|

; 1569 :         }
; 1570 : 
; 1571 :         InterruptMask(m_dwControllerSysIntr,FALSE);

  00194	e3a01000	 mov         r1, #0
  00198	e59d3024	 ldr         r3, [sp, #0x24]
  0019c	e283306c	 add         r3, r3, #0x6C
  001a0	e5930000	 ldr         r0, [r3]
  001a4	eb000000	 bl          InterruptMask

; 1572 :         ASSERT(m_fCurrentRequestFastPath);
; 1573 :     }
; 1574 :     else 

  001a8	ea00000d	 b           |$LN3@SDHCBusReq|
  001ac		 |$LN9@SDHCBusReq|

; 1575 :     {
; 1576 :         pRequest->SystemFlags &= ~SD_FAST_PATH_AVAILABLE ;

  001ac	e59d3028	 ldr         r3, [sp, #0x28]
  001b0	e283300c	 add         r3, r3, #0xC
  001b4	e5932000	 ldr         r2, [r3]
  001b8	e3e03102	 mvn         r3, #2, 2
  001bc	e0022003	 and         r2, r2, r3
  001c0	e59d3028	 ldr         r3, [sp, #0x28]
  001c4	e283300c	 add         r3, r3, #0xC
  001c8	e5832000	 str         r2, [r3]

; 1577 :         status = SendCommand(pRequest);

  001cc	e59d1028	 ldr         r1, [sp, #0x28]
  001d0	e59d0024	 ldr         r0, [sp, #0x24]
  001d4	eb000000	 bl          |?SendCommand@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  001d8	e58d0018	 str         r0, [sp, #0x18]
  001dc	e59d3018	 ldr         r3, [sp, #0x18]
  001e0	e58d3000	 str         r3, [sp]
  001e4		 |$LN3@SDHCBusReq|
  001e4		 |$EXIT$40567|

; 1578 :         if(!SD_API_SUCCESS(status))
; 1579 :         {
; 1580 :             DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDHCBusRequestHandlerImpl: "
; 1581 :                 L"Error sending command:0x%02x\r\n", pRequest->CommandCode
; 1582 :             ));
; 1583 :             goto EXIT;      
; 1584 :         }
; 1585 :     }
; 1586 : 
; 1587 : 
; 1588 : EXIT:
; 1589 :     SDHCDReleaseHCLock(m_pHCContext);

  001e4	e59d3024	 ldr         r3, [sp, #0x24]
  001e8	e2833004	 add         r3, r3, #4
  001ec	e5933000	 ldr         r3, [r3]
  001f0	e2830024	 add         r0, r3, #0x24
  001f4	eb000000	 bl          LeaveCriticalSection

; 1590 :     return status;

  001f8	e59d3000	 ldr         r3, [sp]
  001fc	e58d300c	 str         r3, [sp, #0xC]

; 1591 : }

  00200	e59d000c	 ldr         r0, [sp, #0xC]
  00204	e28dd01c	 add         sp, sp, #0x1C
  00208	e89d6000	 ldmia       sp, {sp, lr}
  0020c	e12fff1e	 bx          lr
  00210		 |$M42617|

			 ENDP  ; |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandlerImpl

	EXPORT	|?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| ; CSDIOControllerBase::SDHCBusRequestHandler

  00000			 AREA	 |.pdata|, PDATA
|$T42627| DCD	|$LN5@SDHCBusReq@2|
	DCD	0x40001204
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z| PROC ; CSDIOControllerBase::SDHCBusRequestHandler

; 2114 : {

  00000		 |$LN5@SDHCBusReq@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42624|

; 2115 :     // get our extension 
; 2116 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e283304c	 add         r3, r3, #0x4C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3000	 str         r3, [sp]

; 2117 :     return pController->SDHCBusRequestHandlerImpl(pRequest);

  00020	e59d101c	 ldr         r1, [sp, #0x1C]
  00024	e59d0000	 ldr         r0, [sp]
  00028	eb000000	 bl          |?SDHCBusRequestHandlerImpl@CSDIOControllerBase@@QAAJPAU_SD_BUS_REQUEST@@@Z|
  0002c	e58d0008	 str         r0, [sp, #8]
  00030	e59d3008	 ldr         r3, [sp, #8]
  00034	e58d3004	 str         r3, [sp, #4]

; 2118 : }

  00038	e59d0004	 ldr         r0, [sp, #4]
  0003c	e28dd00c	 add         sp, sp, #0xC
  00040	e89d6000	 ldmia       sp, {sp, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M42625|

			 ENDP  ; |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|, CSDIOControllerBase::SDHCBusRequestHandler

	EXPORT	|?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z| ; CSDIOControllerBase::SDHCControllerIstThread

  00000			 AREA	 |.pdata|, PDATA
|$T42635| DCD	|$LN5@SDHCContro@2|
	DCD	0x40000f04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z| PROC ; CSDIOControllerBase::SDHCControllerIstThread

; 1146 : {

  00000		 |$LN5@SDHCContro@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42632|

; 1147 :     CSDIOControllerBase *pController = (CSDIOControllerBase*)lpParameter;

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e58d3000	 str         r3, [sp]

; 1148 :     return pController->SDHCControllerIstThreadImpl();

  00018	e59d0000	 ldr         r0, [sp]
  0001c	eb000000	 bl          |?SDHCControllerIstThreadImpl@CSDIOControllerBase@@QAAKXZ|
  00020	e58d0008	 str         r0, [sp, #8]
  00024	e59d3008	 ldr         r3, [sp, #8]
  00028	e58d3004	 str         r3, [sp, #4]

; 1149 : }

  0002c	e59d0004	 ldr         r0, [sp, #4]
  00030	e28dd00c	 add         sp, sp, #0xC
  00034	e89d6000	 ldmia       sp, {sp, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M42633|

			 ENDP  ; |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z|, CSDIOControllerBase::SDHCControllerIstThread

	EXPORT	|?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ| ; CSDIOControllerBase::SDHCInitializeImpl
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\twl.h

  00000			 AREA	 |.pdata|, PDATA
|$T42696| DCD	|$LN55@SDHCInitia|
	DCD	0x4001ab04
; Function compile flags: /Odsp
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\sdhc\base\sdhc.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ| PROC ; CSDIOControllerBase::SDHCInitializeImpl

; 1328 : {

  00000		 |$LN55@SDHCInitia|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd0cc	 sub         sp, sp, #0xCC
  00010		 |$M42693|

; 1329 :     SD_API_STATUS status = SD_API_STATUS_INSUFFICIENT_RESOURCES; // intermediate status

  00010	e3a0313b	 mov         r3, #0x3B, 2
  00014	e58d301c	 str         r3, [sp, #0x1C]

; 1330 :     DWORD         threadID;
; 1331 :     unsigned long  ulLong;
; 1332 :     WORD wRegValue;
; 1333 :     DWORD *pdwSDIOIrq;
; 1334 :     DWORD dwSDIOIrqLen;
; 1335 : 
; 1336 :     m_fDriverShutdown = FALSE;

  00018	e59d30d4	 ldr         r3, [sp, #0xD4]
  0001c	e2832060	 add         r2, r3, #0x60
  00020	e3a03000	 mov         r3, #0
  00024	e5823000	 str         r3, [r2]

; 1337 :     SoftwareReset(SOFT_RESET_ALL);

  00028	e3a01002	 mov         r1, #2
  0002c	e59d00d4	 ldr         r0, [sp, #0xD4]
  00030	eb000000	 bl          |?SoftwareReset@CSDIOControllerBase@@QAAXE@Z|

; 1338 : 
; 1339 :     // activate the clock
; 1340 :     ClockOn();

  00034	e59d00d4	 ldr         r0, [sp, #0xD4]
  00038	eb000000	 bl          |?ClockOn@CSDIOControllerBase@@QAAXXZ|

; 1341 : 
; 1342 :     // --- Setup MMC config register ---
; 1343 :     // Data Bus width 1 bit - MMC/SD mode - Power Up Up/Normal - Little Endian - Clock Divider
; 1344 :     wRegValue = 0;

  0003c	e3a03000	 mov         r3, #0
  00040	e1cd32b0	 strh        r3, [sp, #0x20]

; 1345 :     wRegValue |= VALUE_MMC_CON_DW_1BIT | VALUE_MMC_CON_MODE_MMCSD | 
; 1346 :         VALUE_MMC_CON_POWERUP_UP | VALUE_MMC_CON_BE_LITTLEENDIAN;

  00044	e1dd32b0	 ldrh        r3, [sp, #0x20]
  00048	e3833b02	 orr         r3, r3, #2, 22
  0004c	e1a03803	 mov         r3, r3, lsl #16
  00050	e1a03823	 mov         r3, r3, lsr #16
  00054	e1cd32b0	 strh        r3, [sp, #0x20]

; 1347 : 
; 1348 :     ulLong = (MMCSD_CLOCK_INPUT / MMCSD_CLOCK_INIT);

  00058	e3a030f0	 mov         r3, #0xF0
  0005c	e58d3014	 str         r3, [sp, #0x14]

; 1349 :     if (MMCSD_CLOCK_INPUT % MMCSD_CLOCK_INIT) ulLong++;

  00060	ea000002	 b           |$LN32@SDHCInitia|
  00064	e59d3014	 ldr         r3, [sp, #0x14]
  00068	e2833001	 add         r3, r3, #1
  0006c	e58d3014	 str         r3, [sp, #0x14]
  00070		 |$LN32@SDHCInitia|

; 1350 :     wRegValue |= (ulLong & MASK_MMC_CON_CLKD);

  00070	e59d2014	 ldr         r2, [sp, #0x14]
  00074	e3a03c03	 mov         r3, #3, 24
  00078	e38330ff	 orr         r3, r3, #0xFF
  0007c	e0022003	 and         r2, r2, r3
  00080	e1dd32b0	 ldrh        r3, [sp, #0x20]
  00084	e1833002	 orr         r3, r3, r2
  00088	e1a03803	 mov         r3, r3, lsl #16
  0008c	e1a03823	 mov         r3, r3, lsr #16
  00090	e1cd32b0	 strh        r3, [sp, #0x20]

; 1351 : 
; 1352 :     OUTREG16(&m_vpSDIOReg->MMC_CON, wRegValue);

  00094	e59d30d4	 ldr         r3, [sp, #0xD4]
  00098	e2833088	 add         r3, r3, #0x88
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e283200c	 add         r2, r3, #0xC
  000a4	e1dd32b0	 ldrh        r3, [sp, #0x20]
  000a8	e1c230b0	 strh        r3, [r2]

; 1353 :     DEBUGMSG(SDCARD_ZONE_INIT, (L"CSDIOControllerBase::SDHCInitializeImpl: "
; 1354 :         L"MMC1_CON set value = %X\r\n", wRegValue
; 1355 :     ));
; 1356 : 
; 1357 :     OUTREG16(&m_vpSDIOReg->MMC_IE, 0);

  000ac	e59d30d4	 ldr         r3, [sp, #0xD4]
  000b0	e2833088	 add         r3, r3, #0x88
  000b4	e5933000	 ldr         r3, [r3]
  000b8	e2832014	 add         r2, r3, #0x14
  000bc	e3a03000	 mov         r3, #0
  000c0	e1c230b0	 strh        r3, [r2]

; 1358 : 
; 1359 :     wRegValue = (SDMMC_DEFAULT_ALMOST_EMPTY - 1) | ((SDMMC_DEFAULT_ALMOST_FULL - 1) << 8);

  000c4	e3a03c1f	 mov         r3, #0x1F, 24
  000c8	e383301f	 orr         r3, r3, #0x1F
  000cc	e1cd32b0	 strh        r3, [sp, #0x20]

; 1360 :     OUTREG16(&m_vpSDIOReg->MMC_BUF, wRegValue);

  000d0	e59d30d4	 ldr         r3, [sp, #0xD4]
  000d4	e2833088	 add         r3, r3, #0x88
  000d8	e5933000	 ldr         r3, [r3]
  000dc	e283202c	 add         r2, r3, #0x2C
  000e0	e1dd32b0	 ldrh        r3, [sp, #0x20]
  000e4	e1c230b0	 strh        r3, [r2]

; 1361 : 
; 1362 :     Write_MMC_SDIO(0);

  000e8	e59d30d4	 ldr         r3, [sp, #0xD4]
  000ec	e2830014	 add         r0, r3, #0x14
  000f0	eb000000	 bl          EnterCriticalSection
  000f4	e59d30d4	 ldr         r3, [sp, #0xD4]
  000f8	e2833088	 add         r3, r3, #0x88
  000fc	e5933000	 ldr         r3, [r3]
  00100	e2832034	 add         r2, r3, #0x34
  00104	e3a03000	 mov         r3, #0
  00108	e1c230b0	 strh        r3, [r2]
  0010c	e59d30d4	 ldr         r3, [sp, #0xD4]
  00110	e2830014	 add         r0, r3, #0x14
  00114	eb000000	 bl          LeaveCriticalSection

; 1363 : 
; 1364 : 
; 1365 :     // --- Set the timeouts ----
; 1366 :     // Set command timeout of 64 clocks, the max according to OMAP1610 and SD specs
; 1367 :     OUTREG16(&m_vpSDIOReg->MMC_CTO, MMC_CTO_CONTROL_MAX);

  00118	e59d30d4	 ldr         r3, [sp, #0xD4]
  0011c	e2833088	 add         r3, r3, #0x88
  00120	e5933000	 ldr         r3, [r3]
  00124	e2832018	 add         r2, r3, #0x18
  00128	e3a030fd	 mov         r3, #0xFD
  0012c	e1c230b0	 strh        r3, [r2]

; 1368 :     OUTREG16(&m_vpSDIOReg->MMC_DTO, MMC_DTO_CONTROL_MAX);

  00130	e59d30d4	 ldr         r3, [sp, #0xD4]
  00134	e2833088	 add         r3, r3, #0x88
  00138	e5933000	 ldr         r3, [r3]
  0013c	e283201c	 add         r2, r3, #0x1C
  00140	e3a03cff	 mov         r3, #0xFF, 24
  00144	e38330fd	 orr         r3, r3, #0xFD
  00148	e1c230b0	 strh        r3, [r2]

; 1369 : 
; 1370 :     // deactivate the clock
; 1371 :     ClockOff();

  0014c	e59d00d4	 ldr         r0, [sp, #0xD4]
  00150	eb000000	 bl          |?ClockOff@CSDIOControllerBase@@QAAXXZ|

; 1372 : 
; 1373 :     // convert the SDIO hardware IRQ into a logical SYSINTR value
; 1374 :     DWORD rgdwSDIOIrq[] = { IRQ_MMC };

  00154	e3a03053	 mov         r3, #0x53
  00158	e58d3008	 str         r3, [sp, #8]

; 1375 :     pdwSDIOIrq = rgdwSDIOIrq;

  0015c	e28d3008	 add         r3, sp, #8
  00160	e58d300c	 str         r3, [sp, #0xC]

; 1376 :     dwSDIOIrqLen = sizeof(rgdwSDIOIrq);

  00164	e3a03004	 mov         r3, #4
  00168	e58d3018	 str         r3, [sp, #0x18]

; 1377 : 
; 1378 :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, pdwSDIOIrq, dwSDIOIrqLen, &m_dwControllerSysIntr, sizeof(DWORD), NULL))

  0016c	e3a03000	 mov         r3, #0
  00170	e58d3004	 str         r3, [sp, #4]
  00174	e3a03004	 mov         r3, #4
  00178	e58d3000	 str         r3, [sp]
  0017c	e59d30d4	 ldr         r3, [sp, #0xD4]
  00180	e283306c	 add         r3, r3, #0x6C
  00184	e59d2018	 ldr         r2, [sp, #0x18]
  00188	e59d100c	 ldr         r1, [sp, #0xC]
  0018c	e59f0514	 ldr         r0, [pc, #0x514]
  00190	eb000000	 bl          KernelIoControl
  00194	e58d0090	 str         r0, [sp, #0x90]
  00198	e59d3090	 ldr         r3, [sp, #0x90]
  0019c	e3530000	 cmp         r3, #0
  001a0	1a000007	 bne         |$LN31@SDHCInitia|

; 1379 :     {
; 1380 :         // invalid SDIO SYSINTR value!
; 1381 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::SDHCInitializeImpl: "
; 1382 :             L"Error obtaining SDIO SYSINTR value!\r\n"
; 1383 :         ));
; 1384 :         m_dwControllerSysIntr = SYSINTR_UNDEFINED;

  001a4	e59d30d4	 ldr         r3, [sp, #0xD4]
  001a8	e283206c	 add         r2, r3, #0x6C
  001ac	e3e03000	 mvn         r3, #0
  001b0	e5823000	 str         r3, [r2]

; 1385 :         status = SD_API_STATUS_UNSUCCESSFUL;

  001b4	e3a0310f	 mov         r3, #0xF, 2
  001b8	e58d301c	 str         r3, [sp, #0x1C]
  001bc	ea00012c	 b           |$LN30@SDHCInitia|

; 1386 :         goto exitInit;

  001c0	ea00012b	 b           |$exitInit$40497|
  001c4		 |$LN31@SDHCInitia|

; 1387 :     }
; 1388 : 
; 1389 :     // allocate the interrupt event for the SDIO/controller interrupt
; 1390 :     m_hControllerISTEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  001c4	e3a03000	 mov         r3, #0
  001c8	e3a02000	 mov         r2, #0
  001cc	e3a01000	 mov         r1, #0
  001d0	e3a00000	 mov         r0, #0
  001d4	eb000000	 bl          CreateEventW
  001d8	e58d0094	 str         r0, [sp, #0x94]
  001dc	e59d30d4	 ldr         r3, [sp, #0xD4]
  001e0	e2832048	 add         r2, r3, #0x48
  001e4	e59d3094	 ldr         r3, [sp, #0x94]
  001e8	e5823000	 str         r3, [r2]

; 1391 : 
; 1392 :     if (NULL == m_hControllerISTEvent) {

  001ec	e59d30d4	 ldr         r3, [sp, #0xD4]
  001f0	e2833048	 add         r3, r3, #0x48
  001f4	e5933000	 ldr         r3, [r3]
  001f8	e3530000	 cmp         r3, #0
  001fc	1a000003	 bne         |$LN29@SDHCInitia|

; 1393 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00200	e3a0313b	 mov         r3, #0x3B, 2
  00204	e58d301c	 str         r3, [sp, #0x1C]
  00208	ea000119	 b           |$LN28@SDHCInitia|

; 1394 :         goto exitInit;

  0020c	ea000118	 b           |$exitInit$40497|
  00210		 |$LN29@SDHCInitia|

; 1395 :     }
; 1396 : 
; 1397 :     if ( !InterruptInitialize( m_dwControllerSysIntr, m_hControllerISTEvent, NULL, 0 ) ) {

  00210	e3a03000	 mov         r3, #0
  00214	e3a02000	 mov         r2, #0
  00218	e59d10d4	 ldr         r1, [sp, #0xD4]
  0021c	e2811048	 add         r1, r1, #0x48
  00220	e5911000	 ldr         r1, [r1]
  00224	e59d00d4	 ldr         r0, [sp, #0xD4]
  00228	e280006c	 add         r0, r0, #0x6C
  0022c	e5900000	 ldr         r0, [r0]
  00230	eb000000	 bl          InterruptInitialize
  00234	e58d0098	 str         r0, [sp, #0x98]
  00238	e59d3098	 ldr         r3, [sp, #0x98]
  0023c	e3530000	 cmp         r3, #0
  00240	1a000003	 bne         |$LN27@SDHCInitia|

; 1398 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00244	e3a0313b	 mov         r3, #0x3B, 2
  00248	e58d301c	 str         r3, [sp, #0x1C]
  0024c	ea000108	 b           |$LN26@SDHCInitia|

; 1399 :         goto exitInit;

  00250	ea000107	 b           |$exitInit$40497|
  00254		 |$LN27@SDHCInitia|

; 1400 :     }
; 1401 : 
; 1402 :     // allocate the interrupt event for card detection
; 1403 :     m_hCardDetectEvent = CreateEvent(NULL, FALSE, FALSE,NULL);

  00254	e3a03000	 mov         r3, #0
  00258	e3a02000	 mov         r2, #0
  0025c	e3a01000	 mov         r1, #0
  00260	e3a00000	 mov         r0, #0
  00264	eb000000	 bl          CreateEventW
  00268	e58d009c	 str         r0, [sp, #0x9C]
  0026c	e59d30d4	 ldr         r3, [sp, #0xD4]
  00270	e2832050	 add         r2, r3, #0x50
  00274	e59d309c	 ldr         r3, [sp, #0x9C]
  00278	e5823000	 str         r3, [r2]

; 1404 : 
; 1405 :     if (NULL == m_hCardDetectEvent) {

  0027c	e59d30d4	 ldr         r3, [sp, #0xD4]
  00280	e2833050	 add         r3, r3, #0x50
  00284	e5933000	 ldr         r3, [r3]
  00288	e3530000	 cmp         r3, #0
  0028c	1a000003	 bne         |$LN25@SDHCInitia|

; 1406 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  00290	e3a0313b	 mov         r3, #0x3B, 2
  00294	e58d301c	 str         r3, [sp, #0x1C]
  00298	ea0000f5	 b           |$LN24@SDHCInitia|

; 1407 :         goto exitInit;

  0029c	ea0000f4	 b           |$exitInit$40497|
  002a0		 |$LN25@SDHCInitia|

; 1408 :     }
; 1409 : 
; 1410 :     // Open parent bus - triton
; 1411 :     m_hParentBus = TWLOpen();

  002a0	eb000000	 bl          TWLOpen
  002a4	e58d00a0	 str         r0, [sp, #0xA0]
  002a8	e59d30d4	 ldr         r3, [sp, #0xD4]
  002ac	e2832008	 add         r2, r3, #8
  002b0	e59d30a0	 ldr         r3, [sp, #0xA0]
  002b4	e5823000	 str         r3, [r2]

; 1412 :     if ( m_hParentBus == NULL ) {

  002b8	e59d30d4	 ldr         r3, [sp, #0xD4]
  002bc	e2833008	 add         r3, r3, #8
  002c0	e5933000	 ldr         r3, [r3]
  002c4	e3530000	 cmp         r3, #0
  002c8	1a000001	 bne         |$LN23@SDHCInitia|
  002cc	ea0000e8	 b           |$LN22@SDHCInitia|

; 1413 :         DEBUGMSG(SDCARD_ZONE_ERROR, (L"CSDIOControllerBase::Init: "
; 1414 :             L"Failed to obtain parent bus handle\r\n"
; 1415 :         ));
; 1416 :         goto exitInit;

  002d0	ea0000e7	 b           |$exitInit$40497|
  002d4		 |$LN23@SDHCInitia|

; 1417 :     }
; 1418 :  
; 1419 :     // Associate event with TWL TWL_INTR_CD1 interrupt
; 1420 :     if (!TWLSetIntrEvent(m_hParentBus, TWL_INTR_CD1, m_hCardDetectEvent)) {

  002d4	e59d30d4	 ldr         r3, [sp, #0xD4]
  002d8	e2833050	 add         r3, r3, #0x50
  002dc	e5933000	 ldr         r3, [r3]
  002e0	e58d302c	 str         r3, [sp, #0x2C]
  002e4	e59d30d4	 ldr         r3, [sp, #0xD4]
  002e8	e2833008	 add         r3, r3, #8
  002ec	e5933000	 ldr         r3, [r3]
  002f0	e58d3028	 str         r3, [sp, #0x28]
  002f4	e59d3028	 ldr         r3, [sp, #0x28]
  002f8	e58d3024	 str         r3, [sp, #0x24]
  002fc	e59d202c	 ldr         r2, [sp, #0x2C]
  00300	e3a01000	 mov         r1, #0
  00304	e59d3024	 ldr         r3, [sp, #0x24]
  00308	e5930000	 ldr         r0, [r3]
  0030c	e59d3024	 ldr         r3, [sp, #0x24]
  00310	e283300c	 add         r3, r3, #0xC
  00314	e5933000	 ldr         r3, [r3]
  00318	e1a0e00f	 mov         lr, pc
  0031c	e12fff13	 bx          r3
  00320	e58d00a4	 str         r0, [sp, #0xA4]
  00324	e59d30a4	 ldr         r3, [sp, #0xA4]
  00328	e3530000	 cmp         r3, #0
  0032c	1a000001	 bne         |$LN21@SDHCInitia|
  00330	ea0000cf	 b           |$LN20@SDHCInitia|

; 1421 :         goto exitInit;

  00334	ea0000ce	 b           |$exitInit$40497|
  00338		 |$LN21@SDHCInitia|

; 1422 :     }
; 1423 : 
; 1424 :     // Associate event with TWL TWL_INTR_DL1 interrupt
; 1425 :     if (!TWLSetIntrEvent(m_hParentBus, TWL_INTR_DL1, m_hCardDetectEvent)) {

  00338	e59d30d4	 ldr         r3, [sp, #0xD4]
  0033c	e2833050	 add         r3, r3, #0x50
  00340	e5933000	 ldr         r3, [r3]
  00344	e58d3038	 str         r3, [sp, #0x38]
  00348	e59d30d4	 ldr         r3, [sp, #0xD4]
  0034c	e2833008	 add         r3, r3, #8
  00350	e5933000	 ldr         r3, [r3]
  00354	e58d3034	 str         r3, [sp, #0x34]
  00358	e59d3034	 ldr         r3, [sp, #0x34]
  0035c	e58d3030	 str         r3, [sp, #0x30]
  00360	e59d2038	 ldr         r2, [sp, #0x38]
  00364	e3a01002	 mov         r1, #2
  00368	e59d3030	 ldr         r3, [sp, #0x30]
  0036c	e5930000	 ldr         r0, [r3]
  00370	e59d3030	 ldr         r3, [sp, #0x30]
  00374	e283300c	 add         r3, r3, #0xC
  00378	e5933000	 ldr         r3, [r3]
  0037c	e1a0e00f	 mov         lr, pc
  00380	e12fff13	 bx          r3
  00384	e58d00a8	 str         r0, [sp, #0xA8]
  00388	e59d30a8	 ldr         r3, [sp, #0xA8]
  0038c	e3530000	 cmp         r3, #0
  00390	1a000001	 bne         |$LN19@SDHCInitia|
  00394	ea0000b6	 b           |$LN18@SDHCInitia|

; 1426 :         goto exitInit;

  00398	ea0000b5	 b           |$exitInit$40497|
  0039c		 |$LN19@SDHCInitia|

; 1427 :     }
; 1428 : 
; 1429 :     // Associate event with TWL TWL_INTR_CD2 interrupt
; 1430 :     if (!TWLSetIntrEvent(m_hParentBus, TWL_INTR_CD2, m_hCardDetectEvent)) {

  0039c	e59d30d4	 ldr         r3, [sp, #0xD4]
  003a0	e2833050	 add         r3, r3, #0x50
  003a4	e5933000	 ldr         r3, [r3]
  003a8	e58d3044	 str         r3, [sp, #0x44]
  003ac	e59d30d4	 ldr         r3, [sp, #0xD4]
  003b0	e2833008	 add         r3, r3, #8
  003b4	e5933000	 ldr         r3, [r3]
  003b8	e58d3040	 str         r3, [sp, #0x40]
  003bc	e59d3040	 ldr         r3, [sp, #0x40]
  003c0	e58d303c	 str         r3, [sp, #0x3C]
  003c4	e59d2044	 ldr         r2, [sp, #0x44]
  003c8	e3a01001	 mov         r1, #1
  003cc	e59d303c	 ldr         r3, [sp, #0x3C]
  003d0	e5930000	 ldr         r0, [r3]
  003d4	e59d303c	 ldr         r3, [sp, #0x3C]
  003d8	e283300c	 add         r3, r3, #0xC
  003dc	e5933000	 ldr         r3, [r3]
  003e0	e1a0e00f	 mov         lr, pc
  003e4	e12fff13	 bx          r3
  003e8	e58d00ac	 str         r0, [sp, #0xAC]
  003ec	e59d30ac	 ldr         r3, [sp, #0xAC]
  003f0	e3530000	 cmp         r3, #0
  003f4	1a000001	 bne         |$LN17@SDHCInitia|
  003f8	ea00009d	 b           |$LN16@SDHCInitia|

; 1431 :         goto exitInit;

  003fc	ea00009c	 b           |$exitInit$40497|
  00400		 |$LN17@SDHCInitia|

; 1432 :     }
; 1433 : 
; 1434 :     // Associate event with TWL TWL_INTR_DL2 interrupt
; 1435 :     if (!TWLSetIntrEvent(m_hParentBus, TWL_INTR_DL2, m_hCardDetectEvent)) {

  00400	e59d30d4	 ldr         r3, [sp, #0xD4]
  00404	e2833050	 add         r3, r3, #0x50
  00408	e5933000	 ldr         r3, [r3]
  0040c	e58d3050	 str         r3, [sp, #0x50]
  00410	e59d30d4	 ldr         r3, [sp, #0xD4]
  00414	e2833008	 add         r3, r3, #8
  00418	e5933000	 ldr         r3, [r3]
  0041c	e58d304c	 str         r3, [sp, #0x4C]
  00420	e59d304c	 ldr         r3, [sp, #0x4C]
  00424	e58d3048	 str         r3, [sp, #0x48]
  00428	e59d2050	 ldr         r2, [sp, #0x50]
  0042c	e3a01003	 mov         r1, #3
  00430	e59d3048	 ldr         r3, [sp, #0x48]
  00434	e5930000	 ldr         r0, [r3]
  00438	e59d3048	 ldr         r3, [sp, #0x48]
  0043c	e283300c	 add         r3, r3, #0xC
  00440	e5933000	 ldr         r3, [r3]
  00444	e1a0e00f	 mov         lr, pc
  00448	e12fff13	 bx          r3
  0044c	e58d00b0	 str         r0, [sp, #0xB0]
  00450	e59d30b0	 ldr         r3, [sp, #0xB0]
  00454	e3530000	 cmp         r3, #0
  00458	1a000001	 bne         |$LN15@SDHCInitia|
  0045c	ea000084	 b           |$LN14@SDHCInitia|

; 1436 :         goto exitInit;

  00460	ea000083	 b           |$exitInit$40497|
  00464		 |$LN15@SDHCInitia|

; 1437 :     }
; 1438 : 
; 1439 :     // Enable TWL_INTR_CD1 event
; 1440 :     if (!TWLIntrEnable(m_hParentBus, TWL_INTR_CD1)) {

  00464	e59d30d4	 ldr         r3, [sp, #0xD4]
  00468	e2833008	 add         r3, r3, #8
  0046c	e5933000	 ldr         r3, [r3]
  00470	e58d3058	 str         r3, [sp, #0x58]
  00474	e59d3058	 ldr         r3, [sp, #0x58]
  00478	e58d3054	 str         r3, [sp, #0x54]
  0047c	e3a01000	 mov         r1, #0
  00480	e59d3054	 ldr         r3, [sp, #0x54]
  00484	e5930000	 ldr         r0, [r3]
  00488	e59d3054	 ldr         r3, [sp, #0x54]
  0048c	e2833010	 add         r3, r3, #0x10
  00490	e5933000	 ldr         r3, [r3]
  00494	e1a0e00f	 mov         lr, pc
  00498	e12fff13	 bx          r3
  0049c	e58d00b4	 str         r0, [sp, #0xB4]
  004a0	e59d30b4	 ldr         r3, [sp, #0xB4]
  004a4	e3530000	 cmp         r3, #0
  004a8	1a000001	 bne         |$LN13@SDHCInitia|
  004ac	ea000070	 b           |$LN12@SDHCInitia|

; 1441 :         goto exitInit;

  004b0	ea00006f	 b           |$exitInit$40497|
  004b4		 |$LN13@SDHCInitia|

; 1442 :     }
; 1443 : 
; 1444 :     // Enable TWL_INTR_DL1 event
; 1445 :     if (!TWLIntrEnable(m_hParentBus, TWL_INTR_DL1)) {

  004b4	e59d30d4	 ldr         r3, [sp, #0xD4]
  004b8	e2833008	 add         r3, r3, #8
  004bc	e5933000	 ldr         r3, [r3]
  004c0	e58d3060	 str         r3, [sp, #0x60]
  004c4	e59d3060	 ldr         r3, [sp, #0x60]
  004c8	e58d305c	 str         r3, [sp, #0x5C]
  004cc	e3a01002	 mov         r1, #2
  004d0	e59d305c	 ldr         r3, [sp, #0x5C]
  004d4	e5930000	 ldr         r0, [r3]
  004d8	e59d305c	 ldr         r3, [sp, #0x5C]
  004dc	e2833010	 add         r3, r3, #0x10
  004e0	e5933000	 ldr         r3, [r3]
  004e4	e1a0e00f	 mov         lr, pc
  004e8	e12fff13	 bx          r3
  004ec	e58d00b8	 str         r0, [sp, #0xB8]
  004f0	e59d30b8	 ldr         r3, [sp, #0xB8]
  004f4	e3530000	 cmp         r3, #0
  004f8	1a000001	 bne         |$LN11@SDHCInitia|
  004fc	ea00005c	 b           |$LN10@SDHCInitia|

; 1446 :         goto exitInit;

  00500	ea00005b	 b           |$exitInit$40497|
  00504		 |$LN11@SDHCInitia|

; 1447 :     }
; 1448 : 
; 1449 :     // Enable TWL_INTR_CD2 event
; 1450 :     if (!TWLIntrEnable(m_hParentBus, TWL_INTR_CD2)) {

  00504	e59d30d4	 ldr         r3, [sp, #0xD4]
  00508	e2833008	 add         r3, r3, #8
  0050c	e5933000	 ldr         r3, [r3]
  00510	e58d3068	 str         r3, [sp, #0x68]
  00514	e59d3068	 ldr         r3, [sp, #0x68]
  00518	e58d3064	 str         r3, [sp, #0x64]
  0051c	e3a01001	 mov         r1, #1
  00520	e59d3064	 ldr         r3, [sp, #0x64]
  00524	e5930000	 ldr         r0, [r3]
  00528	e59d3064	 ldr         r3, [sp, #0x64]
  0052c	e2833010	 add         r3, r3, #0x10
  00530	e5933000	 ldr         r3, [r3]
  00534	e1a0e00f	 mov         lr, pc
  00538	e12fff13	 bx          r3
  0053c	e58d00bc	 str         r0, [sp, #0xBC]
  00540	e59d30bc	 ldr         r3, [sp, #0xBC]
  00544	e3530000	 cmp         r3, #0
  00548	1a000001	 bne         |$LN9@SDHCInitia|
  0054c	ea000048	 b           |$LN8@SDHCInitia|

; 1451 :         goto exitInit;

  00550	ea000047	 b           |$exitInit$40497|
  00554		 |$LN9@SDHCInitia|

; 1452 :     }
; 1453 : 
; 1454 :     // Enable TWL_INTR_DL2 event
; 1455 :     if (!TWLIntrEnable(m_hParentBus, TWL_INTR_DL2)) {

  00554	e59d30d4	 ldr         r3, [sp, #0xD4]
  00558	e2833008	 add         r3, r3, #8
  0055c	e5933000	 ldr         r3, [r3]
  00560	e58d3070	 str         r3, [sp, #0x70]
  00564	e59d3070	 ldr         r3, [sp, #0x70]
  00568	e58d306c	 str         r3, [sp, #0x6C]
  0056c	e3a01003	 mov         r1, #3
  00570	e59d306c	 ldr         r3, [sp, #0x6C]
  00574	e5930000	 ldr         r0, [r3]
  00578	e59d306c	 ldr         r3, [sp, #0x6C]
  0057c	e2833010	 add         r3, r3, #0x10
  00580	e5933000	 ldr         r3, [r3]
  00584	e1a0e00f	 mov         lr, pc
  00588	e12fff13	 bx          r3
  0058c	e58d00c0	 str         r0, [sp, #0xC0]
  00590	e59d30c0	 ldr         r3, [sp, #0xC0]
  00594	e3530000	 cmp         r3, #0
  00598	1a000001	 bne         |$LN7@SDHCInitia|
  0059c	ea000034	 b           |$LN6@SDHCInitia|

; 1456 :         goto exitInit;

  005a0	ea000033	 b           |$exitInit$40497|
  005a4		 |$LN7@SDHCInitia|

; 1457 :     }
; 1458 : 
; 1459 :     // create the Controller IST thread
; 1460 :     m_htControllerIST = CreateThread(NULL,
; 1461 :         0,
; 1462 :         CSDIOControllerBase::SDHCControllerIstThread,
; 1463 :         this,
; 1464 :         0,
; 1465 :         &threadID);

  005a4	e28d3010	 add         r3, sp, #0x10
  005a8	e58d3004	 str         r3, [sp, #4]
  005ac	e3a03000	 mov         r3, #0
  005b0	e58d3000	 str         r3, [sp]
  005b4	e59d30d4	 ldr         r3, [sp, #0xD4]
  005b8	e59f20e4	 ldr         r2, [pc, #0xE4]
  005bc	e3a01000	 mov         r1, #0
  005c0	e3a00000	 mov         r0, #0
  005c4	eb000000	 bl          CreateThread
  005c8	e58d00c4	 str         r0, [sp, #0xC4]
  005cc	e59d30d4	 ldr         r3, [sp, #0xD4]
  005d0	e283204c	 add         r2, r3, #0x4C
  005d4	e59d30c4	 ldr         r3, [sp, #0xC4]
  005d8	e5823000	 str         r3, [r2]

; 1466 : 
; 1467 :     if (NULL == m_htControllerIST) {

  005dc	e59d30d4	 ldr         r3, [sp, #0xD4]
  005e0	e283304c	 add         r3, r3, #0x4C
  005e4	e5933000	 ldr         r3, [r3]
  005e8	e3530000	 cmp         r3, #0
  005ec	1a000003	 bne         |$LN5@SDHCInitia|

; 1468 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  005f0	e3a0313b	 mov         r3, #0x3B, 2
  005f4	e58d301c	 str         r3, [sp, #0x1C]
  005f8	ea00001d	 b           |$LN4@SDHCInitia|

; 1469 :         goto exitInit;

  005fc	ea00001c	 b           |$exitInit$40497|
  00600		 |$LN5@SDHCInitia|

; 1470 :     }
; 1471 : 
; 1472 :     // create the card detect IST thread
; 1473 :     m_htCardDetectIST = CreateThread(NULL,
; 1474 :         0,
; 1475 :         CSDIOControllerBase::SDHCCardDetectIstThread,
; 1476 :         this,
; 1477 :         0,
; 1478 :         &threadID);

  00600	e28d3010	 add         r3, sp, #0x10
  00604	e58d3004	 str         r3, [sp, #4]
  00608	e3a03000	 mov         r3, #0
  0060c	e58d3000	 str         r3, [sp]
  00610	e59d30d4	 ldr         r3, [sp, #0xD4]
  00614	e59f2084	 ldr         r2, [pc, #0x84]
  00618	e3a01000	 mov         r1, #0
  0061c	e3a00000	 mov         r0, #0
  00620	eb000000	 bl          CreateThread
  00624	e58d00c8	 str         r0, [sp, #0xC8]
  00628	e59d30d4	 ldr         r3, [sp, #0xD4]
  0062c	e2832054	 add         r2, r3, #0x54
  00630	e59d30c8	 ldr         r3, [sp, #0xC8]
  00634	e5823000	 str         r3, [r2]

; 1479 : 
; 1480 :     if (NULL == m_htCardDetectIST) {

  00638	e59d30d4	 ldr         r3, [sp, #0xD4]
  0063c	e2833054	 add         r3, r3, #0x54
  00640	e5933000	 ldr         r3, [r3]
  00644	e3530000	 cmp         r3, #0
  00648	1a000003	 bne         |$LN3@SDHCInitia|

; 1481 :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;

  0064c	e3a0313b	 mov         r3, #0x3B, 2
  00650	e58d301c	 str         r3, [sp, #0x1C]
  00654	ea000006	 b           |$LN2@SDHCInitia|

; 1482 :         goto exitInit;

  00658	ea000005	 b           |$exitInit$40497|
  0065c		 |$LN3@SDHCInitia|

; 1483 :     }
; 1484 : 
; 1485 :     m_fInitialized = TRUE;

  0065c	e59d30d4	 ldr         r3, [sp, #0xD4]
  00660	e2832070	 add         r2, r3, #0x70
  00664	e3a03001	 mov         r3, #1
  00668	e5823000	 str         r3, [r2]

; 1486 : 
; 1487 :     // on start we need the IST to check the slot for a card
; 1488 :     // FIXME Menelaus should detect card SetEvent(m_hCardDetectEvent);
; 1489 : 
; 1490 :     status = SD_API_STATUS_SUCCESS;

  0066c	e3a03000	 mov         r3, #0
  00670	e58d301c	 str         r3, [sp, #0x1C]
  00674		 |$LN2@SDHCInitia|
  00674		 |$LN4@SDHCInitia|
  00674		 |$LN6@SDHCInitia|
  00674		 |$LN8@SDHCInitia|
  00674		 |$LN10@SDHCInitia|
  00674		 |$LN12@SDHCInitia|
  00674		 |$LN14@SDHCInitia|
  00674		 |$LN16@SDHCInitia|
  00674		 |$LN18@SDHCInitia|
  00674		 |$LN20@SDHCInitia|
  00674		 |$LN22@SDHCInitia|
  00674		 |$LN24@SDHCInitia|
  00674		 |$LN26@SDHCInitia|
  00674		 |$LN28@SDHCInitia|
  00674		 |$LN30@SDHCInitia|
  00674		 |$exitInit$40497|

; 1491 : 
; 1492 : exitInit:
; 1493 : 
; 1494 :     if (!SD_API_SUCCESS(status)) {

  00674	e59d301c	 ldr         r3, [sp, #0x1C]
  00678	e3530000	 cmp         r3, #0
  0067c	aa000001	 bge         |$LN1@SDHCInitia|

; 1495 :         // just call the deinit handler directly to cleanup
; 1496 :         SDHCDeinitializeImpl();

  00680	e59d00d4	 ldr         r0, [sp, #0xD4]
  00684	eb000000	 bl          |?SDHCDeinitializeImpl@CSDIOControllerBase@@QAAJXZ|
  00688		 |$LN1@SDHCInitia|

; 1497 :     }
; 1498 : 
; 1499 :     return status;

  00688	e59d301c	 ldr         r3, [sp, #0x1C]
  0068c	e58d308c	 str         r3, [sp, #0x8C]

; 1500 : }

  00690	e59d008c	 ldr         r0, [sp, #0x8C]
  00694	e28dd0cc	 add         sp, sp, #0xCC
  00698	e89d6000	 ldmia       sp, {sp, lr}
  0069c	e12fff1e	 bx          lr
  006a0		 |$LN56@SDHCInitia|
  006a0		 |$LN57@SDHCInitia|
  006a0	00000000	 DCD         |?SDHCCardDetectIstThread@CSDIOControllerBase@@SAKPAX@Z|
  006a4		 |$LN58@SDHCInitia|
  006a4	00000000	 DCD         |?SDHCControllerIstThread@CSDIOControllerBase@@SAKPAX@Z|
  006a8		 |$LN59@SDHCInitia|
  006a8	01010098	 DCD         0x1010098
  006ac		 |$M42694|

			 ENDP  ; |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ|, CSDIOControllerBase::SDHCInitializeImpl

	EXPORT	|?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| ; CSDIOControllerBase::SDHCInitialize

  00000			 AREA	 |.pdata|, PDATA
|$T42708| DCD	|$LN5@SDHCInitia@2|
	DCD	0x40001104
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z| PROC ; CSDIOControllerBase::SDHCInitialize

; 2145 : {

  00000		 |$LN5@SDHCInitia@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M42705|

; 2146 :     // get our extension 
; 2147 :     CSDIOControllerBase *pController = GET_PCONTROLLER_FROM_HCD(pHCContext);

  00010	e59d3014	 ldr         r3, [sp, #0x14]
  00014	e283304c	 add         r3, r3, #0x4C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3000	 str         r3, [sp]

; 2148 :     return pController->SDHCInitializeImpl();

  00020	e59d0000	 ldr         r0, [sp]
  00024	eb000000	 bl          |?SDHCInitializeImpl@CSDIOControllerBase@@QAAJXZ|
  00028	e58d0008	 str         r0, [sp, #8]
  0002c	e59d3008	 ldr         r3, [sp, #8]
  00030	e58d3004	 str         r3, [sp, #4]

; 2149 : }

  00034	e59d0004	 ldr         r0, [sp, #4]
  00038	e28dd00c	 add         sp, sp, #0xC
  0003c	e89d6000	 ldmia       sp, {sp, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M42706|

			 ENDP  ; |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|, CSDIOControllerBase::SDHCInitialize

	EXPORT	|??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|wcsncpy|

  00000			 AREA	 |.pdata|, PDATA
|$T42717| DCD	|$LN5@InterpretC|
	DCD	0x40003b04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@| DCB "S", 0x0, "D", 0x0, "H"
	DCB	0x0, "C", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ| PROC ; CSDIOControllerBase::InterpretCapabilities

; 1111 : {

  00000		 |$LN5@InterpretC|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42714|

; 1112 :     BOOL fRet = TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e58d3000	 str         r3, [sp]

; 1113 : 
; 1114 :     // set the host controller name
; 1115 :     SDHCDSetHCName(m_pHCContext, L"SDHC");

  00018	e3a0200f	 mov         r2, #0xF
  0001c	e59f10c4	 ldr         r1, [pc, #0xC4]
  00020	e59d3010	 ldr         r3, [sp, #0x10]
  00024	e2833004	 add         r3, r3, #4
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2830004	 add         r0, r3, #4
  00030	eb000000	 bl          wcsncpy

; 1116 : 
; 1117 :     // set init handler
; 1118 :     SDHCDSetControllerInitHandler(m_pHCContext, CSDIOControllerBase::SDHCInitialize);

  00034	e59d3010	 ldr         r3, [sp, #0x10]
  00038	e2833004	 add         r3, r3, #4
  0003c	e5933000	 ldr         r3, [r3]
  00040	e2832044	 add         r2, r3, #0x44
  00044	e59f3098	 ldr         r3, [pc, #0x98]
  00048	e5823000	 str         r3, [r2]

; 1119 : 
; 1120 :     // set deinit handler    
; 1121 :     SDHCDSetControllerDeinitHandler(m_pHCContext, CSDIOControllerBase::SDHCDeinitialize);

  0004c	e59d3010	 ldr         r3, [sp, #0x10]
  00050	e2833004	 add         r3, r3, #4
  00054	e5933000	 ldr         r3, [r3]
  00058	e2832048	 add         r2, r3, #0x48
  0005c	e59f307c	 ldr         r3, [pc, #0x7C]
  00060	e5823000	 str         r3, [r2]

; 1122 : 
; 1123 :     // set the Send packet handler
; 1124 :     SDHCDSetBusRequestHandler(m_pHCContext, CSDIOControllerBase::SDHCBusRequestHandler);

  00064	e59d3010	 ldr         r3, [sp, #0x10]
  00068	e2833004	 add         r3, r3, #4
  0006c	e5933000	 ldr         r3, [r3]
  00070	e2832038	 add         r2, r3, #0x38
  00074	e59f3060	 ldr         r3, [pc, #0x60]
  00078	e5823000	 str         r3, [r2]

; 1125 : 
; 1126 :     // set the cancel I/O handler
; 1127 :     SDHCDSetCancelIOHandler(m_pHCContext, CSDIOControllerBase::SDHCCancelIoHandler);

  0007c	e59d3010	 ldr         r3, [sp, #0x10]
  00080	e2833004	 add         r3, r3, #4
  00084	e5933000	 ldr         r3, [r3]
  00088	e2832040	 add         r2, r3, #0x40
  0008c	e59f3044	 ldr         r3, [pc, #0x44]
  00090	e5823000	 str         r3, [r2]

; 1128 : 
; 1129 :     // set the slot option handler
; 1130 :     SDHCDSetSlotOptionHandler(m_pHCContext, CSDIOControllerBase::SDHCSlotOptionHandler);

  00094	e59d3010	 ldr         r3, [sp, #0x10]
  00098	e2833004	 add         r3, r3, #4
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e283203c	 add         r2, r3, #0x3C
  000a4	e59f3028	 ldr         r3, [pc, #0x28]
  000a8	e5823000	 str         r3, [r2]

; 1131 : 
; 1132 :     // set maximum block length
; 1133 :     m_usMaxBlockLen = STD_HC_MAX_BLOCK_LENGTH;

  000ac	e59d3010	 ldr         r3, [sp, #0x10]
  000b0	e2832078	 add         r2, r3, #0x78
  000b4	e3a03b02	 mov         r3, #2, 22
  000b8	e1c230b0	 strh        r3, [r2]

; 1134 : 
; 1135 :     return fRet;

  000bc	e59d3000	 ldr         r3, [sp]
  000c0	e58d3004	 str         r3, [sp, #4]

; 1136 : }

  000c4	e59d0004	 ldr         r0, [sp, #4]
  000c8	e28dd008	 add         sp, sp, #8
  000cc	e89d6000	 ldmia       sp, {sp, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN6@InterpretC|
  000d4		 |$LN7@InterpretC|
  000d4	00000000	 DCD         |?SDHCSlotOptionHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KW4_SD_SLOT_OPTION_CODE@@PAXK@Z|
  000d8		 |$LN8@InterpretC|
  000d8	00000000	 DCD         |?SDHCCancelIoHandler@CSDIOControllerBase@@SAEPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|
  000dc		 |$LN9@InterpretC|
  000dc	00000000	 DCD         |?SDHCBusRequestHandler@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@KPAU_SD_BUS_REQUEST@@@Z|
  000e0		 |$LN10@InterpretC|
  000e0	00000000	 DCD         |?SDHCDeinitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|
  000e4		 |$LN11@InterpretC|
  000e4	00000000	 DCD         |?SDHCInitialize@CSDIOControllerBase@@SAJPAU_SDCARD_HC_CONTEXT@@@Z|
  000e8		 |$LN12@InterpretC|
  000e8	00000000	 DCD         |??_C@_19IJCLBJAH@?$AAS?$AAD?$AAH?$AAC?$AA?$AA@|
  000ec		 |$M42715|

			 ENDP  ; |?InterpretCapabilities@CSDIOControllerBase@@UAAHXZ|, CSDIOControllerBase::InterpretCapabilities

	END
