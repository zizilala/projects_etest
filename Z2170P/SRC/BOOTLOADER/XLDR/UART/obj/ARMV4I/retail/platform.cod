; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\XLDR\platform.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|OMAP37x_OPP_Table| [ DATA ]
	EXPORT	|BSP_DDR_device_params| [ DATA ]

  00000			 AREA	 |.data|, DATA
|OMAP37x_OPP_Table| DCD 0x12c
	DCD	0x104
	DCD	0x1b
	DCD	0x2b
	DCD	0x258
	DCD	0x208
	DCD	0x28
	DCD	0x2b
	DCD	0x320
	DCD	0x294
	DCD	0x35
	DCD	0x2b
	DCD	0x3e8
	DCD	0x320
	DCD	0x3e
	DCD	0x2b
|BSP_DDR_device_params| DCD 0x2584099
	DCD	0x2584099
	DCD	0xaa9db4c6
	DCD	0x2014
	DCD	0xaa9db4c6
	DCD	0x2014
	DCD	0x4e201
	DCD	0x4e201
	DCD	0x3588099
	DCD	0x3580099
	DCD	0xa2e1b4c6
	DCD	0x2131c
	DCD	0xa2e1b4c6
	DCD	0x2131c
	DCD	0x5e601
	DCD	0x5e601
	DCD	0x3588099
	DCD	0x3580099
	DCD	0xa2e1b4c6
	DCD	0x2131c
	DCD	0xa2e1b4c6
	DCD	0x2131c
	DCD	0x5e601
	DCD	0x5e601

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|?initialPinMux@?1??PinMuxSetup@@9@9| DCW 0x0		; `PinMuxSetup'::`2'::initialPinMux
	%	2
	DCD	0x1
	DCW	0x1
	%	2
	DCD	0x1
	DCW	0x2
	%	2
	DCD	0x1
	DCW	0x3
	%	2
	DCD	0x1
	DCW	0x4
	%	2
	DCD	0x1
	DCW	0x5
	%	2
	DCD	0x1
	DCW	0x6
	%	2
	DCD	0x1
	DCW	0x7
	%	2
	DCD	0x1
	DCW	0x8
	%	2
	DCD	0x1
	DCW	0x9
	%	2
	DCD	0x1
	DCW	0xa
	%	2
	DCD	0x1
	DCW	0xb
	%	2
	DCD	0x1
	DCW	0xc
	%	2
	DCD	0x1
	DCW	0xd
	%	2
	DCD	0x1
	DCW	0xe
	%	2
	DCD	0x1
	DCW	0xf
	%	2
	DCD	0x1
	DCW	0x10
	%	2
	DCD	0x1
	DCW	0x11
	%	2
	DCD	0x1
	DCW	0x12
	%	2
	DCD	0x1
	DCW	0x13
	%	2
	DCD	0x1
	DCW	0x14
	%	2
	DCD	0x1
	DCW	0x15
	%	2
	DCD	0x1
	DCW	0x16
	%	2
	DCD	0x1
	DCW	0x17
	%	2
	DCD	0x1
	DCW	0x18
	%	2
	DCD	0x1
	DCW	0x19
	%	2
	DCD	0x1
	DCW	0x1a
	%	2
	DCD	0x1
	DCW	0x1b
	%	2
	DCD	0x1
	DCW	0x1c
	%	2
	DCD	0x1
	DCW	0x1d
	%	2
	DCD	0x1
	DCW	0x1e
	%	2
	DCD	0x1
	DCW	0x1f
	%	2
	DCD	0x1
	DCW	0x20
	%	2
	DCD	0x1
	DCW	0x21
	%	2
	DCD	0x1
	DCW	0x22
	%	2
	DCD	0x1
	DCW	0x23
	%	2
	DCD	0x1
	DCW	0x24
	%	2
	DCD	0x1
	DCW	0x119
	%	2
	DCD	0x1
	DCW	0x11a
	%	2
	DCD	0x1
	DCW	0x2f
	%	2
	DCD	0x1
	DCW	0x30
	%	2
	DCD	0x1
	DCW	0x31
	%	2
	DCD	0x1
	DCW	0x32
	%	2
	DCD	0x1
	DCW	0x33
	%	2
	DCD	0x1
	DCW	0x34
	%	2
	DCD	0x1
	DCW	0x35
	%	2
	DCD	0x1
	DCW	0x36
	%	2
	DCD	0x1
	DCW	0x37
	%	2
	DCD	0x1
	DCW	0x38
	%	2
	DCD	0x1
	DCW	0x39
	%	2
	DCD	0x1
	DCW	0x3a
	%	2
	DCD	0x1
	DCW	0x3b
	%	2
	DCD	0x1
	DCW	0x3c
	%	2
	DCD	0x1
	DCW	0x3d
	%	2
	DCD	0x1
	DCW	0x3e
	%	2
	DCD	0x1
	DCW	0x3f
	%	2
	DCD	0x0
	DCW	0x47
	%	2
	DCD	0x0
	DCW	0x48
	%	2
	DCD	0x0
	DCW	0x49
	%	2
	DCD	0x0
	DCW	0x4a
	%	2
	DCD	0x0
	DCW	0x4b
	%	2
	DCD	0x0
	DCW	0x4d
	%	2
	DCD	0x0
	DCW	0x4e
	%	2
	DCD	0x7
	DCW	0xb8
	%	2
	DCD	0x0
	DCW	0xb6
	%	2
	DCD	0x0
	DCW	0xb5
	%	2
	DCD	0x1
	DCW	0xb7
	%	2
	DCD	0x1
	DCW	0x8a
	%	2
	DCD	0x7
	DCW	0x8b
	%	2
	DCD	0x1
	DCW	0x8c
	%	2
	DCD	0x7
	DCW	0x8d
	%	2
	DCD	0x7
	DCW	0x8e
	%	2
	DCD	0x7
	DCW	0x8f
	%	2
	DCD	0x7
	DCW	0xc5
	%	2
	DCD	0x1
	DCW	0xc6
	%	2
	DCD	0x1
	DCW	0x518
	%	2
	DCD	0x1
	DCW	0x82
	%	2
	DCD	0x21
	DCW	0xad
	%	2
	DCD	0x20
	DCW	0xab
	%	2
	DCD	0x21
	DCW	0xaa
	%	2
	DCD	0x21
	DCW	0xa0
	%	2
	DCD	0x23
	DCW	0x9a
	%	2
	DCD	0x20
	DCW	0x2d8
	%	2
	DCD	0x20
	DCW	0x2d7
	%	2
	DCD	0x20
	DCW	0x25
	%	2
	DCD	0x20
	DCW	0x27
	%	2
	DCD	0x20
	DCW	0x28
	%	2
	DCD	0x20
	DCW	0x29
	%	2
	DCD	0x20
	DCW	0x2e
	%	2
	DCD	0x21
	DCW	0x9d
	%	2
	DCD	0x20
	DCW	0xffff
	%	2
	DCD	0x0
	IMPORT	|SOCSetPadConfig|
; File c:\wince600\platform\z2170p\src\inc\bsp_padcfg.h

  00000			 AREA	 |.pdata|, PDATA
|$T46789| DCD	|$LN9@ConfigureP|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ConfigurePadArray| PROC

; 588  : {

  00000		 |$LN9@ConfigureP|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46786|
  00004	e1a04000	 mov         r4, r0

; 589  :     int i=0;
; 590  :     while (padArray[i].padID != (UINT16) -1)

  00008	e1d420b0	 ldrh        r2, [r4]
  0000c	e3a03cff	 mov         r3, #0xFF, 24
  00010	e38350ff	 orr         r5, r3, #0xFF
  00014	e1520005	 cmp         r2, r5
  00018	e3a06000	 mov         r6, #0
  0001c	0a00000b	 beq         |$LN1@ConfigureP|
  00020	e3a01c7f	 mov         r1, #0x7F, 24
  00024	e38170ff	 orr         r7, r1, #0xFF
  00028	e1a03004	 mov         r3, r4
  0002c		 |$LL2@ConfigureP|

; 591  :     {
; 592  :         SOCSetPadConfig(padArray[i].padID,(UINT16) padArray[i].Cfg);

  0002c	e5933004	 ldr         r3, [r3, #4]
  00030	e1a00002	 mov         r0, r2
  00034	e0031007	 and         r1, r3, r7
  00038	eb000000	 bl          SOCSetPadConfig

; 593  :         i++;

  0003c	e2866001	 add         r6, r6, #1
  00040	e0843186	 add         r3, r4, r6, lsl #3
  00044	e1d320b0	 ldrh        r2, [r3]
  00048	e1520005	 cmp         r2, r5
  0004c	1afffff6	 bne         |$LL2@ConfigureP|
  00050		 |$LN1@ConfigureP|

; 594  :     }
; 595  : }

  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M46787|

			 ENDP  ; |ConfigurePadArray|

; File c:\wince600\platform\z2170p\src\bootloader\xldr\platform.c

  00000			 AREA	 |.pdata|, PDATA
|$T46811| DCD	|$LN15@WaitOnValu|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitOnValue| PROC

; 156  : {

  00000		 |$LN15@WaitOnValu|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46808|

; 157  : 	UINT32 i = 0, val;
; 158  : 	for(;;)
; 159  : 	{
; 160  : 		i++;
; 161  : 		val = INREG32(readAddr) & readBitMask;

  00004	e3a04001	 mov         r4, #1
  00008	ea000002	 b           |$LN12@WaitOnValu|
  0000c		 |$LL4@WaitOnValu|

; 164  : 		if (i == bound)

  0000c	e1540003	 cmp         r4, r3
  00010	0a000007	 beq         |$LN10@WaitOnValu|
  00014	e2844001	 add         r4, r4, #1
  00018		 |$LN12@WaitOnValu|
  00018	e592e000	 ldr         lr, [r2]
  0001c	e00ee000	 and         lr, lr, r0
  00020	e15e0001	 cmp         lr, r1
  00024	1afffff8	 bne         |$LL4@WaitOnValu|

; 162  : 		if (val == matchValue)
; 163  : 			return 1;

  00028	e3a00001	 mov         r0, #1

; 166  : 	} 
; 167  : }

  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$LN10@WaitOnValu|

; 165  : 			return 0;

  00034	e3a00000	 mov         r0, #0

; 166  : 	} 
; 167  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M46809|

			 ENDP  ; |WaitOnValue|

	EXPORT	|OALGetTickCount|

  00000			 AREA	 |.pdata|, PDATA
|$T46820| DCD	|$LN5@OALGetTick|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALGetTickCount| PROC

; 177  : {

  00000		 |$LN5@OALGetTick|
  00000		 |$M46817|

; 178  :     return 1;

  00000	e3a00001	 mov         r0, #1

; 179  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46818|

			 ENDP  ; |OALGetTickCount|

	EXPORT	|Mpu_dpll_init|
	IMPORT	|OALPAtoVA|

  00000			 AREA	 |.pdata|, PDATA
|$T46832| DCD	|$LN11@Mpu_dpll_i|
	DCD	0x40001e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Mpu_dpll_init| PROC

; 188  : {

  00000		 |$LN11@Mpu_dpll_i|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46829|
  00004	e1a04000	 mov         r4, r0
  00008	e3a03312	 mov         r3, #0x12, 6

; 189  :     OMAP_PRCM_MPU_CM_REGS* pPrcmMpuCM = OALPAtoUA(OMAP_PRCM_MPU_CM_REGS_PA);

  0000c	e3830c49	 orr         r0, r3, #0x49, 24
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          OALPAtoVA

; 190  :     unsigned int val, mpu_mult;
; 191  : 
; 192  :     // put mpu dpll in bypass
; 193  :     val = INREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU);

  00018	e5903004	 ldr         r3, [r0, #4]

; 194  :     val &= ~DPLL_MODE_MASK;
; 195  :     val |= DPLL_MODE_LOWPOWER_BYPASS;

  0001c	e3c33007	 bic         r3, r3, #7
  00020	e3833005	 orr         r3, r3, #5

; 196  :     OUTREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU, val);

  00024	e5803004	 str         r3, [r0, #4]
  00028		 |$LL4@Mpu_dpll_i|

; 197  :     while ((INREG32(&pPrcmMpuCM->CM_IDLEST_PLL_MPU) & DPLL_STATUS_MASK) != DPLL_STATUS_BYPASSED);

  00028	e5903024	 ldr         r3, [r0, #0x24]
  0002c	e3130001	 tst         r3, #1
  00030	1afffffc	 bne         |$LL4@Mpu_dpll_i|

; 198  : 
; 199  :     // setup DPLL1 divider
; 200  :     OUTREG32(&pPrcmMpuCM->CM_CLKSEL2_PLL_MPU, BSP_CM_CLKSEL2_PLL_MPU);

  00034	e3a03001	 mov         r3, #1
  00038	e5803044	 str         r3, [r0, #0x44]

; 201  :     
; 202  :     // configure m:n clock ratios as well as frequency selection for mpu dpll
; 203  :     mpu_mult = ((opp_setting->MPUSpeed / 2) << 8);
; 204  :     val = BSP_MPU_CLK_SRC | mpu_mult | BSP_MPU_DPLL_DIV;
; 205  :     OUTREG32(&pPrcmMpuCM->CM_CLKSEL1_PLL_MPU, val);

  0003c	e5943000	 ldr         r3, [r4]
  00040	e3a01601	 mov         r1, #1, 12
  00044	e3c32001	 bic         r2, r3, #1
  00048	e381300c	 orr         r3, r1, #0xC
  0004c	e1833382	 orr         r3, r3, r2, lsl #7
  00050	e3a02c02	 mov         r2, #2, 24
  00054	e5803040	 str         r3, [r0, #0x40]

; 206  : 
; 207  :     // lock dpll with correct frequency selection
; 208  :     OUTREG32(&pPrcmMpuCM->CM_CLKEN_PLL_MPU, BSP_CM_CLKEN_PLL_MPU);

  00058	e3823077	 orr         r3, r2, #0x77
  0005c	e5803004	 str         r3, [r0, #4]
  00060		 |$LL2@Mpu_dpll_i|

; 209  :     while ((INREG32(&pPrcmMpuCM->CM_IDLEST_PLL_MPU) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00060	e5903024	 ldr         r3, [r0, #0x24]
  00064	e2033001	 and         r3, r3, #1
  00068	e3530001	 cmp         r3, #1
  0006c	1afffffb	 bne         |$LL2@Mpu_dpll_i|

; 210  : }    

  00070	e8bd4010	 ldmia       sp!, {r4, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M46830|

			 ENDP  ; |Mpu_dpll_init|

	EXPORT	|Iva_dpll_init|
	IMPORT	|gCPU_family|

  00000			 AREA	 |.pdata|, PDATA
|$T46845| DCD	|$LN13@Iva_dpll_i|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Iva_dpll_init| PROC

; 220  : {

  00000		 |$LN13@Iva_dpll_i|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46842|
  00004	e1a04000	 mov         r4, r0
  00008	e3a03312	 mov         r3, #0x12, 6

; 221  :     OMAP_PRCM_IVA2_CM_REGS* pPrcmIvaCM = OALPAtoUA(OMAP_PRCM_IVA2_CM_REGS_PA);

  0000c	e3830901	 orr         r0, r3, #1, 18
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          OALPAtoVA

; 222  :     unsigned int val, iva_mult;
; 223  : 
; 224  :     //---------------------------------
; 225  :     // setup dpll timings for iva2 dpll
; 226  :     //
; 227  : 
; 228  :     // put iva2 dpll in bypass
; 229  :     val = INREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2);

  00018	e5903004	 ldr         r3, [r0, #4]

; 230  : 
; 231  :     val &= ~DPLL_MODE_MASK;
; 232  :     val |= DPLL_MODE_LOWPOWER_BYPASS;

  0001c	e3c33007	 bic         r3, r3, #7
  00020	e3833005	 orr         r3, r3, #5

; 233  :     OUTREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2, val);

  00024	e5803004	 str         r3, [r0, #4]
  00028		 |$LL6@Iva_dpll_i|

; 234  :     while ((INREG32(&pPrcmIvaCM->CM_IDLEST_PLL_IVA2) & DPLL_STATUS_MASK) != DPLL_STATUS_BYPASSED);

  00028	e5903024	 ldr         r3, [r0, #0x24]
  0002c	e3130001	 tst         r3, #1
  00030	1afffffc	 bne         |$LL6@Iva_dpll_i|

; 235  : 
; 236  :     // setup DPLL1 divider
; 237  :     OUTREG32(&pPrcmIvaCM->CM_CLKSEL2_PLL_IVA2, BSP_CM_CLKSEL2_PLL_IVA2);

  00034	e3a03001	 mov         r3, #1
  00038	e5803044	 str         r3, [r0, #0x44]

; 238  :     
; 239  :     // configure m:n clock ratios as well as frequency selection for iva dpll
; 240  :     iva_mult = ((opp_setting->IVASpeed/ 2) << 8);
; 241  :     val = BSP_3530_IVA2_CLK_SRC | iva_mult | BSP_IVA2_DPLL_DIV;
; 242  :     OUTREG32(&pPrcmIvaCM->CM_CLKSEL1_PLL_IVA2, val);

  0003c	e5943004	 ldr         r3, [r4, #4]
  00040	e3a01601	 mov         r1, #1, 12
  00044	e3c32001	 bic         r2, r3, #1
  00048	e381300c	 orr         r3, r1, #0xC

; 243  : 
; 244  :     // lock dpll with correct frequency selection
; 245  :     if(gCPU_family == CPU_FAMILY_DM37XX)

  0004c	e59f1034	 ldr         r1, [pc, #0x34]
  00050	e1833382	 orr         r3, r3, r2, lsl #7
  00054	e5803040	 str         r3, [r0, #0x40]
  00058	e5913000	 ldr         r3, [r1]
  0005c	e3530001	 cmp         r3, #1

; 246  :     {
; 247  :         //val = (BSP_EN_IVA2_DPLL_LPMODE | BSP_EN_IVA2_DPLL_DRIFTGUARD | BSP_EN_IVA2_DPLL);
; 248  :         val = (BSP_EN_IVA2_DPLL_LPMODE | BSP_EN_IVA2_DPLL);

  00060	03a03007	 moveq       r3, #7

; 249  :     }
; 250  :     else

  00064	13a03c02	 movne       r3, #2, 24

; 251  :     {
; 252  :         val = BSP_CM_CLKEN_PLL_IVA2;

  00068	13833077	 orrne       r3, r3, #0x77

; 253  :     }
; 254  :     OUTREG32(&pPrcmIvaCM->CM_CLKEN_PLL_IVA2, val);

  0006c	e5803004	 str         r3, [r0, #4]
  00070		 |$LL2@Iva_dpll_i|

; 255  :     while ((INREG32(&pPrcmIvaCM->CM_IDLEST_PLL_IVA2) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00070	e5903024	 ldr         r3, [r0, #0x24]
  00074	e2033001	 and         r3, r3, #1
  00078	e3530001	 cmp         r3, #1
  0007c	1afffffb	 bne         |$LL2@Iva_dpll_i|

; 256  : 
; 257  : }

  00080	e8bd4010	 ldmia       sp!, {r4, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$LN14@Iva_dpll_i|
  00088		 |$LN15@Iva_dpll_i|
  00088	00000000	 DCD         |gCPU_family|
  0008c		 |$M46843|

			 ENDP  ; |Iva_dpll_init|

	EXPORT	|Omap37xx_dpll4_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46859| DCD	|$LN8@Omap37xx_d|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Omap37xx_dpll4_init| PROC

; 266  : {

  00000		 |$LN8@Omap37xx_d|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46856|
  00004	e3a06312	 mov         r6, #0x12, 6

; 267  :     OMAP_PRCM_EMU_CM_REGS* pPrcmEmuCM = OALPAtoUA(OMAP_PRCM_EMU_CM_REGS_PA);

  00008	e3860c51	 orr         r0, r6, #0x51, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a05000	 mov         r5, r0

; 268  :     OMAP_PRCM_CAM_CM_REGS* pPrcmCamCM = OALPAtoUA(OMAP_PRCM_CAM_CM_REGS_PA);

  00018	e3860c4f	 orr         r0, r6, #0x4F, 24
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          OALPAtoVA
  00024	e1a04000	 mov         r4, r0

; 269  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00028	e3860c4d	 orr         r0, r6, #0x4D, 24
  0002c	e3a01000	 mov         r1, #0
  00030	eb000000	 bl          OALPAtoVA

; 270  :     //OMAP_PRCM_SGX_CM_REGS* pPrcmSgxCM = OALPAtoUA(OMAP_PRCM_SGX_CM_REGS_PA);	
; 271  :     unsigned int val;
; 272  :     
; 273  : 
; 274  :     // configure timings for all related peripherals
; 275  :     OUTREG32(&pPrcmEmuCM->CM_CLKSEL1_EMU, BSP_CM_CLKSEL1_EMU);

  00034	e59f3054	 ldr         r3, [pc, #0x54]

; 276  :     OUTREG32(&pPrcmCamCM->CM_CLKSEL_CAM, BSP_CM_CLKSEL_CAM);
; 277  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL3_PLL, BSP_CM_CLKSEL3_PLL);
; 278  :     //OUTREG32(&pPrcmSgxCM->CM_CLKSEL_SGX, BSP_CM_CLKSEL_SGX);
; 279  : 	
; 280  :     /* Omap37xx using low jitter DPLL, the output freq is one half of OMAP 35xx DPLL4 */
; 281  :     val = INREG32(&pPrcmClkCM->CM_CLKSEL2_PLL) & 0xfff00000;

  00038	e3a01a1b	 mov         r1, #0x1B, 20
  0003c	e5853040	 str         r3, [r5, #0x40]
  00040	e3a03004	 mov         r3, #4
  00044	e5843040	 str         r3, [r4, #0x40]
  00048	e3a03009	 mov         r3, #9
  0004c	e5803048	 str         r3, [r0, #0x48]
  00050	e5902044	 ldr         r2, [r0, #0x44]
  00054	e3a034ff	 mov         r3, #0xFF, 8
  00058	e383360f	 orr         r3, r3, #0xF, 12
  0005c	e0022003	 and         r2, r2, r3

; 282  : 
; 283  :     val |= (BSP_PERIPH_DPLL_MULT_37xx | BSP_PERIPH_DPLL_DIV);

  00060	e381300c	 orr         r3, r1, #0xC
  00064	e1823003	 orr         r3, r2, r3
  00068	e3a02877	 mov         r2, #0x77, 16

; 284  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL2_PLL, val);

  0006c	e5803044	 str         r3, [r0, #0x44]

; 285  :     
; 286  :     // lock dpll with correct frequency selection
; 287  :     val =   BSP_CM_CLKEN_PLL & (~(7 << 4));
; 288  :  
; 289  :     OUTREG32(&pPrcmClkCM->CM_CLKEN_PLL, val);

  00070	e3823007	 orr         r3, r2, #7
  00074	e4803020	 str         r3, [r0], #0x20
  00078		 |$LL2@Omap37xx_d|

; 290  :     while ((INREG32(&pPrcmClkCM->CM_IDLEST_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00078	e5903000	 ldr         r3, [r0]
  0007c	e2033001	 and         r3, r3, #1
  00080	e3530001	 cmp         r3, #1
  00084	1afffffb	 bne         |$LL2@Omap37xx_d|

; 291  : 
; 292  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN9@Omap37xx_d|
  00090		 |$LN10@Omap37xx_d|
  00090	03020a50	 DCD         0x3020a50
  00094		 |$M46857|

			 ENDP  ; |Omap37xx_dpll4_init|

	EXPORT	|Dpll4_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46872| DCD	|$LN8@Dpll4_init|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Dpll4_init| PROC

; 301  : {

  00000		 |$LN8@Dpll4_init|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M46869|
  00004	e3a06312	 mov         r6, #0x12, 6

; 302  :     OMAP_PRCM_EMU_CM_REGS* pPrcmEmuCM = OALPAtoUA(OMAP_PRCM_EMU_CM_REGS_PA);

  00008	e3860c51	 orr         r0, r6, #0x51, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a05000	 mov         r5, r0

; 303  :     OMAP_PRCM_CAM_CM_REGS* pPrcmCamCM = OALPAtoUA(OMAP_PRCM_CAM_CM_REGS_PA);

  00018	e3860c4f	 orr         r0, r6, #0x4F, 24
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          OALPAtoVA
  00024	e1a04000	 mov         r4, r0

; 304  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00028	e3860c4d	 orr         r0, r6, #0x4D, 24
  0002c	e3a01000	 mov         r1, #0
  00030	eb000000	 bl          OALPAtoVA

; 305  : 
; 306  :     // configure timings for all related peripherals
; 307  :     OUTREG32(&pPrcmEmuCM->CM_CLKSEL1_EMU, BSP_CM_CLKSEL1_EMU);

  00034	e59f3054	 ldr         r3, [pc, #0x54]

; 308  :     OUTREG32(&pPrcmCamCM->CM_CLKSEL_CAM, BSP_CM_CLKSEL_CAM);
; 309  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL3_PLL, BSP_CM_CLKSEL3_PLL);
; 310  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL2_PLL, (INREG32(&pPrcmClkCM->CM_CLKSEL2_PLL) & 0xfff00000) | BSP_CM_CLKSEL2_PLL);

  00038	e3a01b36	 mov         r1, #0x36, 22
  0003c	e5853040	 str         r3, [r5, #0x40]
  00040	e3a03004	 mov         r3, #4
  00044	e5843040	 str         r3, [r4, #0x40]
  00048	e3a03009	 mov         r3, #9
  0004c	e5803048	 str         r3, [r0, #0x48]
  00050	e5902044	 ldr         r2, [r0, #0x44]
  00054	e3a034ff	 mov         r3, #0xFF, 8
  00058	e383360f	 orr         r3, r3, #0xF, 12
  0005c	e0022003	 and         r2, r2, r3
  00060	e381300c	 orr         r3, r1, #0xC
  00064	e1823003	 orr         r3, r2, r3
  00068	e3a02877	 mov         r2, #0x77, 16
  0006c	e5803044	 str         r3, [r0, #0x44]

; 311  : 
; 312  :     // lock dpll with correct frequency selection
; 313  :     OUTREG32(&pPrcmClkCM->CM_CLKEN_PLL, BSP_CM_CLKEN_PLL);

  00070	e3823077	 orr         r3, r2, #0x77
  00074	e4803020	 str         r3, [r0], #0x20
  00078		 |$LL2@Dpll4_init|

; 314  :     while ((INREG32(&pPrcmClkCM->CM_IDLEST_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00078	e5903000	 ldr         r3, [r0]
  0007c	e2033001	 and         r3, r3, #1
  00080	e3530001	 cmp         r3, #1
  00084	1afffffb	 bne         |$LL2@Dpll4_init|

; 315  : 
; 316  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN9@Dpll4_init|
  00090		 |$LN10@Dpll4_init|
  00090	03020a50	 DCD         0x3020a50
  00094		 |$M46870|

			 ENDP  ; |Dpll4_init|

	EXPORT	|Omap37xx_core_dpll_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46883| DCD	|$LN5@Omap37xx_c|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Omap37xx_core_dpll_init| PROC

; 325  : {

  00000		 |$LN5@Omap37xx_c|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46880|
  00004	e3a05312	 mov         r5, #0x12, 6

; 326  :     OMAP_PRCM_CORE_CM_REGS* pPrcmCoreCM = OALPAtoUA(OMAP_PRCM_CORE_CM_REGS_PA);

  00008	e3850c4a	 orr         r0, r5, #0x4A, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a04000	 mov         r4, r0

; 327  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00018	e3850c4d	 orr         r0, r5, #0x4D, 24
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          OALPAtoVA

; 328  : 
; 329  :     //---------------------------------
; 330  :     // setup dpll timings for core and peripheral dpll
; 331  :     //
; 332  :     
; 333  :     // configure clock ratios for L3, L4, FSHOSTUSB, SSI
; 334  :     // configure clock selection for gpt10, gpt11
; 335  :     OUTREG32(&pPrcmCoreCM->CM_CLKSEL_CORE, BSP_CM_CLKSEL_CORE);
; 336  :     //OUTREG32(&pPrcmCoreCM->CM_FCLKEN1_CORE, 0x1 <<13);
; 337  : 
; 338  :     // configure m:n clock ratios as well as frequency selection for core dpll
; 339  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL1_PLL, (BSP_CORE_DPLL_CLKOUT_DIV | CORE_DPLL_MULT_400 | \
; 340  :                                                                         CORE_DPLL_DIV_400 | BSP_SOURCE_96M));

  00024	e59f2014	 ldr         r2, [pc, #0x14]
  00028	e3a03c13	 mov         r3, #0x13, 24
  0002c	e383300a	 orr         r3, r3, #0xA
  00030	e5843040	 str         r3, [r4, #0x40]
  00034	e5802040	 str         r2, [r0, #0x40]

; 341  : 
; 342  : }

  00038	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN6@Omap37xx_c|
  00040		 |$LN7@Omap37xx_c|
  00040	08c80c00	 DCD         0x8c80c00
  00044		 |$M46881|

			 ENDP  ; |Omap37xx_core_dpll_init|

	EXPORT	|Core_dpll_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46894| DCD	|$LN5@Core_dpll_|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Core_dpll_init| PROC

; 351  : {

  00000		 |$LN5@Core_dpll_|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46891|
  00004	e3a05312	 mov         r5, #0x12, 6

; 352  :     OMAP_PRCM_CORE_CM_REGS* pPrcmCoreCM = OALPAtoUA(OMAP_PRCM_CORE_CM_REGS_PA);

  00008	e3850c4a	 orr         r0, r5, #0x4A, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a04000	 mov         r4, r0

; 353  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00018	e3850c4d	 orr         r0, r5, #0x4D, 24
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          OALPAtoVA

; 354  : 
; 355  :     //---------------------------------
; 356  :     // setup dpll timings for core and peripheral dpll
; 357  :     //
; 358  :     
; 359  :     // configure clock ratios for L3, L4, FSHOSTUSB, SSI
; 360  :     // configure clock selection for gpt10, gpt11
; 361  :     OUTREG32(&pPrcmCoreCM->CM_CLKSEL_CORE, BSP_CM_CLKSEL_CORE);
; 362  :     
; 363  :     // configure m:n clock ratios as well as frequency selection for core dpll
; 364  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL1_PLL, BSP_CM_CLKSEL1_PLL);

  00024	e59f2014	 ldr         r2, [pc, #0x14]
  00028	e3a03c13	 mov         r3, #0x13, 24
  0002c	e383300a	 orr         r3, r3, #0xA
  00030	e5843040	 str         r3, [r4, #0x40]
  00034	e5802040	 str         r2, [r0, #0x40]

; 365  : 
; 366  : }

  00038	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN6@Core_dpll_|
  00040		 |$LN7@Core_dpll_|
  00040	08a60c00	 DCD         0x8a60c00
  00044		 |$M46892|

			 ENDP  ; |Core_dpll_init|

	EXPORT	|Per_dpll_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46905| DCD	|$LN8@Per_dpll_i|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Per_dpll_init| PROC

; 374  : {

  00000		 |$LN8@Per_dpll_i|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46902|
  00004	e3a03312	 mov         r3, #0x12, 6

; 375  : 
; 376  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00008	e3830c4d	 orr         r0, r3, #0x4D, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA

; 377  : 
; 378  :     //---------------------------------
; 379  :     // setup dpll timings for core and peripheral dpll
; 380  :     //
; 381  :     
; 382  :     // configure clock ratios for 120m
; 383  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL5_PLL, BSP_CM_CLKSEL5_PLL);

  00014	e3a03001	 mov         r3, #1
  00018	e3a02b0f	 mov         r2, #0xF, 22
  0001c	e5803050	 str         r3, [r0, #0x50]

; 384  :     
; 385  :     // configure m:n clock ratios as well as frequency selection for core dpll
; 386  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL4_PLL, BSP_CM_CLKSEL4_PLL);

  00020	e382300c	 orr         r3, r2, #0xC
  00024	e580304c	 str         r3, [r0, #0x4C]

; 387  : 
; 388  :     // lock dpll with correct frequency selection
; 389  :     OUTREG32(&pPrcmClkCM->CM_CLKEN2_PLL, BSP_CM_CLKEN2_PLL);

  00028	e3a03077	 mov         r3, #0x77
  0002c	e5803004	 str         r3, [r0, #4]
  00030		 |$LL2@Per_dpll_i|

; 390  :     while ((INREG32(&pPrcmClkCM->CM_IDLEST2_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00030	e5903024	 ldr         r3, [r0, #0x24]
  00034	e2033001	 and         r3, r3, #1
  00038	e3530001	 cmp         r3, #1
  0003c	1afffffb	 bne         |$LL2@Per_dpll_i|

; 391  :     
; 392  : 
; 393  : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$M46903|

			 ENDP  ; |Per_dpll_init|

	EXPORT	|Omap37xx_per_dpll_init|

  00000			 AREA	 |.pdata|, PDATA
|$T46914| DCD	|$LN8@Omap37xx_p|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Omap37xx_per_dpll_init| PROC

; 402  : {

  00000		 |$LN8@Omap37xx_p|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46911|
  00004	e3a03312	 mov         r3, #0x12, 6

; 403  : 
; 404  :     OMAP_PRCM_CLOCK_CONTROL_CM_REGS* pPrcmClkCM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_CM_REGS_PA);

  00008	e3830c4d	 orr         r0, r3, #0x4D, 24
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA

; 405  :     unsigned int val;
; 406  : 
; 407  :     //---------------------------------
; 408  :     // setup dpll timings for core and peripheral dpll
; 409  :     //
; 410  :     
; 411  :     // configure clock ratios for 120m
; 412  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL5_PLL, BSP_CM_CLKSEL5_PLL);

  00014	e3a03001	 mov         r3, #1
  00018	e3a02b0f	 mov         r2, #0xF, 22
  0001c	e5803050	 str         r3, [r0, #0x50]

; 413  :     
; 414  :     // configure m:n clock ratios as well as frequency selection for core dpll
; 415  :     OUTREG32(&pPrcmClkCM->CM_CLKSEL4_PLL, BSP_CM_CLKSEL4_PLL);

  00020	e382300c	 orr         r3, r2, #0xC
  00024	e580304c	 str         r3, [r0, #0x4C]

; 416  : 
; 417  :     // lock dpll with correct frequency selection
; 418  : /*    val = (BSP_EN_PERIPH2_DPLL_LPMODE |  BSP_PERIPH2_DPLL_RAMPTIME |       \
; 419  :              BSP_EN_PERIPH2_DPLL_DRIFTGUARD |  BSP_EN_PERIPH2_DPLL);*/
; 420  :     val = (BSP_EN_PERIPH2_DPLL_LPMODE |  BSP_PERIPH2_DPLL_RAMPTIME |       \
; 421  :            BSP_EN_PERIPH2_DPLL);
; 422  :                  
; 423  :              
; 424  :     OUTREG32(&pPrcmClkCM->CM_CLKEN2_PLL, val);

  00028	e3a03007	 mov         r3, #7
  0002c	e5803004	 str         r3, [r0, #4]
  00030		 |$LL2@Omap37xx_p|

; 425  :     while ((INREG32(&pPrcmClkCM->CM_IDLEST2_CKGEN) & DPLL_STATUS_MASK) != DPLL_STATUS_LOCKED);

  00030	e5903024	 ldr         r3, [r0, #0x24]
  00034	e2033001	 and         r3, r3, #1
  00038	e3530001	 cmp         r3, #1
  0003c	1afffffb	 bne         |$LL2@Omap37xx_p|

; 426  : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$M46912|

			 ENDP  ; |Omap37xx_per_dpll_init|


  00000			 AREA	 |.pdata|, PDATA
|$T46945| DCD	|$LN21@WatchdogSe|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WatchdogSetup| PROC

; 480  : {

  00000		 |$LN21@WatchdogSe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46942|
  00004	e3a05312	 mov         r5, #0x12, 6

; 481  : 	/* There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
; 482  : 	either taken care of by ROM (HS/EMU) or not accessible (GP).
; 483  : 	We need to take care of WD2-MPU or take a PRCM reset. WD3
; 484  : 	should not be running and does not generate a PRCM reset. */
; 485  : 
; 486  : 	OMAP_PRCM_WKUP_CM_REGS *pPrcmWkupCM = OALPAtoUA(OMAP_PRCM_WKUP_CM_REGS_PA);

  00008	e3850b13	 orr         r0, r5, #0x13, 22
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e1a04000	 mov         r4, r0

; 487  : 	OMAP_WDOG_REGS *pWdogTimer = OALPAtoUA(OMAP_WDOG2_REGS_PA);

  00018	e38509c5	 orr         r0, r5, #0xC5, 18
  0001c	e3a01000	 mov         r1, #0
  00020	eb000000	 bl          OALPAtoVA

; 488  : 
; 489  : 	SETREG32(&pPrcmWkupCM->CM_FCLKEN_WKUP, CM_CLKEN_WDT2);

  00024	e5943000	 ldr         r3, [r4]

; 490  : 	SETREG32(&pPrcmWkupCM->CM_ICLKEN_WKUP, CM_CLKEN_WDT2);
; 491  : 
; 492  : 	WaitOnValue(CM_IDLEST_ST_WDT2, CM_IDLEST_ST_WDT2, &pPrcmWkupCM->CM_IDLEST_WKUP, 5); // Some issue here

  00028	e2841020	 add         r1, r4, #0x20
  0002c	e3a02001	 mov         r2, #1
  00030	e3833020	 orr         r3, r3, #0x20
  00034	e5843000	 str         r3, [r4]
  00038	e5b43010	 ldr         r3, [r4, #0x10]!
  0003c	e3833020	 orr         r3, r3, #0x20
  00040	e5843000	 str         r3, [r4]
  00044	ea000002	 b           |$LN18@WatchdogSe|
  00048		 |$LL8@WatchdogSe|
  00048	e3520005	 cmp         r2, #5
  0004c	0a000004	 beq         |$LN16@WatchdogSe|
  00050	e2822001	 add         r2, r2, #1
  00054		 |$LN18@WatchdogSe|
  00054	e5913000	 ldr         r3, [r1]
  00058	e2033020	 and         r3, r3, #0x20
  0005c	e3530020	 cmp         r3, #0x20
  00060	1afffff8	 bne         |$LL8@WatchdogSe|
  00064		 |$LN16@WatchdogSe|
  00064	e3a03caa	 mov         r3, #0xAA, 24

; 493  : 
; 494  : 	OUTREG32(&pWdogTimer->WSPR, WDOG_DISABLE_SEQ1);

  00068	e38330aa	 orr         r3, r3, #0xAA
  0006c	e5803048	 str         r3, [r0, #0x48]
  00070		 |$LL2@WatchdogSe|

; 495  : 	while (INREG32(&pWdogTimer->WWPS));

  00070	e5903034	 ldr         r3, [r0, #0x34]
  00074	e3530000	 cmp         r3, #0
  00078	1afffffc	 bne         |$LL2@WatchdogSe|
  0007c	e3a03c55	 mov         r3, #0x55, 24

; 496  : 	OUTREG32(&pWdogTimer->WSPR, WDOG_DISABLE_SEQ2);

  00080	e3833055	 orr         r3, r3, #0x55
  00084	e5803048	 str         r3, [r0, #0x48]

; 497  : }

  00088	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M46943|

			 ENDP  ; |WatchdogSetup|

; File c:\wince600\platform\z2170p\src\inc\bsp_padcfg.h

  00000			 AREA	 |.pdata|, PDATA
|$T46961| DCD	|$LN11@PinMuxSetu|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\z2170p\src\bootloader\xldr\platform.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PinMuxSetup| PROC

; 506  : {

  00000		 |$LN11@PinMuxSetu|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M46958|

; 507  :     static const PAD_INFO initialPinMux[] = {
; 508  :             SDRC_PADS            
; 509  :             GPMC_PADS
; 510  :             UART3_PADS
; 511  :             MMC1_PADS
; 512  :             I2C1_PADS
; 513  :             WKUP_PAD_ENTRY(SYS_32K, INPUT_ENABLED | PULL_RESISTOR_DISABLED | MUXMODE(0))
; 514  :             GPIO_PADS_37XX       
; 515  :             END_OF_PAD_ARRAY
; 516  :     };
; 517  : 
; 518  :     ConfigurePadArray(initialPinMux);

  00004	e3a01c7f	 mov         r1, #0x7F, 24
  00008	e3a00cff	 mov         r0, #0xFF, 24
  0000c	e59f5040	 ldr         r5, [pc, #0x40]
  00010	e38160ff	 orr         r6, r1, #0xFF
  00014	e38070ff	 orr         r7, r0, #0xFF
  00018	e3a04000	 mov         r4, #0
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02000	 mov         r2, #0
  00024		 |$LL4@PinMuxSetu|
  00024	e0833005	 add         r3, r3, r5
  00028	e5933004	 ldr         r3, [r3, #4]
  0002c	e1a00002	 mov         r0, r2
  00030	e0031006	 and         r1, r3, r6
  00034	eb000000	 bl          SOCSetPadConfig
  00038	e2844001	 add         r4, r4, #1
  0003c	e1a03184	 mov         r3, r4, lsl #3
  00040	e19320b5	 ldrh        r2, [r3, +r5]
  00044	e1520007	 cmp         r2, r7
  00048	1afffff5	 bne         |$LL4@PinMuxSetu|

; 519  : }

  0004c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN12@PinMuxSetu|
  00054		 |$LN13@PinMuxSetu|
  00054	00000000	 DCD         |?initialPinMux@?1??PinMuxSetup@@9@9|
  00058		 |$M46959|

			 ENDP  ; |PinMuxSetup|


  00000			 AREA	 |.pdata|, PDATA
|$T46970| DCD	|$LN5@GpioSetup|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GpioSetup| PROC

; 528  : {

  00000		 |$LN5@GpioSetup|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46967|
  00004	e3a03312	 mov         r3, #0x12, 6

; 529  :     OMAP_GPIO_REGS* pGpio;
; 530  :        
; 531  :     // Initialize state/direction for all pins configured as gpio
; 532  :     // Bank 1 GPIO 0..31
; 533  :     pGpio = OALPAtoUA(OMAP_GPIO1_REGS_PA);

  00008	e3830831	 orr         r0, r3, #0x31, 16
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA

; 534  : 
; 535  :     // Set GPIO7 as output
; 536  :     OUTREG32(&pGpio->OE, ~(1 << 7));

  00014	e3e03080	 mvn         r3, #0x80
  00018	e5803034	 str         r3, [r0, #0x34]

; 537  :     // Bank 2 GPIO 32..63
; 538  :     //pGpio = OALPAtoUA(OMAP_GPIO2_REGS_PA);
; 539  :     //OUTREG32(&pGpio->OE, ~(1 << 29)); // BL_EN -output
; 540  :     //SETREG32(&pGpio->DATAOUT, 1 << 29);
; 541  : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$M46968|

			 ENDP  ; |GpioSetup|


  00000			 AREA	 |.pdata|, PDATA
|$T46982| DCD	|$LN7@ClockSetup|
	DCD	0x40003601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ClockSetup| PROC

; 551  : {    

  00000		 |$LN7@ClockSetup|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M46979|
  00004	e1a05000	 mov         r5, r0

; 552  :     
; 553  :     OMAP_PRCM_CLOCK_CONTROL_PRM_REGS* pPrcmClkPRM = OALPAtoUA(OMAP_PRCM_CLOCK_CONTROL_PRM_REGS_PA);

  00008	e59f00c4	 ldr         r0, [pc, #0xC4]
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e3a08312	 mov         r8, #0x12, 6
  00018	e1a04000	 mov         r4, r0

; 554  :     OMAP_PRCM_WKUP_CM_REGS* pPrcmWkupCM = OALPAtoUA(OMAP_PRCM_WKUP_CM_REGS_PA);

  0001c	e3880b13	 orr         r0, r8, #0x13, 22
  00020	e3a01000	 mov         r1, #0
  00024	eb000000	 bl          OALPAtoVA
  00028	e1a06000	 mov         r6, r0

; 555  :     OMAP_PRCM_PER_CM_REGS* pPrcmPerCM = OALPAtoUA(OMAP_PRCM_PER_CM_REGS_PA);

  0002c	e3880a05	 orr         r0, r8, #5, 20
  00030	e3a01000	 mov         r1, #0
  00034	eb000000	 bl          OALPAtoVA
  00038	e1a07000	 mov         r7, r0

; 556  :     OMAP_PRCM_CORE_CM_REGS* pPrcmCoreCM = OALPAtoUA(OMAP_PRCM_CORE_CM_REGS_PA);

  0003c	e3880c4a	 orr         r0, r8, #0x4A, 24
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          OALPAtoVA

; 557  :     
; 558  :     // setup input system clock
; 559  :     OUTREG32(&pPrcmClkPRM->PRM_CLKSEL, BSP_PRM_CLKSEL);
; 560  : 
; 561  :     if(gCPU_family == CPU_FAMILY_DM37XX)

  00048	e59f3080	 ldr         r3, [pc, #0x80]
  0004c	e3a02003	 mov         r2, #3
  00050	e5842040	 str         r2, [r4, #0x40]
  00054	e5933000	 ldr         r3, [r3]
  00058	e1a04000	 mov         r4, r0
  0005c	e3530001	 cmp         r3, #1
  00060	1a000006	 bne         |$LN2@ClockSetup|

; 562  :     {
; 563  :         Omap37xx_core_dpll_init();

  00064	eb000000	 bl          Omap37xx_core_dpll_init

; 564  :         Omap37xx_dpll4_init();        

  00068	eb000000	 bl          Omap37xx_dpll4_init

; 565  :         Mpu_dpll_init(opp_setting);

  0006c	e1a00005	 mov         r0, r5
  00070	eb000000	 bl          Mpu_dpll_init

; 566  :         Iva_dpll_init(opp_setting);   

  00074	e1a00005	 mov         r0, r5
  00078	eb000000	 bl          Iva_dpll_init

; 567  :         Omap37xx_per_dpll_init();

  0007c	eb000000	 bl          Omap37xx_per_dpll_init
  00080		 |$LN2@ClockSetup|

; 568  :     }
; 569  :     else
; 570  :     {
; 571  :         /*Core_dpll_init();
; 572  :         Dpll4_init();
; 573  :         Mpu_dpll_init(opp_setting);
; 574  :         Iva_dpll_init(opp_setting);    
; 575  :         Per_dpll_init();*/
; 576  :     }
; 577  :     
; 578  :     //--------------------------
; 579  :     // Enable GPTIMER1, GPIO bank 1 (debug led)
; 580  :     SETREG32(&pPrcmWkupCM->CM_FCLKEN_WKUP, (CM_CLKEN_GPT1|CM_CLKEN_GPIO1));

  00080	e5963000	 ldr         r3, [r6]

; 581  :     SETREG32(&pPrcmWkupCM->CM_ICLKEN_WKUP, (CM_CLKEN_GPT1|CM_CLKEN_GPIO1));
; 582  : 
; 583  :     // Enable UART3 (debug port) and GPIO banks that are accessed in the bootloader
; 584  :     SETREG32(&pPrcmPerCM->CM_FCLKEN_PER, (CM_CLKEN_UART3|CM_CLKEN_GPIO6|CM_CLKEN_GPIO5|CM_CLKEN_GPIO3));
; 585  :     SETREG32(&pPrcmPerCM->CM_ICLKEN_PER, (CM_CLKEN_UART3|CM_CLKEN_GPIO6|CM_CLKEN_GPIO5|CM_CLKEN_GPIO3));

  00084	e3833009	 orr         r3, r3, #9
  00088	e5863000	 str         r3, [r6]
  0008c	e5b63010	 ldr         r3, [r6, #0x10]!

; 586  : 
; 587  :     // Disable HS USB OTG interface clock
; 588  :     CLRREG32(&pPrcmCoreCM->CM_ICLKEN1_CORE, CM_CLKEN_HSOTGUSB);
; 589  : 
; 590  :     // Disable D2D interface clock
; 591  :     CLRREG32(&pPrcmCoreCM->CM_ICLKEN1_CORE, CM_CLKEN_D2D);

  00090	e3833009	 orr         r3, r3, #9
  00094	e5863000	 str         r3, [r6]
  00098	e5973000	 ldr         r3, [r7]
  0009c	e3833bd2	 orr         r3, r3, #0xD2, 22
  000a0	e5873000	 str         r3, [r7]
  000a4	e5b73010	 ldr         r3, [r7, #0x10]!
  000a8	e3833bd2	 orr         r3, r3, #0xD2, 22
  000ac	e5873000	 str         r3, [r7]
  000b0	e5943010	 ldr         r3, [r4, #0x10]
  000b4	e3c33010	 bic         r3, r3, #0x10
  000b8	e5843010	 str         r3, [r4, #0x10]
  000bc	e5943010	 ldr         r3, [r4, #0x10]
  000c0	e3c33008	 bic         r3, r3, #8
  000c4	e5843010	 str         r3, [r4, #0x10]

; 592  : 
; 593  : }

  000c8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN8@ClockSetup|
  000d0		 |$LN9@ClockSetup|
  000d0	00000000	 DCD         |gCPU_family|
  000d4		 |$LN10@ClockSetup|
  000d4	48306d00	 DCD         0x48306d00
  000d8		 |$M46980|

			 ENDP  ; |ClockSetup|

	IMPORT	|OALStall|

  00000			 AREA	 |.pdata|, PDATA
|$T47001| DCD	|$LN13@MemorySetu|
	DCD	0x40009201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MemorySetup| PROC

; 602  : {

  00000		 |$LN13@MemorySetu|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M46998|

; 603  :     OMAP_GPMC_REGS* pGpmc = OALPAtoUA(OMAP_GPMC_REGS_PA); // for NAND/NOR flash & SRAM

  00004	e3a01000	 mov         r1, #0
  00008	e3a0046e	 mov         r0, #0x6E, 8
  0000c	eb000000	 bl          OALPAtoVA
  00010	e1a04000	 mov         r4, r0

; 604  :     OMAP_SDRC_REGS* pSdrc = OALPAtoUA(OMAP_SDRC_REGS_PA); // for SDRAM

  00014	e3a0046d	 mov         r0, #0x6D, 8
  00018	e3a01000	 mov         r1, #0
  0001c	eb000000	 bl          OALPAtoVA
  00020	e1a05000	 mov         r5, r0

; 605  :     OMAP_PRCM_GLOBAL_PRM_REGS * pPrmGlobal = OALPAtoUA(OMAP_PRCM_GLOBAL_PRM_REGS_PA);

  00024	e59f0218	 ldr         r0, [pc, #0x218]
  00028	e3a01000	 mov         r1, #0
  0002c	eb000000	 bl          OALPAtoVA
  00030	e1a06000	 mov         r6, r0

; 606  :     OMAP_SYSC_PADCONFS_REGS *pConfig = OALPAtoUA(OMAP_SYSC_PADCONFS_REGS_PA);

  00034	e59f0204	 ldr         r0, [pc, #0x204]
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          OALPAtoVA

; 607  :     DDR_DEVICE_TYPE ddr_type = DDR_TYPE_MICRON;	
; 608  :     DDR_DEVICE_PARAM  *pDDR_param;
; 609  :     unsigned int val = 0;
; 610  :     BOOL bColdBoot;
; 611  : 
; 612  : #ifdef FIX_DDR_STALL_ERRATA
; 613  : 	OMAP_PRCM_CORE_CM_REGS* pPrcmCoreCM = OALPAtoUA(OMAP_PRCM_CORE_CM_REGS_PA);
; 614  :     OMAP_SMS_REGS* pSms = OALPAtoUA(OMAP_SMS_REGS_PA);
; 615  : #endif
; 616  : 
; 617  :     //  Global GPMC Configuration
; 618  :     OUTREG32(&pGpmc->GPMC_SYSCONFIG,       0x00000008);   // No idle, L3 clock free running      

  00040	e3a03008	 mov         r3, #8
  00044	e5843010	 str         r3, [r4, #0x10]

; 619  :     OUTREG32(&pGpmc->GPMC_IRQENABLE,       0x00000000);   // All interrupts disabled    
; 620  :     OUTREG32(&pGpmc->GPMC_TIMEOUT_CONTROL, 0x00000000);   // Time out disabled    
; 621  :     OUTREG32(&pGpmc->GPMC_CONFIG,          0x00000011);   // WP high, force posted write for NAND    
; 622  : 
; 623  : #ifdef FMD_ONENAND
; 624  :     // Configure CS0 for OneNAND,  Base Address 0x0C000000
; 625  :     OUTREG32(&pGpmc->GPMC_CONFIG1_0, BSP_GPMC_ONENAND_CONFIG1);
; 626  :     OUTREG32(&pGpmc->GPMC_CONFIG2_0, BSP_GPMC_ONENAND_CONFIG2);
; 627  :     OUTREG32(&pGpmc->GPMC_CONFIG3_0, BSP_GPMC_ONENAND_CONFIG3);
; 628  :     OUTREG32(&pGpmc->GPMC_CONFIG4_0, BSP_GPMC_ONENAND_CONFIG4);
; 629  :     OUTREG32(&pGpmc->GPMC_CONFIG5_0, BSP_GPMC_ONENAND_CONFIG5);
; 630  :     OUTREG32(&pGpmc->GPMC_CONFIG6_0, BSP_GPMC_ONENAND_CONFIG6);
; 631  :     OUTREG32(&pGpmc->GPMC_CONFIG7_0, BSP_GPMC_ONENAND_CONFIG7);
; 632  : #endif
; 633  :     if(gCPU_family == CPU_FAMILY_DM37XX)

  00048	e59f31ec	 ldr         r3, [pc, #0x1EC]
  0004c	e3a09000	 mov         r9, #0
  00050	e584901c	 str         r9, [r4, #0x1C]
  00054	e3a02011	 mov         r2, #0x11
  00058	e5849040	 str         r9, [r4, #0x40]
  0005c	e5842050	 str         r2, [r4, #0x50]
  00060	e5933000	 ldr         r3, [r3]
  00064	e1a07000	 mov         r7, r0
  00068	e3a0e000	 mov         lr, #0
  0006c	e3530001	 cmp         r3, #1
  00070	1a00000f	 bne         |$LN7@MemorySetu|

; 634  :     {
; 635  : #ifdef FMD_NAND
; 636  :         // Configure CS0 for NAND,  Base Address 0x08000000
; 637  :         OUTREG32(&pGpmc->GPMC_CONFIG1_0, BSP_GPMC_NAND_CONFIG1_200);

  00074	e3a03b06	 mov         r3, #6, 22

; 638  :         OUTREG32(&pGpmc->GPMC_CONFIG2_0, BSP_GPMC_NAND_CONFIG2_200);
; 639  :         OUTREG32(&pGpmc->GPMC_CONFIG3_0, BSP_GPMC_NAND_CONFIG3_200);
; 640  :         OUTREG32(&pGpmc->GPMC_CONFIG4_0, BSP_GPMC_NAND_CONFIG4_200);

  00078	e5843060	 str         r3, [r4, #0x60]

; 641  :         OUTREG32(&pGpmc->GPMC_CONFIG5_0, BSP_GPMC_NAND_CONFIG5_200);

  0007c	e3a03705	 mov         r3, #5, 14
  00080	e59f11b0	 ldr         r1, [pc, #0x1B0]
  00084	e59fe1a8	 ldr         lr, [pc, #0x1A8]
  00088	e3833b05	 orr         r3, r3, #5, 22

; 642  :         OUTREG32(&pGpmc->GPMC_CONFIG6_0, BSP_GPMC_NAND_CONFIG6_200);

  0008c	e59f219c	 ldr         r2, [pc, #0x19C]
  00090	e5843064	 str         r3, [r4, #0x64]
  00094	e5843068	 str         r3, [r4, #0x68]
  00098	e584106c	 str         r1, [r4, #0x6C]
  0009c	e3a03c0f	 mov         r3, #0xF, 24
  000a0	e584e070	 str         lr, [r4, #0x70]
  000a4	e5842074	 str         r2, [r4, #0x74]

; 643  :         OUTREG32(&pGpmc->GPMC_CONFIG7_0, BSP_GPMC_NAND_CONFIG7);

  000a8	e3833048	 orr         r3, r3, #0x48

; 644  : #endif
; 645  :     
; 646  :         // Configure CS5 for LAN,  Base Address 0x15000000
; 647  :         //OUTREG32(&pGpmc->GPMC_CONFIG1_5, BSP_GPMC_LAN_CONFIG1_200);
; 648  :         //OUTREG32(&pGpmc->GPMC_CONFIG2_5, BSP_GPMC_LAN_CONFIG2_200);
; 649  :         //OUTREG32(&pGpmc->GPMC_CONFIG3_5, BSP_GPMC_LAN_CONFIG3_200);
; 650  :         //OUTREG32(&pGpmc->GPMC_CONFIG4_5, BSP_GPMC_LAN_CONFIG4_200); 
; 651  :         //OUTREG32(&pGpmc->GPMC_CONFIG5_5, BSP_GPMC_LAN_CONFIG5_200); 
; 652  :         //OUTREG32(&pGpmc->GPMC_CONFIG6_5, BSP_GPMC_LAN_CONFIG6_200); 
; 653  :         //OUTREG32(&pGpmc->GPMC_CONFIG7_5, BSP_GPMC_LAN_CONFIG7); 
; 654  : 
; 655  :         ddr_type = DDR_TYPE_HYNIX_512;

  000ac	e3a0e002	 mov         lr, #2
  000b0	ea000012	 b           |$LN10@MemorySetu|
  000b4		 |$LN7@MemorySetu|

; 656  :     }
; 657  :     else if (gCPU_family == CPU_FAMILY_OMAP35XX)

  000b4	e3530000	 cmp         r3, #0
  000b8	1a000011	 bne         |$LN5@MemorySetu|
  000bc	e3a03806	 mov         r3, #6, 16

; 658  :     {
; 659  : #ifdef FMD_NAND
; 660  :         // Configure CS0 for NAND,  Base Address 0x08000000
; 661  :         OUTREG32(&pGpmc->GPMC_CONFIG1_0, BSP_GPMC_NAND_CONFIG1_166);
; 662  :         OUTREG32(&pGpmc->GPMC_CONFIG2_0, BSP_GPMC_NAND_CONFIG2_166);
; 663  :         OUTREG32(&pGpmc->GPMC_CONFIG3_0, BSP_GPMC_NAND_CONFIG3_166);

  000c0	e59f1164	 ldr         r1, [pc, #0x164]
  000c4	e3a0eb06	 mov         lr, #6, 22

; 664  :         OUTREG32(&pGpmc->GPMC_CONFIG4_0, BSP_GPMC_NAND_CONFIG4_166);

  000c8	e59f2158	 ldr         r2, [pc, #0x158]
  000cc	e3833c06	 orr         r3, r3, #6, 24

; 665  :         OUTREG32(&pGpmc->GPMC_CONFIG5_0, BSP_GPMC_NAND_CONFIG5_166);

  000d0	e59f014c	 ldr         r0, [pc, #0x14C]
  000d4	e584e060	 str         lr, [r4, #0x60]
  000d8	e5843064	 str         r3, [r4, #0x64]
  000dc	e3a03405	 mov         r3, #5, 8
  000e0	e5841068	 str         r1, [r4, #0x68]

; 666  :         OUTREG32(&pGpmc->GPMC_CONFIG6_0, BSP_GPMC_NAND_CONFIG6_166);

  000e4	e3833d07	 orr         r3, r3, #7, 26
  000e8	e584206c	 str         r2, [r4, #0x6C]
  000ec	e3a02c0f	 mov         r2, #0xF, 24
  000f0	e5840070	 str         r0, [r4, #0x70]
  000f4	e5843074	 str         r3, [r4, #0x74]

; 667  :         OUTREG32(&pGpmc->GPMC_CONFIG7_0, BSP_GPMC_NAND_CONFIG7);

  000f8	e3823048	 orr         r3, r2, #0x48

; 668  : #endif
; 669  :     
; 670  :         // Configure CS5 for LAN,  Base Address 0x15000000
; 671  :         //OUTREG32(&pGpmc->GPMC_CONFIG1_5, BSP_GPMC_LAN_CONFIG1_166);
; 672  :         //OUTREG32(&pGpmc->GPMC_CONFIG2_5, BSP_GPMC_LAN_CONFIG2_166);
; 673  :         //OUTREG32(&pGpmc->GPMC_CONFIG3_5, BSP_GPMC_LAN_CONFIG3_166);
; 674  :         //OUTREG32(&pGpmc->GPMC_CONFIG4_5, BSP_GPMC_LAN_CONFIG4_166); 
; 675  :         //OUTREG32(&pGpmc->GPMC_CONFIG5_5, BSP_GPMC_LAN_CONFIG5_166); 
; 676  :         //OUTREG32(&pGpmc->GPMC_CONFIG6_5, BSP_GPMC_LAN_CONFIG6_166); 
; 677  :         //OUTREG32(&pGpmc->GPMC_CONFIG7_5, BSP_GPMC_LAN_CONFIG7); 
; 678  : 
; 679  :         ddr_type = DDR_TYPE_MICRON;		

  000fc	e3a0e000	 mov         lr, #0
  00100		 |$LN10@MemorySetu|

; 667  :         OUTREG32(&pGpmc->GPMC_CONFIG7_0, BSP_GPMC_NAND_CONFIG7);

  00100	e5843078	 str         r3, [r4, #0x78]

; 668  : #endif
; 669  :     
; 670  :         // Configure CS5 for LAN,  Base Address 0x15000000
; 671  :         //OUTREG32(&pGpmc->GPMC_CONFIG1_5, BSP_GPMC_LAN_CONFIG1_166);
; 672  :         //OUTREG32(&pGpmc->GPMC_CONFIG2_5, BSP_GPMC_LAN_CONFIG2_166);
; 673  :         //OUTREG32(&pGpmc->GPMC_CONFIG3_5, BSP_GPMC_LAN_CONFIG3_166);
; 674  :         //OUTREG32(&pGpmc->GPMC_CONFIG4_5, BSP_GPMC_LAN_CONFIG4_166); 
; 675  :         //OUTREG32(&pGpmc->GPMC_CONFIG5_5, BSP_GPMC_LAN_CONFIG5_166); 
; 676  :         //OUTREG32(&pGpmc->GPMC_CONFIG6_5, BSP_GPMC_LAN_CONFIG6_166); 
; 677  :         //OUTREG32(&pGpmc->GPMC_CONFIG7_5, BSP_GPMC_LAN_CONFIG7); 
; 678  : 
; 679  :         ddr_type = DDR_TYPE_MICRON;		

  00104		 |$LN5@MemorySetu|

; 680  : 
; 681  :     }
; 682  :     else
; 683  :     {
; 684  :         /* Not supported CPU family , use default ddr_type */
; 685  :     }
; 686  :     // check global reset status
; 687  :     val = INREG32(&pPrmGlobal->PRM_RSTST);

  00104	e5963058	 ldr         r3, [r6, #0x58]

; 688  : 
; 689  :     if (val & (GLOBAL_SW_RST | EXTERNAL_WARM_RST))
; 690  :         bColdBoot = FALSE;
; 691  :     else
; 692  :         bColdBoot = TRUE;
; 693  :     
; 694  : #ifdef FIX_DDR_STALL_ERRATA
; 695  : 	// Re-enable SDRC interface clock in case we come back from warm reset
; 696  : 	SETREG32(&pPrcmCoreCM->CM_ICLKEN1_CORE, CM_CLKEN_SDRC);
; 697  : 	{
; 698  : 		volatile int timeout = 1000;
; 699  : 		while(((INREG32(&pPrcmCoreCM->CM_IDLEST1_CORE) & CM_CLKEN_SDRC) != 0) || (timeout-- > 0))
; 700  : 		{
; 701  : 			OALStall(1);
; 702  : 		}
; 703  : 	}
; 704  : #endif
; 705  : 
; 706  :     // read config register
; 707  :     INREG32(&pSdrc->SDRC_SYSCONFIG);
; 708  :     pDDR_param = &BSP_DDR_device_params[ddr_type];		

  00108	e59f2110	 ldr         r2, [pc, #0x110]

; 709  : 
; 710  :     if (bColdBoot == FALSE)

  0010c	e3a08002	 mov         r8, #2
  00110	e3130042	 tst         r3, #0x42
  00114	13a01000	 movne       r1, #0
  00118	03a01001	 moveq       r1, #1
  0011c	e3510000	 cmp         r1, #0
  00120	e5953010	 ldr         r3, [r5, #0x10]

; 711  :     {
; 712  : #ifdef FIX_DDR_STALL_ERRATA
; 713  : 		// As per advisory 3.1.1.178 in errata sheet
; 714  : 		// Reset SMS controller first
; 715  : 		SETREG32(&pSms->SMS_SYSCONFIG, SMS_SYSCONFIG_SOFTRESET);
; 716  : 		{
; 717  : 			volatile int timeout = 1000;
; 718  : 			while(((INREG32(&pSms->SMS_SYSSTATUS) & SMS_SYSSTATUS_RESETDONE) == 0) || (timeout-- > 0))
; 719  : 			{
; 720  : 				OALStall(1);
; 721  : 			}
; 722  : 		}
; 723  : 
; 724  : 		//Reset SDRC controller
; 725  :         OUTREG32(&pSdrc->SDRC_SYSCONFIG, SDRC_SYSCONFIG_SOFTRESET);
; 726  : 		{
; 727  : 			volatile int timeout = 1000;
; 728  : 			while(((INREG32(&pSdrc->SDRC_SYSSTATUS) & SDRC_SYSSTATUS_RESETDONE) == 0) || (timeout-- > 0))
; 729  : 			{
; 730  : 				OALStall(1);
; 731  : 			}
; 732  : 		}
; 733  : #else
; 734  : 		//After warm reset, the SDRC will be unreliable and this will cause eboot image can't be copied from NAND flash to SDRAM correctly.
; 735  :         //Therefore, we have to force SDRC to reset after warm reset to solve this issue.
; 736  :         
; 737  :         //SDRC reset by software
; 738  :         OUTREG32(&pSdrc->SDRC_SYSCONFIG, SDRC_SYSCONFIG_SOFTRESET);
; 739  :         // wait for at least 1000us
; 740  :         OALStall(1000);

  00124	03a00ffa	 moveq       r0, #0xFA, 30
  00128	e082428e	 add         r4, r2, lr, lsl #5
  0012c	05858010	 streq       r8, [r5, #0x10]
  00130	0b000000	 bleq        OALStall

; 741  : 
; 742  :         //After SDRC reset, we do below steps to configure SDRC regisger again.
; 743  : #endif
; 744  :     }
; 745  : 	
; 746  :     //if (bColdBoot == TRUE)
; 747  :     {
; 748  :         // Disable SDRC power saving mode
; 749  :         CLRREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA);

  00134	e5953070	 ldr         r3, [r5, #0x70]

; 750  : 
; 751  :         // update memory cofiguration
; 752  :         OUTREG32(&pSdrc->SDRC_MCFG_0, pDDR_param->mcfg0);
; 753  :         OUTREG32(&pSdrc->SDRC_MCFG_1, pDDR_param->mcfg1);
; 754  :         OUTREG32(&pSdrc->SDRC_SHARING, BSP_SDRC_SHARING);

  00138	e3a02c01	 mov         r2, #1, 24

; 755  : 
; 756  :         // wait for at least 200us
; 757  :         OALStall(2000);

  0013c	e3a00e7d	 mov         r0, #0x7D, 28
  00140	e3c33004	 bic         r3, r3, #4
  00144	e5853070	 str         r3, [r5, #0x70]
  00148	e5943000	 ldr         r3, [r4]
  0014c	e5853080	 str         r3, [r5, #0x80]
  00150	e5943004	 ldr         r3, [r4, #4]
  00154	e58530b0	 str         r3, [r5, #0xB0]
  00158	e5852044	 str         r2, [r5, #0x44]
  0015c	eb000000	 bl          OALStall

; 758  : 
; 759  :         // set autorefresh
; 760  :         OUTREG32(&pSdrc->SDRC_RFR_CTRL_0, pDDR_param->rfr_ctrl0);

  00160	e5943018	 ldr         r3, [r4, #0x18]

; 761  :         OUTREG32(&pSdrc->SDRC_RFR_CTRL_1, pDDR_param->rfr_ctrl1);
; 762  : 
; 763  :         // setup ac timings
; 764  :         OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_0, pDDR_param->actim_ctrla0);
; 765  :         OUTREG32(&pSdrc->SDRC_ACTIM_CTRLA_1, pDDR_param->actim_ctrla1);
; 766  :         OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_0, pDDR_param->actim_ctrlb0);
; 767  :         OUTREG32(&pSdrc->SDRC_ACTIM_CTRLB_1, pDDR_param->actim_ctrlb1);    
; 768  : 
; 769  :         // manual command sequence to start bank 0
; 770  :         OUTREG32(&pSdrc->SDRC_MANUAL_0, 0);
; 771  :         // wait for at least 200us
; 772  :         OALStall(2000);

  00164	e3a00e7d	 mov         r0, #0x7D, 28
  00168	e58530a4	 str         r3, [r5, #0xA4]
  0016c	e594301c	 ldr         r3, [r4, #0x1C]
  00170	e58530d4	 str         r3, [r5, #0xD4]
  00174	e5943008	 ldr         r3, [r4, #8]
  00178	e585309c	 str         r3, [r5, #0x9C]
  0017c	e5943010	 ldr         r3, [r4, #0x10]
  00180	e58530c4	 str         r3, [r5, #0xC4]
  00184	e594300c	 ldr         r3, [r4, #0xC]
  00188	e58530a0	 str         r3, [r5, #0xA0]
  0018c	e5943014	 ldr         r3, [r4, #0x14]
  00190	e58530c8	 str         r3, [r5, #0xC8]
  00194	e58590a8	 str         r9, [r5, #0xA8]
  00198	eb000000	 bl          OALStall

; 773  :         OUTREG32(&pSdrc->SDRC_MANUAL_0, 1);

  0019c	e3a06001	 mov         r6, #1
  001a0	e58560a8	 str         r6, [r5, #0xA8]

; 774  :         OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);

  001a4	e58580a8	 str         r8, [r5, #0xA8]

; 775  :         OUTREG32(&pSdrc->SDRC_MANUAL_0, 2);
; 776  :         OUTREG32(&pSdrc->SDRC_MR_0, BSP_SDRC_MR_0);

  001a8	e3a04032	 mov         r4, #0x32
  001ac	e58580a8	 str         r8, [r5, #0xA8]
  001b0	e5854084	 str         r4, [r5, #0x84]

; 777  :         
; 778  :         #if BSP_MICRON_RAMSIZE_1
; 779  :             // manual command sequence to start bank 1
; 780  :             OUTREG32(&pSdrc->SDRC_MANUAL_1, 0);
; 781  :             // wait for at least 200us
; 782  :             OALStall(2000);

  001b4	e3a00e7d	 mov         r0, #0x7D, 28
  001b8	e58590d8	 str         r9, [r5, #0xD8]
  001bc	eb000000	 bl          OALStall

; 783  :             OUTREG32(&pSdrc->SDRC_MANUAL_1, 1);

  001c0	e58560d8	 str         r6, [r5, #0xD8]

; 784  :             OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);

  001c4	e58580d8	 str         r8, [r5, #0xD8]

; 785  :             OUTREG32(&pSdrc->SDRC_MANUAL_1, 2);

  001c8	e58580d8	 str         r8, [r5, #0xD8]

; 786  :             OUTREG32(&pSdrc->SDRC_MR_1, BSP_SDRC_MR_1);

  001cc	e58540b4	 str         r4, [r5, #0xB4]

; 787  :         #endif
; 788  : 
; 789  :         // re-enable power saving mode
; 790  :         SETREG32(&pSdrc->SDRC_POWER, SDRC_POWER_PWDENA | SDRC_POWER_SRFRONIDLEREQ);

  001d0	e5953070	 ldr         r3, [r5, #0x70]

; 791  : 
; 792  :         // update sdrc dll timings
; 793  :         OUTREG32(&pSdrc->SDRC_DLLA_CTRL, BSP_SDRC_DLLA_CTRL);

  001d4	e3a02426	 mov         r2, #0x26, 8
  001d8	e382200a	 orr         r2, r2, #0xA
  001dc	e3833044	 orr         r3, r3, #0x44
  001e0	e5853070	 str         r3, [r5, #0x70]
  001e4	e5852060	 str         r2, [r5, #0x60]

; 794  :         OUTREG32(&pSdrc->SDRC_DLLB_CTRL, BSP_SDRC_DLLB_CTRL);

  001e8	e5852068	 str         r2, [r5, #0x68]

; 795  :         
; 796  :         // update sdram characteristics
; 797  :         OUTREG32(&pSdrc->SDRC_EMR2_0, BSP_SDRC_EMR2_0);

  001ec	e585908c	 str         r9, [r5, #0x8C]

; 798  :         OUTREG32(&pSdrc->SDRC_EMR2_1, BSP_SDRC_EMR2_1);

  001f0	e58590bc	 str         r9, [r5, #0xBC]

; 799  :     }
; 800  :     
; 801  :     SETREG32(&pSdrc->SDRC_POWER, SDRC_POWER_SRFRONRESET);

  001f4	e5953070	 ldr         r3, [r5, #0x70]

; 802  : 
; 803  :     // allow SDRC to settle
; 804  :     OALStall(100);

  001f8	e3a00064	 mov         r0, #0x64
  001fc	e3833080	 orr         r3, r3, #0x80
  00200	e5853070	 str         r3, [r5, #0x70]
  00204	eb000000	 bl          OALStall

; 805  : 
; 806  :     // release the force on the clke signals
; 807  :     OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CKE0, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0));

  00208	e2873c02	 add         r3, r7, #2, 24
  0020c	e1c393b2	 strh        r9, [r3, #0x32]

; 808  :     OUTREG16(&pConfig->CONTROL_PADCONF_SDRC_CKE1, (INPUT_DISABLE | PULL_INACTIVE | MUX_MODE_0)); 

  00210	e2873f8d	 add         r3, r7, #0x8D, 30
  00214	e1c390b0	 strh        r9, [r3]

; 809  : }

  00218	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0021c	e12fff1e	 bx          lr
  00220		 |$LN14@MemorySetu|
  00220		 |$LN15@MemorySetu|
  00220	00000000	 DCD         |BSP_DDR_device_params|
  00224		 |$LN16@MemorySetu|
  00224	00080909	 DCD         0x80909
  00228		 |$LN17@MemorySetu|
  00228	05010801	 DCD         0x5010801
  0022c		 |$LN18@MemorySetu|
  0022c	00060401	 DCD         0x60401
  00230		 |$LN19@MemorySetu|
  00230	1f0f0a80	 DCD         0x1f0f0a80
  00234		 |$LN20@MemorySetu|
  00234	010c1414	 DCD         0x10c1414
  00238		 |$LN21@MemorySetu|
  00238	0f010f01	 DCD         0xf010f01
  0023c		 |$LN22@MemorySetu|
  0023c	00000000	 DCD         |gCPU_family|
  00240		 |$LN23@MemorySetu|
  00240	48002030	 DCD         0x48002030
  00244		 |$LN24@MemorySetu|
  00244	48307200	 DCD         0x48307200
  00248		 |$M46999|

			 ENDP  ; |MemorySetup|


  00000			 AREA	 |.pdata|, PDATA
|$T47021| DCD	|$LN5@UpdateVolt|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateVoltageLevels| PROC

; 819  : {   

  00000		 |$LN5@UpdateVolt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47018|
  00004	e1a04000	 mov         r4, r0

; 820  :     OMAP_PRCM_GLOBAL_PRM_REGS* pPrcmGblPRM = OALPAtoUA(OMAP_PRCM_GLOBAL_PRM_REGS_PA);

  00008	e59f0114	 ldr         r0, [pc, #0x114]
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e3a03812	 mov         r3, #0x12, 16

; 821  : 
; 822  :     //---------------------------------
; 823  :     // setup voltage processors
; 824  :     //
; 825  : 
; 826  :     // setup i2c for smps communication
; 827  :     OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_SA, BSP_VC_SMPS_SA_INIT);

  00018	e3833012	 orr         r3, r3, #0x12
  0001c	e1a05000	 mov         r5, r0
  00020	e5853020	 str         r3, [r5, #0x20]

; 828  :     OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_VOL_RA, BSP_VC_SMPS_VOL_RA_INIT);

  00024	e3a03801	 mov         r3, #1, 16
  00028	e5853024	 str         r3, [r5, #0x24]

; 829  :     OUTREG32(&pPrcmGblPRM->PRM_VC_SMPS_CMD_RA, BSP_VC_SMPS_CMD_RA_INIT);

  0002c	e3a03000	 mov         r3, #0
  00030	e5853028	 str         r3, [r5, #0x28]

; 830  :     OUTREG32(&pPrcmGblPRM->PRM_VC_CH_CONF, BSP_VC_CH_CONF_INIT);  

  00034	e3a03817	 mov         r3, #0x17, 16
  00038	e5853034	 str         r3, [r5, #0x34]

; 831  :     OUTREG32(&pPrcmGblPRM->PRM_VC_I2C_CFG, BSP_PRM_VC_I2C_CFG_INIT);

  0003c	e3a03005	 mov         r3, #5
  00040	e5853038	 str         r3, [r5, #0x38]

; 832  : 
; 833  :     // set intial voltage levels
; 834  :     OUTREG32(&pPrcmGblPRM->PRM_VC_CMD_VAL_0, (opp_setting->VDD1Init << 24) | BSP_PRM_VC_CMD_VAL_0_INIT );

  00044	e5943008	 ldr         r3, [r4, #8]
  00048	e3a01602	 mov         r1, #2, 12
  0004c	e3812a02	 orr         r2, r1, #2, 20
  00050	e1823c03	 orr         r3, r2, r3, lsl #24
  00054	e585302c	 str         r3, [r5, #0x2C]

; 835  :     OUTREG32(&pPrcmGblPRM->PRM_VC_CMD_VAL_1, (opp_setting->VDD2Init << 24) | BSP_PRM_VC_CMD_VAL_1_INIT);

  00058	e594300c	 ldr         r3, [r4, #0xC]

; 836  : 
; 837  :     // set PowerIC error offset, gains, and initial voltage
; 838  :     OUTREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, (opp_setting->VDD1Init << 8) | BSP_PRM_VP1_CONFIG_INIT);

  0005c	e3811008	 orr         r1, r1, #8

; 839  :     OUTREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, (opp_setting->VDD2Init << 8) | BSP_PRM_VP2_CONFIG_INIT);
; 840  : 
; 841  :     // set PowerIC slew range
; 842  :     OUTREG32(&pPrcmGblPRM->PRM_VP1_VSTEPMIN, BSP_PRM_VP1_VSTEPMIN_INIT);

  00060	e3a00b7d	 mov         r0, #0x7D, 22
  00064	e1823c03	 orr         r3, r2, r3, lsl #24
  00068	e5853030	 str         r3, [r5, #0x30]
  0006c	e5943008	 ldr         r3, [r4, #8]
  00070	e3802001	 orr         r2, r0, #1
  00074	e1813403	 orr         r3, r1, r3, lsl #8
  00078	e58530b0	 str         r3, [r5, #0xB0]
  0007c	e594300c	 ldr         r3, [r4, #0xC]
  00080	e1813403	 orr         r3, r1, r3, lsl #8
  00084	e58530d0	 str         r3, [r5, #0xD0]

; 843  :     OUTREG32(&pPrcmGblPRM->PRM_VP1_VSTEPMAX, BSP_PRM_VP1_VSTEPMAX_INIT);

  00088	e3803010	 orr         r3, r0, #0x10
  0008c	e58520b4	 str         r2, [r5, #0xB4]
  00090	e58530b8	 str         r3, [r5, #0xB8]

; 844  :     OUTREG32(&pPrcmGblPRM->PRM_VP2_VSTEPMIN, BSP_PRM_VP2_VSTEPMIN_INIT);

  00094	e58520d4	 str         r2, [r5, #0xD4]
  00098	e3e014bf	 mvn         r1, #0xBF, 8

; 845  :     OUTREG32(&pPrcmGblPRM->PRM_VP2_VSTEPMAX, BSP_PRM_VP2_VSTEPMAX_INIT);

  0009c	e58530d8	 str         r3, [r5, #0xD8]

; 846  : 
; 847  :     // set PowerIC voltage limits and timeout
; 848  :     OUTREG32(&pPrcmGblPRM->PRM_VP1_VLIMITTO, BSP_PRM_VP1_VLIMITTO_INIT);

  000a0	e22138ff	 eor         r3, r1, #0xFF, 16
  000a4	e3e024c3	 mvn         r2, #0xC3, 8
  000a8	e58530bc	 str         r3, [r5, #0xBC]

; 849  :     OUTREG32(&pPrcmGblPRM->PRM_VP2_VLIMITTO, BSP_PRM_VP2_VLIMITTO_INIT);

  000ac	e22238ff	 eor         r3, r2, #0xFF, 16
  000b0	e58530dc	 str         r3, [r5, #0xDC]

; 850  :     
; 851  :     // enable voltage processor
; 852  :     SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_VPENABLE);

  000b4	e59530b0	 ldr         r3, [r5, #0xB0]

; 853  :     SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_VPENABLE);
; 854  : 
; 855  :     // enable timeout
; 856  :     SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_TIMEOUTEN);
; 857  :     SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_TIMEOUTEN);    
; 858  : 
; 859  :     // flush commands to smps
; 860  :     SETREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_FORCEUPDATE | SMPS_INITVDD);
; 861  :     SETREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_FORCEUPDATE | SMPS_INITVDD);
; 862  : 
; 863  :     // allow voltage to settle
; 864  :     OALStall(100);

  000b8	e3a00064	 mov         r0, #0x64
  000bc	e3833001	 orr         r3, r3, #1
  000c0	e58530b0	 str         r3, [r5, #0xB0]
  000c4	e59530d0	 ldr         r3, [r5, #0xD0]
  000c8	e3833001	 orr         r3, r3, #1
  000cc	e58530d0	 str         r3, [r5, #0xD0]
  000d0	e59530b0	 ldr         r3, [r5, #0xB0]
  000d4	e3833008	 orr         r3, r3, #8
  000d8	e58530b0	 str         r3, [r5, #0xB0]
  000dc	e59530d0	 ldr         r3, [r5, #0xD0]
  000e0	e3833008	 orr         r3, r3, #8
  000e4	e58530d0	 str         r3, [r5, #0xD0]
  000e8	e59530b0	 ldr         r3, [r5, #0xB0]
  000ec	e3833006	 orr         r3, r3, #6
  000f0	e58530b0	 str         r3, [r5, #0xB0]
  000f4	e59530d0	 ldr         r3, [r5, #0xD0]
  000f8	e3833006	 orr         r3, r3, #6
  000fc	e58530d0	 str         r3, [r5, #0xD0]
  00100	eb000000	 bl          OALStall

; 865  : 
; 866  :     // disable voltage processor
; 867  :     CLRREG32(&pPrcmGblPRM->PRM_VP1_CONFIG, SMPS_VPENABLE | SMPS_FORCEUPDATE | SMPS_INITVDD | SMPS_TIMEOUTEN);

  00104	e59530b0	 ldr         r3, [r5, #0xB0]
  00108	e3c3300f	 bic         r3, r3, #0xF
  0010c	e58530b0	 str         r3, [r5, #0xB0]

; 868  :     CLRREG32(&pPrcmGblPRM->PRM_VP2_CONFIG, SMPS_VPENABLE | SMPS_FORCEUPDATE | SMPS_INITVDD | SMPS_TIMEOUTEN);

  00110	e59530d0	 ldr         r3, [r5, #0xD0]
  00114	e3c3300f	 bic         r3, r3, #0xF
  00118	e58530d0	 str         r3, [r5, #0xD0]

; 869  : }

  0011c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN6@UpdateVolt|
  00124		 |$LN7@UpdateVolt|
  00124	48307200	 DCD         0x48307200
  00128		 |$M47019|

			 ENDP  ; |UpdateVoltageLevels|

	EXPORT	|PlatformSetup|
	IMPORT	|InitTwlPower|
	IMPORT	|OALI2CPostInit|
	IMPORT	|OALI2CInit|

  00000			 AREA	 |.pdata|, PDATA
|$T47109| DCD	|$LN39@PlatformSe|
	DCD	0x4000bd01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PlatformSetup| PROC

; 436  : {

  00000		 |$LN39@PlatformSe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M47106|

; 437  :     pCPU_OPP_Settings opp_setting;
; 438  : 	
; 439  :     //---------------------------------
; 440  :     // setup dpll timings for mpu dpll
; 441  :     //
; 442  :     //if(gCPU_family == CPU_FAMILY_DM37XX)
; 443  :     //{
; 444  : 	opp_setting = &OMAP37x_OPP_Table[BSP_OPM_SELECT_37XX-1]; // BSP_OPM_SELECT_37XX=4
; 445  :     //}
; 446  :     //else 
; 447  :     //{
; 448  :     //    opp_setting = &OMAP35x_OPP_Table[BSP_OPM_SELECT_35XX-1];
; 449  :     //}
; 450  : 	
; 451  :     // Initialize the platform
; 452  :     WatchdogSetup();

  00004	e3a08312	 mov         r8, #0x12, 6
  00008	e3880b13	 orr         r0, r8, #0x13, 22
  0000c	e3a01000	 mov         r1, #0
  00010	eb000000	 bl          OALPAtoVA
  00014	e3a03312	 mov         r3, #0x12, 6
  00018	e1a04000	 mov         r4, r0
  0001c	e38309c5	 orr         r0, r3, #0xC5, 18
  00020	e3a01000	 mov         r1, #0
  00024	eb000000	 bl          OALPAtoVA
  00028	e5943000	 ldr         r3, [r4]
  0002c	e2841020	 add         r1, r4, #0x20
  00030	e3a02001	 mov         r2, #1
  00034	e3833020	 orr         r3, r3, #0x20
  00038	e5843000	 str         r3, [r4]
  0003c	e5b43010	 ldr         r3, [r4, #0x10]!
  00040	e3833020	 orr         r3, r3, #0x20
  00044	e5843000	 str         r3, [r4]
  00048	ea000002	 b           |$LN36@PlatformSe|
  0004c		 |$LL10@PlatformSe|
  0004c	e3520005	 cmp         r2, #5
  00050	0a000004	 beq         |$LN34@PlatformSe|
  00054	e2822001	 add         r2, r2, #1
  00058		 |$LN36@PlatformSe|
  00058	e5913000	 ldr         r3, [r1]
  0005c	e2033020	 and         r3, r3, #0x20
  00060	e3530020	 cmp         r3, #0x20
  00064	1afffff8	 bne         |$LL10@PlatformSe|
  00068		 |$LN34@PlatformSe|
  00068	e3a03caa	 mov         r3, #0xAA, 24
  0006c	e38330aa	 orr         r3, r3, #0xAA
  00070	e5803048	 str         r3, [r0, #0x48]
  00074		 |$LL4@PlatformSe|
  00074	e5903034	 ldr         r3, [r0, #0x34]
  00078	e3530000	 cmp         r3, #0
  0007c	1afffffc	 bne         |$LL4@PlatformSe|
  00080	e3a03c55	 mov         r3, #0x55, 24
  00084	e3833055	 orr         r3, r3, #0x55
  00088	e5803048	 str         r3, [r0, #0x48]

; 453  :     PinMuxSetup();    

  0008c	e3a00cff	 mov         r0, #0xFF, 24
  00090	e59f5258	 ldr         r5, [pc, #0x258]
  00094	e3a01c7f	 mov         r1, #0x7F, 24
  00098	e38070ff	 orr         r7, r0, #0xFF
  0009c	e3a04000	 mov         r4, #0
  000a0	e3a03000	 mov         r3, #0
  000a4	e3a02000	 mov         r2, #0
  000a8	e38160ff	 orr         r6, r1, #0xFF
  000ac		 |$LL16@PlatformSe|
  000ac	e0833005	 add         r3, r3, r5
  000b0	e5933004	 ldr         r3, [r3, #4]
  000b4	e1a00002	 mov         r0, r2
  000b8	e0031006	 and         r1, r3, r6
  000bc	eb000000	 bl          SOCSetPadConfig
  000c0	e2844001	 add         r4, r4, #1
  000c4	e1a03184	 mov         r3, r4, lsl #3
  000c8	e19320b5	 ldrh        r2, [r3, +r5]
  000cc	e1520007	 cmp         r2, r7
  000d0	1afffff5	 bne         |$LL16@PlatformSe|

; 454  : 	
; 455  :     ClockSetup(opp_setting); 

  000d4	e59f0210	 ldr         r0, [pc, #0x210]
  000d8	e3a01000	 mov         r1, #0
  000dc	eb000000	 bl          OALPAtoVA
  000e0	e1a04000	 mov         r4, r0
  000e4	e3880b13	 orr         r0, r8, #0x13, 22
  000e8	e3a01000	 mov         r1, #0
  000ec	eb000000	 bl          OALPAtoVA
  000f0	e3a05312	 mov         r5, #0x12, 6
  000f4	e1a06000	 mov         r6, r0
  000f8	e3850a05	 orr         r0, r5, #5, 20
  000fc	e3a01000	 mov         r1, #0
  00100	eb000000	 bl          OALPAtoVA
  00104	e1a07000	 mov         r7, r0
  00108	e3850c4a	 orr         r0, r5, #0x4A, 24
  0010c	e3a01000	 mov         r1, #0
  00110	eb000000	 bl          OALPAtoVA
  00114	e59f31cc	 ldr         r3, [pc, #0x1CC]
  00118	e3a02003	 mov         r2, #3
  0011c	e5842040	 str         r2, [r4, #0x40]
  00120	e5933000	 ldr         r3, [r3]
  00124	e59f51b8	 ldr         r5, [pc, #0x1B8]
  00128	e1a04000	 mov         r4, r0
  0012c	e3530001	 cmp         r3, #1
  00130	1a000006	 bne         |$LN20@PlatformSe|
  00134	eb000000	 bl          Omap37xx_core_dpll_init
  00138	eb000000	 bl          Omap37xx_dpll4_init
  0013c	e2850030	 add         r0, r5, #0x30
  00140	eb000000	 bl          Mpu_dpll_init
  00144	e2850030	 add         r0, r5, #0x30
  00148	eb000000	 bl          Iva_dpll_init
  0014c	eb000000	 bl          Omap37xx_per_dpll_init
  00150		 |$LN20@PlatformSe|
  00150	e5963000	 ldr         r3, [r6]
  00154	e3a02312	 mov         r2, #0x12, 6

; 456  : 
; 457  : 	GpioSetup();

  00158	e3a01000	 mov         r1, #0
  0015c	e3833009	 orr         r3, r3, #9
  00160	e5863000	 str         r3, [r6]
  00164	e5b63010	 ldr         r3, [r6, #0x10]!
  00168	e3820831	 orr         r0, r2, #0x31, 16
  0016c	e3833009	 orr         r3, r3, #9
  00170	e5863000	 str         r3, [r6]
  00174	e5973000	 ldr         r3, [r7]
  00178	e3833bd2	 orr         r3, r3, #0xD2, 22
  0017c	e5873000	 str         r3, [r7]
  00180	e5b73010	 ldr         r3, [r7, #0x10]!
  00184	e3833bd2	 orr         r3, r3, #0xD2, 22
  00188	e5873000	 str         r3, [r7]
  0018c	e5943010	 ldr         r3, [r4, #0x10]
  00190	e3c33010	 bic         r3, r3, #0x10
  00194	e5843010	 str         r3, [r4, #0x10]
  00198	e5943010	 ldr         r3, [r4, #0x10]
  0019c	e3c33008	 bic         r3, r3, #8
  001a0	e5843010	 str         r3, [r4, #0x10]
  001a4	eb000000	 bl          OALPAtoVA
  001a8	e3e03080	 mvn         r3, #0x80
  001ac	e5803034	 str         r3, [r0, #0x34]

; 458  : 
; 459  :     // configure i2c devices
; 460  :     OALI2CInit(OMAP_DEVICE_I2C1);

  001b0	e3a0000c	 mov         r0, #0xC
  001b4	eb000000	 bl          OALI2CInit

; 461  :     //OALI2CInit(OMAP_DEVICE_I2C2);
; 462  :     //OALI2CInit(OMAP_DEVICE_I2C3);
; 463  : 
; 464  :     OALI2CPostInit();	

  001b8	eb000000	 bl          OALI2CPostInit

; 465  : 	
; 466  :     InitTwlPower();

  001bc	eb000000	 bl          InitTwlPower

; 467  : 
; 468  :     UpdateVoltageLevels(opp_setting);

  001c0	e59f0118	 ldr         r0, [pc, #0x118]
  001c4	e3a01000	 mov         r1, #0
  001c8	eb000000	 bl          OALPAtoVA
  001cc	e3a03812	 mov         r3, #0x12, 16
  001d0	e3833012	 orr         r3, r3, #0x12
  001d4	e1a04000	 mov         r4, r0
  001d8	e5843020	 str         r3, [r4, #0x20]
  001dc	e3a03801	 mov         r3, #1, 16
  001e0	e5843024	 str         r3, [r4, #0x24]
  001e4	e3a03000	 mov         r3, #0
  001e8	e5843028	 str         r3, [r4, #0x28]
  001ec	e3a03817	 mov         r3, #0x17, 16
  001f0	e5843034	 str         r3, [r4, #0x34]
  001f4	e3a03005	 mov         r3, #5
  001f8	e5843038	 str         r3, [r4, #0x38]
  001fc	e5953038	 ldr         r3, [r5, #0x38]
  00200	e3a01602	 mov         r1, #2, 12
  00204	e3812a02	 orr         r2, r1, #2, 20
  00208	e1823c03	 orr         r3, r2, r3, lsl #24
  0020c	e584302c	 str         r3, [r4, #0x2C]
  00210	e595303c	 ldr         r3, [r5, #0x3C]
  00214	e3811008	 orr         r1, r1, #8
  00218	e3a00b7d	 mov         r0, #0x7D, 22
  0021c	e1823c03	 orr         r3, r2, r3, lsl #24
  00220	e5843030	 str         r3, [r4, #0x30]
  00224	e5953038	 ldr         r3, [r5, #0x38]
  00228	e3802001	 orr         r2, r0, #1
  0022c	e1813403	 orr         r3, r1, r3, lsl #8
  00230	e58430b0	 str         r3, [r4, #0xB0]
  00234	e595303c	 ldr         r3, [r5, #0x3C]
  00238	e1813403	 orr         r3, r1, r3, lsl #8
  0023c	e58430d0	 str         r3, [r4, #0xD0]
  00240	e3801010	 orr         r1, r0, #0x10
  00244	e58420b4	 str         r2, [r4, #0xB4]
  00248	e3e034bf	 mvn         r3, #0xBF, 8
  0024c	e58410b8	 str         r1, [r4, #0xB8]
  00250	e58420d4	 str         r2, [r4, #0xD4]
  00254	e22338ff	 eor         r3, r3, #0xFF, 16
  00258	e3e024c3	 mvn         r2, #0xC3, 8
  0025c	e58410d8	 str         r1, [r4, #0xD8]
  00260	e58430bc	 str         r3, [r4, #0xBC]
  00264	e22238ff	 eor         r3, r2, #0xFF, 16
  00268	e58430dc	 str         r3, [r4, #0xDC]
  0026c	e59430b0	 ldr         r3, [r4, #0xB0]
  00270	e3a00064	 mov         r0, #0x64
  00274	e3833001	 orr         r3, r3, #1
  00278	e58430b0	 str         r3, [r4, #0xB0]
  0027c	e59430d0	 ldr         r3, [r4, #0xD0]
  00280	e3833001	 orr         r3, r3, #1
  00284	e58430d0	 str         r3, [r4, #0xD0]
  00288	e59430b0	 ldr         r3, [r4, #0xB0]
  0028c	e3833008	 orr         r3, r3, #8
  00290	e58430b0	 str         r3, [r4, #0xB0]
  00294	e59430d0	 ldr         r3, [r4, #0xD0]
  00298	e3833008	 orr         r3, r3, #8
  0029c	e58430d0	 str         r3, [r4, #0xD0]
  002a0	e59430b0	 ldr         r3, [r4, #0xB0]
  002a4	e3833006	 orr         r3, r3, #6
  002a8	e58430b0	 str         r3, [r4, #0xB0]
  002ac	e59430d0	 ldr         r3, [r4, #0xD0]
  002b0	e3833006	 orr         r3, r3, #6
  002b4	e58430d0	 str         r3, [r4, #0xD0]
  002b8	eb000000	 bl          OALStall
  002bc	e59430b0	 ldr         r3, [r4, #0xB0]
  002c0	e3c3300f	 bic         r3, r3, #0xF
  002c4	e58430b0	 str         r3, [r4, #0xB0]
  002c8	e59430d0	 ldr         r3, [r4, #0xD0]
  002cc	e3c3300f	 bic         r3, r3, #0xF
  002d0	e58430d0	 str         r3, [r4, #0xD0]

; 469  : 
; 470  :     MemorySetup();

  002d4	eb000000	 bl          MemorySetup

; 471  : }

  002d8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  002dc	e12fff1e	 bx          lr
  002e0		 |$LN40@PlatformSe|
  002e0		 |$LN41@PlatformSe|
  002e0	48307200	 DCD         0x48307200
  002e4		 |$LN42@PlatformSe|
  002e4	00000000	 DCD         |OMAP37x_OPP_Table|
  002e8		 |$LN43@PlatformSe|
  002e8	00000000	 DCD         |gCPU_family|
  002ec		 |$LN44@PlatformSe|
  002ec	48306d00	 DCD         0x48306d00
  002f0		 |$LN45@PlatformSe|
  002f0	00000000	 DCD         |?initialPinMux@?1??PinMuxSetup@@9@9|
  002f4		 |$M47107|

			 ENDP  ; |PlatformSetup|

	END
