; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\XLDR\UART\xldrmodem.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|xblock_cnt| %	0x4
|xack_cnt| %	0x4
|xnak_cnt| %	0x4
|xcan_cnt| %	0x4
|xothers_cnt| %	0x4
|checksum_error_cnt| % 0x4
|dup_pkt_cnt| %	0x4
	EXPORT	|XGetStats|
; File c:\wince600\platform\z2170p\src\bootloader\xldr\uart\xldrmodem.c

  00000			 AREA	 |.pdata|, PDATA
|$T532|	DCD	|$LN5@XGetStats|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XGetStats| PROC

; 66   : {

  00000		 |$LN5@XGetStats|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M529|
  00004	e1a0a003	 mov         r10, r3

; 67   : 	*p_xblock_cnt         = xblock_cnt;

  00008	e59f7048	 ldr         r7, [pc, #0x48]

; 68   : 	*p_xack_cnt           = xack_cnt;
; 69   : 	*p_xnak_cnt           = xnak_cnt;
; 70   : 	*p_xcan_cnt           = xcan_cnt;
; 71   : 	*p_xothers_cnt        = xothers_cnt;

  0000c	e59d8020	 ldr         r8, [sp, #0x20]

; 72   : 	*p_checksum_error_cnt = checksum_error_cnt;

  00010	e59d9024	 ldr         r9, [sp, #0x24]
  00014	e597e000	 ldr         lr, [r7]
  00018	e5974004	 ldr         r4, [r7, #4]
  0001c	e5975008	 ldr         r5, [r7, #8]
  00020	e597600c	 ldr         r6, [r7, #0xC]
  00024	e580e000	 str         lr, [r0]
  00028	e5970010	 ldr         r0, [r7, #0x10]
  0002c	e5814000	 str         r4, [r1]
  00030	e5971014	 ldr         r1, [r7, #0x14]

; 73   : 	*p_dup_pkt_cnt        = dup_pkt_cnt;

  00034	e59d3028	 ldr         r3, [sp, #0x28]
  00038	e5825000	 str         r5, [r2]
  0003c	e5972018	 ldr         r2, [r7, #0x18]
  00040	e58a6000	 str         r6, [r10]
  00044	e5880000	 str         r0, [r8]
  00048	e5891000	 str         r1, [r9]
  0004c	e5832000	 str         r2, [r3]

; 74   : }

  00050	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN6@XGetStats|
  00058		 |$LN7@XGetStats|
  00058	00000000	 DCD         |xblock_cnt|
  0005c		 |$M530|

			 ENDP  ; |XGetStats|

	EXPORT	|XWriteStats|

  00000			 AREA	 |.pdata|, PDATA
|$T542|	DCD	|$LN11@XWriteStat|
	DCD	0x40001400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XWriteStats| PROC

; 77   : {

  00000		 |$LN11@XWriteStat|
  00000		 |$M539|

; 78   :     if(c == XACK)
; 79   :         ++xack_cnt;

  00000	e59f2044	 ldr         r2, [pc, #0x44]
  00004	e3500006	 cmp         r0, #6
  00008	05923000	 ldreq       r3, [r2]
  0000c	02833001	 addeq       r3, r3, #1
  00010	05823000	 streq       r3, [r2]

; 86   : }

  00014	012fff1e	 bxeq        lr

; 80   :     else if(c == XNAK)

  00018	e3500015	 cmp         r0, #0x15

; 81   :         ++xnak_cnt;

  0001c	05923004	 ldreq       r3, [r2, #4]
  00020	02833001	 addeq       r3, r3, #1
  00024	05823004	 streq       r3, [r2, #4]

; 86   : }

  00028	012fff1e	 bxeq        lr

; 82   :     else if(c == XCAN)

  0002c	e3500018	 cmp         r0, #0x18

; 83   :         ++xcan_cnt;

  00030	05923008	 ldreq       r3, [r2, #8]
  00034	02833001	 addeq       r3, r3, #1
  00038	05823008	 streq       r3, [r2, #8]

; 84   :     else
; 85   :         ++xothers_cnt;

  0003c	1592300c	 ldrne       r3, [r2, #0xC]
  00040	12833001	 addne       r3, r3, #1
  00044	1582300c	 strne       r3, [r2, #0xC]

; 86   : }

  00048	e12fff1e	 bx          lr
  0004c		 |$LN12@XWriteStat|
  0004c		 |$LN13@XWriteStat|
  0004c	00000000	 DCD         |xack_cnt|
  00050		 |$M540|

			 ENDP  ; |XWriteStats|

	EXPORT	|XWriteChar|
	IMPORT	|XLDRWriteChar|

  00000			 AREA	 |.pdata|, PDATA
|$T554|	DCD	|$LN5@XWriteChar|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XWriteChar| PROC

; 89   : {

  00000		 |$LN5@XWriteChar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M551|
  00004	e1a04000	 mov         r4, r0

; 90   :     XWriteStats(c);

  00008	eb000000	 bl          XWriteStats

; 91   :     XLDRWriteChar(c);

  0000c	e1a00004	 mov         r0, r4
  00010	eb000000	 bl          XLDRWriteChar

; 92   : 	return 0;

  00014	e3a00000	 mov         r0, #0

; 93   : }

  00018	e8bd4010	 ldmia       sp!, {r4, lr}
  0001c	e12fff1e	 bx          lr
  00020		 |$M552|

			 ENDP  ; |XWriteChar|

	EXPORT	|XReceive|
	IMPORT	|XLDRReadCharMaxTime|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T619|	DCD	|$LN69@XReceive|
	DCD	0x4000a702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XReceive| PROC

; 96   : {

  00000		 |$LN69@XReceive|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M616|
  00008	e1a03000	 mov         r3, r0
  0000c	e58d3004	 str         r3, [sp, #4]
  00010	e58d2008	 str         r2, [sp, #8]
  00014	e1a0b001	 mov         r11, r1

; 97   :     int si, i;
; 98   :     int done = 0;
; 99   :     unsigned char us_ch;
; 100  : 
; 101  :     int xstate;
; 102  :     unsigned char check_sum;     /* sum of data bytes, ignores any carry */
; 103  :     unsigned char last_pkt_num = 0xff;
; 104  :     unsigned char pkt_num = 1;   /* starts from 1, wraps 0xff to 0x00, not to 0x01 */
; 105  :     unsigned char pkt_data_num = 0;
; 106  : 
; 107  :     i = 0;
; 108  :     check_sum = 0;
; 109  :     last_pkt_num = 0xff;
; 110  :     pkt_num = 1;
; 111  :     pkt_data_num = 0;
; 112  :     xstate = XSTATE_SOH_EOT;
; 113  :     memset(p_data_buff, 0, buff_size);

  00018	e1a0200b	 mov         r2, r11
  0001c	e3a01000	 mov         r1, #0
  00020	e3a05000	 mov         r5, #0
  00024	e3a07000	 mov         r7, #0
  00028	e3a0a000	 mov         r10, #0
  0002c	e3a09001	 mov         r9, #1
  00030	e3a08000	 mov         r8, #0
  00034	e3a04001	 mov         r4, #1
  00038	eb000000	 bl          memset
  0003c		 |$LL31@XReceive|

; 114  : 
; 115  :     XWriteChar(XNAK);
; 116  : 
; 117  :     /* Send NAK every 10 secs to start */
; 118  :     while (0 == (si = XLDRReadCharMaxTime(&us_ch, START_RESPONSE_TIMEOUT)))
; 119  :     {
; 120  :         XWriteChar(XNAK);

  0003c	e3a00015	 mov         r0, #0x15
  00040	eb000000	 bl          XWriteStats
  00044	e3a00015	 mov         r0, #0x15
  00048	eb000000	 bl          XLDRWriteChar
  0004c	e3a0100a	 mov         r1, #0xA
  00050	e28d0000	 add         r0, sp, #0
  00054	eb000000	 bl          XLDRReadCharMaxTime
  00058	e3500000	 cmp         r0, #0
  0005c	0afffff6	 beq         |$LL31@XReceive|

; 124  : 	{
; 125  : 		done = XERROR_START_RESPONSE;

  00060	43e05000	 mvnmi       r5, #0

; 121  :     }
; 122  : 
; 123  :     if (si < 0)

  00064	4a000085	 bmi         |$DONE$474|

; 126  : 		goto DONE;
; 127  : 	}
; 128  : 
; 129  :     while (i < buff_size)

  00068	e35b0000	 cmp         r11, #0
  0006c	da000083	 ble         |$DONE$474|
  00070	e59f6220	 ldr         r6, [pc, #0x220]
  00074		 |$LL28@XReceive|

; 130  :     {
; 131  :         switch(xstate)

  00074	e3540001	 cmp         r4, #1
  00078	0a000048	 beq         |$LN24@XReceive|
  0007c	e3540002	 cmp         r4, #2
  00080	0a000036	 beq         |$LN19@XReceive|
  00084	e3540003	 cmp         r4, #3
  00088	0a00002e	 beq         |$LN14@XReceive|
  0008c	e3540004	 cmp         r4, #4
  00090	0a00001f	 beq         |$LN11@XReceive|
  00094	e3540005	 cmp         r4, #5
  00098	1a000055	 bne         |$LN60@XReceive|

; 201  : 
; 202  :             case XSTATE_CHECK_SUM:
; 203  :                 if (check_sum != us_ch)

  0009c	e5dd3000	 ldrb        r3, [sp]
  000a0	e15a0003	 cmp         r10, r3
  000a4	0a00000d	 beq         |$LN8@XReceive|

; 204  :                 {
; 205  :                     XWriteChar(XNAK);

  000a8	e3a00015	 mov         r0, #0x15
  000ac	eb000000	 bl          XWriteStats
  000b0	e3a00015	 mov         r0, #0x15
  000b4	eb000000	 bl          XLDRWriteChar

; 206  : 
; 207  :                     /* start over again for this pkt */
; 208  : 					++checksum_error_cnt;

  000b8	e5963014	 ldr         r3, [r6, #0x14]

; 209  :                     i = i - pkt_data_num;

  000bc	e0477008	 sub         r7, r7, r8

; 210  :                     memset(p_data_buff+i, 0, pkt_data_num);

  000c0	e1a02008	 mov         r2, r8
  000c4	e2833001	 add         r3, r3, #1
  000c8	e5863014	 str         r3, [r6, #0x14]
  000cc	e59d3004	 ldr         r3, [sp, #4]
  000d0	e3a01000	 mov         r1, #0
  000d4	e0870003	 add         r0, r7, r3
  000d8	eb000000	 bl          memset

; 211  :                 }
; 212  :                 else

  000dc	ea000006	 b           |$LN7@XReceive|
  000e0		 |$LN8@XReceive|

; 213  :                 {
; 214  :                     /* got one pkt */
; 215  :                     XWriteChar(XACK);

  000e0	e3a00006	 mov         r0, #6
  000e4	eb000000	 bl          XWriteStats
  000e8	e3a00006	 mov         r0, #6
  000ec	eb000000	 bl          XLDRWriteChar

; 216  :                     ++xblock_cnt;

  000f0	e5963000	 ldr         r3, [r6]
  000f4	e2833001	 add         r3, r3, #1
  000f8	e5863000	 str         r3, [r6]
  000fc		 |$LN7@XReceive|

; 217  :                 }
; 218  : 
; 219  :                 /* next pkt */
; 220  :                 ++pkt_num;

  000fc	e2893001	 add         r3, r9, #1
  00100	e20390ff	 and         r9, r3, #0xFF

; 221  :                 check_sum = 0;

  00104	e3a0a000	 mov         r10, #0

; 222  :                 pkt_data_num = 0;

  00108	e3a08000	 mov         r8, #0

; 223  :                 xstate = XSTATE_SOH_EOT;

  0010c	e3a04001	 mov         r4, #1

; 224  :             break;

  00110	ea00002e	 b           |$LN20@XReceive|
  00114		 |$LN11@XReceive|

; 190  : 
; 191  :             case XSTATE_DATA:
; 192  :                 p_data_buff[i++] = us_ch;
; 193  :                 check_sum = (unsigned char)(check_sum + us_ch);
; 194  :                 ++pkt_data_num;

  00114	e5dd2000	 ldrb        r2, [sp]
  00118	e59d1004	 ldr         r1, [sp, #4]
  0011c	e2883001	 add         r3, r8, #1
  00120	e20380ff	 and         r8, r3, #0xFF
  00124	e082300a	 add         r3, r2, r10
  00128	e7c72001	 strb        r2, [r7, +r1]

; 195  :                 if(pkt_data_num >= 128)

  0012c	e203a0ff	 and         r10, r3, #0xFF
  00130	e3580080	 cmp         r8, #0x80
  00134	e2877001	 add         r7, r7, #1
  00138	3a000024	 bcc         |$LN20@XReceive|

; 196  :                 {
; 197  :                     pkt_data_num = 0;

  0013c	e3a08000	 mov         r8, #0

; 198  :                     xstate = XSTATE_CHECK_SUM;

  00140	e3a04005	 mov         r4, #5

; 199  :                 }
; 200  :             break;

  00144	ea000021	 b           |$LN20@XReceive|
  00148		 |$LN14@XReceive|

; 180  : 
; 181  :             case XSTATE_PKT_NUM_1COMPLEMENT:
; 182  :                 if((pkt_num + us_ch) != 0xff)

  00148	e5dd3000	 ldrb        r3, [sp]
  0014c	e0833009	 add         r3, r3, r9
  00150	e35300ff	 cmp         r3, #0xFF
  00154	1a000034	 bne         |$LN62@XReceive|

; 188  :                     xstate = XSTATE_DATA;

  00158	e3a04004	 mov         r4, #4

; 189  :             break;

  0015c	ea00001b	 b           |$LN20@XReceive|
  00160		 |$LN19@XReceive|

; 146  :             break;
; 147  : 
; 148  :             case XSTATE_PKT_NUM:
; 149  : #if 0
; 150  :                 if (pkt_num != us_ch)
; 151  :                 {
; 152  :                     XWriteChar(XCAN);
; 153  :                     done = XERROR_PKT_NUM;
; 154  :                 }
; 155  :                 else
; 156  :                     xstate = XSTATE_PKT_NUM_1COMPLEMENT;
; 157  : #else
; 158  :                 if (us_ch == pkt_num)

  00160	e5dd3000	 ldrb        r3, [sp]
  00164	e1530009	 cmp         r3, r9

; 159  :                 {
; 160  :                     /* Good. Move on */
; 161  :                     xstate = XSTATE_PKT_NUM_1COMPLEMENT;

  00168	03a04003	 moveq       r4, #3
  0016c	0a000017	 beq         |$LN20@XReceive|

; 162  :                 }
; 163  :                 else if (us_ch == last_pkt_num)

  00170	e35300ff	 cmp         r3, #0xFF
  00174	1a000032	 bne         |$LN16@XReceive|

; 164  :                 {
; 165  :                     /* This is a repeat.  Pretend this is the first time to receive the pkt. */
; 166  : 					++dup_pkt_cnt;

  00178	e5963018	 ldr         r3, [r6, #0x18]

; 167  :                     pkt_num = last_pkt_num;
; 168  :                     i = i - 128;
; 169  :                     --xblock_cnt;

  0017c	e5962000	 ldr         r2, [r6]
  00180	e3a090ff	 mov         r9, #0xFF
  00184	e2833001	 add         r3, r3, #1
  00188	e2422001	 sub         r2, r2, #1
  0018c	e5863018	 str         r3, [r6, #0x18]
  00190	e5862000	 str         r2, [r6]
  00194	e2477080	 sub         r7, r7, #0x80
  00198	e3a04003	 mov         r4, #3
  0019c	ea00000b	 b           |$LN20@XReceive|
  001a0		 |$LN24@XReceive|

; 132  :         {
; 133  :             case XSTATE_SOH_EOT:
; 134  :                 if (us_ch == XEOT)

  001a0	e5dd3000	 ldrb        r3, [sp]
  001a4	e3530004	 cmp         r3, #4
  001a8	1a000005	 bne         |$LN23@XReceive|

; 135  :                 {
; 136  :                     XWriteChar(XNAK);

  001ac	e3a00015	 mov         r0, #0x15
  001b0	eb000000	 bl          XWriteStats
  001b4	e3a00015	 mov         r0, #0x15
  001b8	eb000000	 bl          XLDRWriteChar

; 137  :                     xstate = XSTATE_EOT2;

  001bc	e3a04006	 mov         r4, #6
  001c0	ea000002	 b           |$LN20@XReceive|
  001c4		 |$LN23@XReceive|

; 138  :                 }
; 139  :                 else if (us_ch != XSOH)

  001c4	e3530001	 cmp         r3, #1
  001c8	1a000027	 bne         |$LN63@XReceive|

; 143  :                 }
; 144  :                 else
; 145  :                     xstate = XSTATE_PKT_NUM;

  001cc	e3a04002	 mov         r4, #2
  001d0		 |$LN20@XReceive|

; 235  : 
; 236  :         }  /* switch */
; 237  : 
; 238  :         if (done)
; 239  :             break;
; 240  : 
; 241  : 
; 242  :         /* Wait for next incoming char */
; 243  :         si = XLDRReadCharMaxTime(&us_ch, RECEIVE_TIMEOUT);

  001d0	e3a01001	 mov         r1, #1
  001d4	e28d0000	 add         r0, sp, #0
  001d8	eb000000	 bl          XLDRReadCharMaxTime
  001dc	e3500000	 cmp         r0, #0

; 244  :         if (si < 0) 

  001e0	4a00001f	 bmi         |$LN57@XReceive|

; 247  :             break;
; 248  :         }
; 249  : 		else if (si == 0)

  001e4	0a00001c	 beq         |$LN58@XReceive|

; 126  : 		goto DONE;
; 127  : 	}
; 128  : 
; 129  :     while (i < buff_size)

  001e8	e157000b	 cmp         r7, r11
  001ec	baffffa0	 blt         |$LL28@XReceive|
  001f0	ea000022	 b           |$DONE$474|
  001f4		 |$LN60@XReceive|

; 130  :     {
; 131  :         switch(xstate)

  001f4	e3540006	 cmp         r4, #6
  001f8	0a000005	 beq         |$LN6@XReceive|

; 230  : 
; 231  :             default:
; 232  :                 XWriteChar(XCAN);

  001fc	e3a00018	 mov         r0, #0x18
  00200	eb000000	 bl          XWriteStats
  00204	e3a00018	 mov         r0, #0x18
  00208	eb000000	 bl          XLDRWriteChar

; 233  :                 done = XERROR_UNKNOWN_STATE;

  0020c	e3e05005	 mvn         r5, #5

; 234  :             break;

  00210	ea00001a	 b           |$DONE$474|
  00214		 |$LN6@XReceive|

; 225  : 
; 226  :             case XSTATE_EOT2:
; 227  :                 XWriteChar(XACK);

  00214	e3a00006	 mov         r0, #6
  00218	eb000000	 bl          XWriteStats
  0021c	e3a00006	 mov         r0, #6
  00220	eb000000	 bl          XLDRWriteChar

; 228  :                 done = XERROR_NO_ERROR;

  00224	e3a05001	 mov         r5, #1

; 229  :             break;

  00228	ea000014	 b           |$DONE$474|
  0022c		 |$LN62@XReceive|

; 183  :                 {
; 184  :                     XWriteChar(XCAN);

  0022c	e3a00018	 mov         r0, #0x18
  00230	eb000000	 bl          XWriteStats
  00234	e3a00018	 mov         r0, #0x18
  00238	eb000000	 bl          XLDRWriteChar

; 185  :                     done = XERROR_PKT_NUM_1COMPL;

  0023c	e3e05003	 mvn         r5, #3

; 186  :                 }
; 187  :                 else

  00240	ea00000e	 b           |$DONE$474|
  00244		 |$LN16@XReceive|

; 170  :                     xstate = XSTATE_PKT_NUM_1COMPLEMENT;
; 171  :                 }
; 172  :                 else
; 173  :                 {
; 174  :                     /* Not expected pkt_num and not a repeat.  This is bad. */
; 175  :                     XWriteChar(XCAN);

  00244	e3a00018	 mov         r0, #0x18
  00248	eb000000	 bl          XWriteStats
  0024c	e3a00018	 mov         r0, #0x18
  00250	eb000000	 bl          XLDRWriteChar

; 176  :                     done = XERROR_PKT_NUM;

  00254	e3e05002	 mvn         r5, #2

; 177  :                 }
; 178  : #endif
; 179  :             break;

  00258	ea000008	 b           |$DONE$474|
  0025c		 |$LN58@XReceive|

; 250  : 		{
; 251  : 			done = XERROR_TIMEOUT;

  0025c	e3e05006	 mvn         r5, #6
  00260	ea000006	 b           |$DONE$474|
  00264		 |$LN57@XReceive|

; 245  :         {
; 246  :             done = XERROR_RECEIVE;

  00264	e3e05004	 mvn         r5, #4
  00268	ea000004	 b           |$DONE$474|
  0026c		 |$LN63@XReceive|

; 140  :                 {
; 141  :                     XWriteChar(XCAN);

  0026c	e3a00018	 mov         r0, #0x18
  00270	eb000000	 bl          XWriteStats
  00274	e3a00018	 mov         r0, #0x18
  00278	eb000000	 bl          XLDRWriteChar

; 142  :                     done = XERROR_SOH_EOT;

  0027c	e3e05001	 mvn         r5, #1
  00280		 |$DONE$474|

; 252  : 			break;
; 253  : 		}
; 254  :     
; 255  :     }  /* while */
; 256  : 
; 257  : DONE:
; 258  : 	*p_receive_size = (unsigned int)i;

  00280	e59d3008	 ldr         r3, [sp, #8]

; 259  :     return done;
; 260  : }  /* XReceive */

  00284	e1a00005	 mov         r0, r5
  00288	e5837000	 str         r7, [r3]
  0028c	e28dd00c	 add         sp, sp, #0xC
  00290	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00294	e12fff1e	 bx          lr
  00298		 |$LN70@XReceive|
  00298		 |$LN71@XReceive|
  00298	00000000	 DCD         |xblock_cnt|
  0029c		 |$M617|

			 ENDP  ; |XReceive|

	END
